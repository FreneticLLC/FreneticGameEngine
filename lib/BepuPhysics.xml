<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BepuPhysics</name>
    </assembly>
    <members>
        <member name="T:BepuPhysics.BatchCompressor">
            <summary>
            Handles the movement of constraints from higher indexed batches into lower indexed batches to avoid accumulating a bunch of unnecessary ConstraintBatches.
            </summary>
        </member>
        <member name="P:BepuPhysics.BatchCompressor.TargetCandidateFraction">
            <summary>
            Gets or sets the desired number of candidates to analyze as a fraction of the total number of constraints.
            </summary>
        </member>
        <member name="P:BepuPhysics.BatchCompressor.MaximumCompressionFraction">
            <summary>
            Gets or sets the maximum number of constraint moves that can occur in a single execution of Compress as a fraction of the total number of constraints.
            </summary>       
        </member>
        <member name="F:BepuPhysics.BatchCompressor.nextBatchIndex">
            <summary>
            Index of the constraint batch to optimize.
            </summary>
        </member>
        <member name="M:BepuPhysics.BatchCompressor.Compress(BepuUtilities.Memory.BufferPool,BepuUtilities.IThreadDispatcher,System.Boolean)">
            <summary>
            Incrementally finds and applies a set of compressions to apply to the constraints in the solver's batches.
            Constraints in higher index batches try to move to lower index batches whenever possible.
            </summary>
        </member>
        <member name="T:BepuPhysics.BodyMemoryLocation">
            <summary>
            Location of a body in memory.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyMemoryLocation.SetIndex">
            <summary>
            Index of the set owning the body reference. If the set index is 0, the body is awake. If the set index is greater than zero, the body is asleep.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyMemoryLocation.Index">
            <summary>
            Index of the body within its owning set.
            </summary>
        </member>
        <member name="T:BepuPhysics.Bodies">
            <summary>
            Collection of all allocated bodies.
            </summary>
        </member>
        <member name="F:BepuPhysics.Bodies.HandleToLocation">
            <summary>
            Remaps a body handle integer value to the actual array index of the body.
            The backing array index may change in response to cache optimization.
            </summary>
        </member>
        <member name="F:BepuPhysics.Bodies.HandlePool">
            <summary>
            Pool from which handles are pulled for new bodies.
            </summary>
        </member>
        <member name="F:BepuPhysics.Bodies.Sets">
            <summary>
            The set of existing bodies. The slot at index 0 contains all active bodies. Later slots, if allocated, contain the bodies associated with inactive islands.
            Note that this buffer does not necessarily contain contiguous elements. When a set is removed, a gap remains.
            </summary>
        </member>
        <member name="P:BepuPhysics.Bodies.ActiveSet">
            <summary>
            Gets a reference to the active set, stored in the index 0 of the Sets buffer.
            </summary>
            <returns>Reference to the active body set.</returns>
        </member>
        <member name="P:BepuPhysics.Bodies.Item(BepuPhysics.BodyHandle)">
            <summary>
            Gets a reference to a body in the collection.
            </summary>
            <param name="handle">Handle of the body to pull a reference for.</param>
            <returns>Reference to the requested body.</returns>
            <remarks>This is an alias for the older <see cref="M:BepuPhysics.Bodies.GetBodyReference(BepuPhysics.BodyHandle)"/> and the <see cref="T:BepuPhysics.BodyReference"/> constructor. They are all equivalent.</remarks>
        </member>
        <member name="P:BepuPhysics.Bodies.Pool">
            <summary>
            Gets the pool used by the bodies collection to allocate and free memory.
            </summary>
        </member>
        <member name="P:BepuPhysics.Bodies.MinimumConstraintCapacityPerBody">
            <summary>
            Gets or sets the minimum constraint capacity for each body. Future resizes or allocations will obey this minimum, but changing this does not immediately resize existing lists.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.#ctor(BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.Shapes,BepuPhysics.CollisionDetection.BroadPhase,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a new bodies collection. Initialize must be called for the instance to be ready for use.
            </summary>
            <param name="pool">Pool for the collection to pull persistent allocations from.</param>
            <param name="shapes">Shapes referenced by the collection's bodies.</param>
            <param name="broadPhase">Broad phase containing the body collidables.</param>
            <param name="initialBodyCapacity">Initial number of bodies to allocate space for in the active set.</param>
            <param name="initialIslandCapacity">Initial number of islands to allocate space for in the Sets buffer.</param>
            <param name="initialConstraintCapacityPerBody">Expected number of constraint references per body to allocate space for.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.Initialize(BepuPhysics.Solver,BepuPhysics.IslandAwakener,BepuPhysics.IslandSleeper)">
            <summary>
            Initializes the bodies set. Used to complete bidirectional dependencies.
            </summary>
            <param name="solver">Solver responsible for the constraints connected to the collection's bodies.</param>
            <param name="awakener">Island awakener to use when bodies undergo transitions requiring that they exist in the active set.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.UpdateBounds(BepuPhysics.BodyHandle)">
            <summary>
            Updates the bounds held within the broad phase for the body's current state. Does not expand the bounding box by velocity. If there is no shape associated with the body, this does nothing.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.Add(BepuPhysics.BodyDescription@)">
            <summary>
            Adds a new active body to the simulation.
            </summary>
            <param name="description">Description of the body to add.</param>
            <returns>Handle of the created body.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.RemoveAt(System.Int32)">
            <summary>
            Removes an active body by its index. Any constraints connected to this body will be removed. Assumes that the input location is valid.
            </summary>
            <param name="activeBodyIndex">Index of the active body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.Remove(BepuPhysics.BodyHandle)">
            <summary>
            Removes a body from the set by its handle. If the body is inactive, all bodies in its island will be forced active.
            </summary>
            <param name="handle">Handle of the body to remove.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.AddConstraint(System.Int32,BepuPhysics.ConstraintHandle,System.Int32)">
            <summary>
            Adds a constraint to an active body's constraint list.
            </summary>
            <param name="bodyIndex">Index of the body to add the constraint to.</param>
            <param name="constraintHandle">Handle of the constraint to add.</param>
            <param name="indexInConstraint">Index of the body in the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.RemoveConstraintReference(System.Int32,BepuPhysics.ConstraintHandle)">
            <summary>
            Removes a constraint from an active body's constraint list.
            </summary>
            <param name="bodyIndex">Index of the active body.</param>
            <param name="constraintHandle">Handle of the constraint to remove.</param>
            <returns>True if the number of constraints remaining attached to the body is 0, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.IsKinematic(BepuPhysics.BodyInertia)">
            <summary>
            Gets whether the inertia matches that of a kinematic body (that is, all inverse mass and inertia components are zero).
            </summary>
            <param name="inertia">Body inertia to analyze.</param>
            <returns>True if all components of inverse mass and inertia are zero, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.IsKinematicUnsafeGCHole(BepuPhysics.BodyInertia@)">
            <summary>
            Gets whether the inertia matches that of a kinematic body (that is, all inverse mass and inertia components are zero).
            </summary>
            <param name="inertia">Body inertia to analyze. Must be a reference to fixed data; a pointer will be taken.</param>
            <returns>True if all components of inverse mass and inertia are zero, false otherwise.</returns>
            <remarks>This is not exposed by default because of the risk of a non-obvious GC hole.
            It exists because it's a mildly more convenient form than the pointer overload, and every use within the engine references only pinned data.</remarks>
        </member>
        <member name="M:BepuPhysics.Bodies.IsKinematic(BepuPhysics.BodyInertiaWide)">
            <summary>
            Checks inertia lanes for kinematicity (all inverse mass and inertia values are zero).
            </summary>
            <param name="inertia">Inertia to examine for kinematicity.</param>
            <returns>Mask of lanes which contain zeroed inverse masses and inertias.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.IsKinematic(BepuPhysics.BodyInertia*)">
            <summary>
            Gets whether the inertia matches that of a kinematic body (that is, all inverse mass and inertia components are zero).
            </summary>
            <param name="inertia">Body inertia to analyze.</param>
            <returns>True if all components of inverse mass and inertia are zero, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.HasLockedInertia(BepuUtilities.Symmetric3x3)">
            <summary>
            Gets whether the angular inertia matches that of a kinematic body (that is, all inverse inertia tensor components are zero).
            </summary>
            <param name="inertia">Body inertia to analyze.</param>
            <returns>True if all components of inverse mass and inertia are zero, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.HasLockedInertia(BepuUtilities.Symmetric3x3*)">
            <summary>
            Gets whether the angular inertia matches that of a kinematic body (that is, all inverse inertia tensor components are zero).
            </summary>
            <param name="inertia">Body inertia to analyze.</param>
            <returns>True if all components of inverse mass and inertia are zero, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.SetLocalInertia(BepuPhysics.BodyHandle,BepuPhysics.BodyInertia@)">
            <summary>
            Changes the local mass and inertia tensor associated with a body. Properly handles the transition between kinematic and dynamic.
            If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed.
            Wakes up the body.
            </summary>
            <param name="handle">Handle of the body whose inertia should change.</param>
            <param name="localInertia">New local inertia for the body.</param>
            <remarks>
            This function is only necessary when the inertia change could potentially result in a transition between dynamic and kinematic states.
            If it is guaranteed to be dynamic before and after the change, the inertia can be directly modified without issue.
            </remarks>
        </member>
        <member name="M:BepuPhysics.Bodies.SetShape(BepuPhysics.BodyHandle,BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a body. Properly handles the transition between shapeless and shapeful. If the body is inactive, it will be forced awake.
            Updates the bounds of the body in the broad phase.
            </summary>
            <param name="handle">Handle of the body to change the shape of.</param>
            <param name="newShape">Index of the new shape to use for the body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ApplyDescription(BepuPhysics.BodyHandle,BepuPhysics.BodyDescription@)">
            <summary>
            Applies a description to a body. Properly handles any transitions between dynamic and kinematic and between shapeless and shapeful.
            If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed. Wakes up the body.
            Updates the bounds of the body in the broad phase.
            </summary>
            <param name="handle">Handle of the body to receive the description.</param>
            <param name="description">Description to apply to the body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GetDescription(BepuPhysics.BodyHandle,BepuPhysics.BodyDescription@)">
            <summary>
            Gets the description of a body by handle.
            </summary>
            <param name="handle">Handle of the body to look up.</param>
            <param name="description">Description of the body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GetDescription(BepuPhysics.BodyHandle)">
            <summary>
            Gets the description of a body by handle.
            </summary>
            <param name="handle">Handle of the body to look up.</param>
            <returns>Description of the body.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.GetBodyReference(BepuPhysics.BodyHandle)">
            <summary>
            Gets a reference to a body by its handle.
            </summary>
            <param name="handle">Handle of the body to grab a reference of.</param>
            <returns>Reference to the desired body.</returns>
            <remarks>This is an alias for <see cref="P:BepuPhysics.Bodies.Item(BepuPhysics.BodyHandle)"/> and the <see cref="T:BepuPhysics.BodyReference"/> constructor. They are all equivalent.</remarks>
        </member>
        <member name="M:BepuPhysics.Bodies.BodyExists(BepuPhysics.BodyHandle)">
            <summary>
            Checks whether a body handle is currently registered with the bodies set.
            </summary>
            <param name="bodyHandle">Handle to check for.</param>
            <returns>True if the handle exists in the collection, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.EnumerateConnectedBodyIndices``1(System.Int32,``0@)">
            <summary>
            Enumerates all the bodies connected to a given active body.
            Bodies which are connected by more than one constraint will be reported multiple times.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to execute on each connected body.</typeparam>
            <param name="activeBodyIndex">Index of the active body to enumerate the connections of. This body will not appear in the set of enumerated bodies, even if it is connected to itself somehow.</param>
            <param name="enumerator">Enumerator instance to run on each connected body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.EnumerateConnectedBodies``1(BepuPhysics.BodyHandle,``0@)">
            <summary>
            Enumerates all the bodies connected to a given body.
            Bodies which are connected by more than one constraint will be reported multiple times.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to execute on each connected body.</typeparam>
            <param name="bodyHandle">Handle of the body to enumerate the connections of. This body will not appear in the set of enumerated bodies, even if it is connected to itself somehow.</param>
            <param name="enumerator">Enumerator instance to run on each connected body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.Clear">
            <summary>
            Clears all bodies from all sets without releasing any memory that wouldn't be released by a sequence of regular removals.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.Resize(System.Int32)">
            <summary>
            Resizes the allocated spans for active body data. Note that this is conservative; it will never orphan existing objects.
            </summary>
            <param name="capacity">Target body data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ResizeConstraintListCapacities">
            <summary>
            Resizes all active body constraint lists to meet the MinimumConstraintCapacityPerBody. Inactive bodies are untouched.
            Resizes are guaranteed to never shrink a list below the current count.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.EnsureCapacity(System.Int32)">
            <summary>
            Increases the size of active body buffers if needed to hold the target capacity.
            </summary>
            <param name="capacity">Target data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.EnsureConstraintListCapacities">
            <summary>
            Ensures all active body constraint lists can hold at least MinimumConstraintCapacityPerBody constraints. Inactive bodies are untouched.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.Dispose">
            <summary>
            Returns all body resources to the pool used to create them.
            </summary>
            <remarks>The object can be reused if it is reinitialized by using EnsureCapacity or Resize.</remarks>
        </member>
        <member name="F:BepuPhysics.Bodies.DynamicLimit">
            <summary>
            Constraint body references greater than a given unsigned value are either kinematic (bit 30 set) or correspond to an empty lane (bit 31 set).
            </summary>
        </member>
        <member name="F:BepuPhysics.Bodies.BodyReferenceMask">
            <summary>
            Mask of bits containing the decoded body reference in a constraint body reference. For active constraints this would be the body index bits, for sleeping constraints this would be the body handle bits.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.IsEncodedDynamicReference(System.Int32)">
            <summary>
            Checks whether a constraint encoded body reference value refers to a dynamic body.
            </summary>
            <param name="encodedBodyReferenceValue">Raw encoded value taken from a constraint.</param>
            <returns>True if the encoded body reference refers to a dynamic body, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.IsEncodedKinematicReference(System.Int32)">
            <summary>
            Checks whether a constraint encoded body reference value refers to a kinematic body.
            </summary>
            <param name="encodedBodyReferenceValue">Raw encoded value taken from a constraint.</param>
            <returns>True if the encoded body reference refers to a kinematic body, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.TransposeMotionStates(BepuUtilities.Memory.Buffer{BepuPhysics.MotionState},BepuUtilities.Vector3Wide@,BepuUtilities.QuaternionWide@,BepuPhysics.BodyVelocityWide@)">
            <summary>
            Transposes of bundle of array-of-structures layout motion states into a bundle of array-of-structures-of-arrays layout.
            Size of buffer must be no larger than the <see cref="P:System.Numerics.Vector`1.Count"/>.
            </summary>
            <param name="states">Array-of-structures data to transpose.</param>
            <param name="position">Array-of-structures-of-arrays positions.</param>
            <param name="orientation">Array-of-structures-of-arrays orientations.</param>
            <param name="velocity">Array-of-structures-of-arrays velocities.</param>
        </member>
        <member name="T:BepuPhysics.BodyActivityDescription">
            <summary>
            Describes the thresholds for a body going to sleep.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivityDescription.SleepThreshold">
            <summary>
            Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivityDescription.MinimumTimestepCountUnderThreshold">
            <summary>
            The number of time steps that the body must be under the sleep threshold before the body becomes a sleep candidate.
            Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyActivityDescription.#ctor(System.Single,System.Byte)">
            <summary>
            Creates a body activity description.
            </summary>
            <param name="sleepThreshold">Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).</param>
            <param name="minimumTimestepCountUnderThreshold">The number of time steps that the body must be under the sleep threshold before the body becomes a sleep candidate.
            Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.</param>
        </member>
        <member name="M:BepuPhysics.BodyActivityDescription.op_Implicit(System.Single)~BepuPhysics.BodyActivityDescription">
            <summary>
            Creates a body activity description. Uses a <see cref="F:BepuPhysics.BodyActivityDescription.MinimumTimestepCountUnderThreshold"/> of 32.
            </summary>
            <param name="sleepThreshold">Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).
            Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.</param>
        </member>
        <member name="T:BepuPhysics.BodyDescription">
            <summary>
            Describes a body's state.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyDescription.Pose">
            <summary>
            Position and orientation of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyDescription.Velocity">
            <summary>
            Linear and angular velocity of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyDescription.LocalInertia">
            <summary>
            Mass and inertia tensor of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyDescription.Collidable">
            <summary>
            Shape and collision detection settings for the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyDescription.Activity">
            <summary>
            Sleeping settings for the body.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyDescription.GetDefaultSpeculativeMargin``1(``0@)">
            <summary>
            Computes a decent default speculative margin for a shape based on its minimum and maximum radii.
            </summary>
            <typeparam name="TShape">Type of the shape to compute a speculative margin for.</typeparam>
            <param name="shape">Shape to compute a speculative margin for.</param>
            <returns>Speculative margin for the given shape.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.GetDefaultActivity``1(``0@)">
            <summary>
            Computes a decent default activity description for a shape.
            </summary>
            <typeparam name="TShape">Type of the shape to create an activity description for.</typeparam>
            <param name="shape">Shape to create an activity description for.</param>
            <returns>Default activity description for the given shape.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateDynamic(BepuPhysics.RigidPose,BepuPhysics.BodyVelocity,BepuPhysics.BodyInertia,BepuPhysics.Collidables.CollidableDescription,BepuPhysics.BodyActivityDescription)">
            <summary>
            Creates a dynamic body description.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="inertia">Local inertia of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateDynamic(BepuPhysics.RigidPose,BepuPhysics.BodyInertia,BepuPhysics.Collidables.CollidableDescription,BepuPhysics.BodyActivityDescription)">
            <summary>
            Creates a dynamic body description with zero initial velocity.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="inertia">Local inertia of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexDynamic``1(BepuPhysics.RigidPose,BepuPhysics.BodyVelocity,System.Single,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a dynamic body description with collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="mass">Mass of the body. The inertia tensor will be calculated based on this mass and the shape.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexDynamic``1(BepuPhysics.RigidPose,System.Single,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a dynamic body description with zero initial velocity and collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="mass">Mass of the body. The inertia tensor will be calculated based on this mass and the shape.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateKinematic(BepuPhysics.RigidPose,BepuPhysics.BodyVelocity,BepuPhysics.Collidables.CollidableDescription,BepuPhysics.BodyActivityDescription)">
            <summary>
            Creates a kinematic body description.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateKinematic(BepuPhysics.RigidPose,BepuPhysics.Collidables.CollidableDescription,BepuPhysics.BodyActivityDescription)">
            <summary>
            Creates a kinematic body description with zero initial velocity.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexKinematic``1(BepuPhysics.RigidPose,BepuPhysics.BodyVelocity,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a kinematic body description with collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexKinematic``1(BepuPhysics.RigidPose,BepuPhysics.Collidables.Shapes,``0)">
            <summary>
            Creates a kinematic body description with zero initial velocity and collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="T:BepuPhysics.MotionState">
            <summary>
            Describes the pose and velocity of a body.
            </summary>
        </member>
        <member name="F:BepuPhysics.MotionState.Pose">
            <summary>
            Pose of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.MotionState.Velocity">
            <summary>
            Linear and angular velocity of the body.
            </summary>
        </member>
        <member name="T:BepuPhysics.RigidPose">
            <summary>
            Represents a rigid transformation.
            </summary>
        </member>
        <member name="F:BepuPhysics.RigidPose.Orientation">
            <summary>
            Orientation of the pose.
            </summary>
        </member>
        <member name="F:BepuPhysics.RigidPose.Position">
            <summary>
            Position of the pose.
            </summary>
        </member>
        <member name="P:BepuPhysics.RigidPose.Identity">
            <summary>
            Returns a pose with a position at (0,0,0) and identity orientation.
            </summary>
        </member>
        <member name="M:BepuPhysics.RigidPose.#ctor(System.Numerics.Vector3,System.Numerics.Quaternion)">
            <summary>
            Creates a rigid pose with the given position and orientation.
            </summary>
            <param name="position">Position of the pose.</param>
            <param name="orientation">Orientation of the pose.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.#ctor(System.Numerics.Vector3)">
            <summary>
            Creates a rigid pose with the given position and identity orientation.
            </summary>
            <param name="position">Position of the pose.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.op_Implicit(System.Numerics.Vector3)~BepuPhysics.RigidPose">
            <summary>
            Creates a pose by treating a <see cref="T:System.Numerics.Vector3"/> as a position. Orientation is set to identity.
            </summary>
            <param name="position">Position to use in the pose.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.op_Implicit(System.Numerics.Quaternion)~BepuPhysics.RigidPose">
            <summary>
            Creates a pose by treating a <see cref="T:System.Numerics.Quaternion"/> as an orientation in the pose. Position is set to zero.
            </summary>
            <param name="orientation">Orientation to use in the pose.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.op_Implicit(System.ValueTuple{System.Numerics.Vector3,System.Numerics.Quaternion})~BepuPhysics.RigidPose">
            <summary>
            Creates a pose from a tuple of a position and orientation.
            </summary>
            <param name="poseComponents">Position and orientation to use in the pose.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.Transform(System.Numerics.Vector3,BepuPhysics.RigidPose@,System.Numerics.Vector3@)">
            <summary>
            Transforms a vector by the rigid pose: v * pose.Orientation + pose.Position.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="pose">Pose to transform the vector with.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.TransformByInverse(System.Numerics.Vector3,BepuPhysics.RigidPose@,System.Numerics.Vector3@)">
            <summary>
            Transforms a vector by the inverse of a rigid pose: (v - pose.Position) * pose.Orientation^-1.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="pose">Pose to invert and transform the vector with.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.Invert(BepuPhysics.RigidPose@,BepuPhysics.RigidPose@)">
            <summary>
            Inverts the rigid transformation of the pose.
            </summary>
            <param name="pose">Pose to invert.</param>
            <param name="inverse">Inverse of the pose.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.MultiplyWithoutOverlap(BepuPhysics.RigidPose@,BepuPhysics.RigidPose@,BepuPhysics.RigidPose@)">
            <summary>
            Concatenates one rigid transform with another. The resulting transform is equivalent to performing transform a followed by transform b.
            </summary>
            <param name="a">First transform to concatenate.</param>
            <param name="b">Second transform to concatenate.</param>
            <param name="result">Result of the concatenation.</param>
        </member>
        <member name="T:BepuPhysics.BodyVelocity">
            <summary>
            Linear and angular velocity for a body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyVelocity.Linear">
            <summary>
            Linear velocity associated with the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyVelocity.Angular">
            <summary>
            Angular velocity associated with the body.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyVelocity.#ctor(System.Numerics.Vector3)">
            <summary>
            Creates a new set of body velocities. Angular velocity is set to zero.
            </summary>
            <param name="linear">Linear velocity to use for the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyVelocity.#ctor(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Creates a new set of body velocities.
            </summary>
            <param name="linear">Linear velocity to use for the body.</param>
            <param name="angular">Angular velocity to use for the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyVelocity.op_Implicit(System.Numerics.Vector3)~BepuPhysics.BodyVelocity">
            <summary>
            Creates a body velocity by treating a <see cref="T:System.Numerics.Vector3"/> as a linear velocity. Angular velocity is set to zero.
            </summary>
            <param name="linearVelocity">Linear velocity to use in the body velocity.</param>
        </member>
        <member name="M:BepuPhysics.BodyVelocity.op_Implicit(System.ValueTuple{System.Numerics.Vector3,System.Numerics.Vector3})~BepuPhysics.BodyVelocity">
            <summary>
            Creates a body velocity from a tuple of linear and angular velocities..
            </summary>
            <param name="velocities">Velocities to use in the body velocity.</param>
        </member>
        <member name="T:BepuPhysics.BodyInertia">
            <summary>
            Stores the inertia for a body.
            </summary>
            <remarks>This representation stores the inverse mass and inverse inertia tensor. Most of the high frequency use cases in the engine naturally use the inverse.</remarks>
        </member>
        <member name="F:BepuPhysics.BodyInertia.InverseInertiaTensor">
            <summary>
            Inverse of the body's inertia tensor.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyInertia.InverseMass">
            <summary>
            Inverse of the body's mass.
            </summary>
        </member>
        <member name="T:BepuPhysics.BodyInertias">
            <summary>
            Stores the local and world views of a body's inertia, packed together for efficient access.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyInertias.Local">
            <summary>
            Local inertia of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyInertias.World">
            <summary>
            Transformed world inertia of the body. Note that this is only valid between the velocity integration that updates it and the pose integration that follows.
            Outside of that execution window, this should be considered undefined.
            </summary>
            <remarks>
            We cache this here because velocity integration wants both the local and world inertias, and any integration happening within the solver will do so without the benefit of sequential loads.
            In that context, being able to load a single cache line to grab both local and world inertia helps quite a lot.</remarks>
        </member>
        <member name="T:BepuPhysics.BodyDynamics">
            <summary>
            Stores all body information needed by the solver together.
            </summary>
            <remarks>
            With 2.4's revamp of the solver, every solving stage loads pose, velocity, and inertia for every body in each constraint.
            L2 prefetchers often fetch memory in even-odd pairs of cache lines (see https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf#page=162).
            Since L2 is likely pulling in adjacent cache lines when loading either motion state or inertias, they might as well live together in one block.
            Note that this goes along with a change to the buffer pool's default alignment to 128 bytes.
            </remarks>
        </member>
        <member name="F:BepuPhysics.BodyDynamics.Motion">
            <summary>
            Pose and velocity information for the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyDynamics.Inertia">
            <summary>
            Inertia information for the body.
            </summary>
        </member>
        <member name="T:BepuPhysics.BodyActivity">
            <summary>
            Describes how a body sleeps, and its current state with respect to sleeping.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivity.SleepThreshold">
            <summary>
            Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).
            Setting this to a negative value guarantees the body cannot go to sleep without user action.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivity.MinimumTimestepsUnderThreshold">
            <summary>
            The number of time steps that the body must be under the sleep threshold before the body becomes a sleeping candidate.
            Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivity.TimestepsUnderThresholdCount">
            <summary>
            If the body is awake, this is the number of time steps that the body has had a velocity below the sleep threshold.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivity.SleepCandidate">
            <summary>
            True if this body is a candidate for being slept. If all the bodies that it is connected to by constraints are also candidates, this body may go to sleep.
            </summary>
        </member>
        <member name="T:BepuPhysics.BodyReference">
            <summary>
            Convenience structure for directly referring to a body's properties.
            </summary>
            <remarks>Note that this type makes no attempt to protect against unsafe modification of body properties, nor does modifying its properties try to wake up bodies if they are asleep.</remarks>
        </member>
        <member name="F:BepuPhysics.BodyReference.Handle">
            <summary>
            Handle of the body that this reference refers to.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyReference.Bodies">
            <summary>
            The bodies collection containing the body.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.#ctor(BepuPhysics.BodyHandle,BepuPhysics.Bodies)">
            <summary>
            Constructs a new body reference.
            </summary>
            <param name="handle">Handle of the body to refer to.</param>
            <param name="bodies">Collection containing the body.</param>
            <remarks>This is equivalent to <see cref="M:BepuPhysics.Bodies.GetBodyReference(BepuPhysics.BodyHandle)"/> and <see cref="P:BepuPhysics.Bodies.Item(BepuPhysics.BodyHandle)"/>.</remarks>
        </member>
        <member name="P:BepuPhysics.BodyReference.Exists">
            <summary>
            Gets whether the body reference exists within the body set. True if the handle maps to a valid memory location that agrees that the handle points to it, false otherwise.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.MemoryLocation">
            <summary>
            Gets a reference to the body's memory location stored in the handle to location mapping.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Awake">
            <summary>
            Gets or sets whether the body is in the active set. Setting this to true will attempt to wake the body; setting it to false will force the body and any constraint-connected bodies asleep.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Velocity">
            <summary>
            Gets a reference to the body's velocity.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Pose">
            <summary>
            Gets a reference to the body's pose.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.MotionState">
            <summary>
            Gets a reference to the body's motion state, including both pose and velocity.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Dynamics">
            <summary>
            Gets a reference to the body's solver-relevant state, including pose, velocity, and inertia.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Collidable">
            <summary>
            Gets a reference to the body's collidable.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.LocalInertia">
            <summary>
            Gets a reference to the body's local inertia.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Activity">
            <summary>
            Gets a reference to the body's activity state.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Constraints">
            <summary>
            Gets a reference to the list of the body's connected constraints.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.CollidableReference">
            <summary>
            <para>Gets a CollidableReference for this body. CollidableReferences uniquely identify a collidable object in a simulation by including both the dynamic/kinematic/static state of the object and its handle.</para>
            <para>Despite an unfortunate naming collision, CollidableReferences are distinct from a direct reference to a body's collidable data, which you can get from the Collidable property.</para>
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Kinematic">
            <summary>
            Gets whether the body is kinematic, meaning its inverse inertia and mass are all zero.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.HasLockedInertia">
            <summary>
            Gets whether the body has locked inertia, meaning its inverse inertia tensor is zero.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.BecomeKinematic">
            <summary>
            If the body is dynamic, turns the body kinematic by setting all inverse inertia and mass values to zero and activates it.
            Any constraints connected to the body that now only contain kinematic references are removed.
            If the body is kinematic, does nothing.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.SetLocalInertia(BepuPhysics.BodyInertia@)">
            <summary>
            Sets the body's local inertia to the provided inertia. Wakes up the body and correctly handles any transition between dynamic and kinematic states.
            If the body moves from dynamic to kinematic, any constraints connected to the body that now only contain kinematic references are removed.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.ComputeInverseInertia(BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes the world space inverse inertia tensor for the body based on the LocalInertia and Pose.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.GetDescription(BepuPhysics.BodyDescription@)">
            <summary>
            Gets a description of the body.
            </summary>
            <param name="description">Description of the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyDescription(BepuPhysics.BodyDescription@)">
            <summary>
            Sets a body's properties according to a description. Properly handles any transitions between dynamic and kinematic and between shapeless and shapeful.
            If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed. Wakes up the body and updates its bounds in the broad phase.
            </summary>
            <param name="description">Description of the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.SetShape(BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a body. Properly handles the transition between shapeless and shapeful. If the body is inactive, it will be forced awake. Updates the bounds of the body in the broad phase.
            </summary>
            <param name="newShape">Index of the new shape to use for the body.</param>
        </member>
        <member name="P:BepuPhysics.BodyReference.BoundingBox">
            <summary>
            Gets a copy of the body's bounding box. If the body has no shape, the bounding box has a min at float.MaxValue and a max at float.MinValue.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.GetBoundsReferencesFromBroadPhase(System.Numerics.Vector3*@,System.Numerics.Vector3*@)">
            <summary>
            Gets direct pointers to the body's bounding box minimum and maximum in the broad phase. Outputs null if the body has no shape.
            </summary>
            <param name="min">Pointer to the bounding box minimum in the broad phase. Null if the body has no shape.</param>
            <param name="max">Pointer to the bounding box maximum in the broad phase. Null if the body has no shape.</param>
            <returns>True if the body has a shape and bounds, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.BodyReference.UpdateBounds">
            <summary>
            Updates the body's bounds in the broad phase for its current state. Does not include velocity expansion. Does nothing if the body has no shape.
            </summary>
            <remarks>Can be useful if you made modifications to the body's state that you want reflected in the broad phase before the next timestep.
            For example, if you want to perform ray casts against the broad phase after moving objects around directly, their bounds must be updated or else the broad phase bounds will be out of date and the ray will likely miss.</remarks>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyImpulse(System.Numerics.Vector3,System.Numerics.Vector3,BepuPhysics.BodyInertia@,BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@)">
            <summary>
            Applies an impulse to a body by index. Does not wake the body up.
            </summary>
            <param name="pose">Pose of the body to apply impulse to.</param>
            <param name="velocity">Velocity of the body to apply impulse to.</param>
            <param name="localInertia">Local inertia of the body to apply impulse to.</param>
            <param name="impulse">Impulse to apply to the body.</param>
            <param name="impulseOffset">World space offset from the center of the body to apply the impulse at.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyImpulse(BepuPhysics.BodySet@,System.Int32,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Applies an impulse to a body by index. Does not wake the body up.
            </summary>
            <param name="set">Body set containing the body to apply an impulse to.</param>
            <param name="index">Index of the body in the body set.</param>
            <param name="impulse">Impulse to apply to the body.</param>
            <param name="impulseOffset">World space offset from the center of the body to apply the impulse at.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyAngularImpulse(System.Numerics.Vector3,BepuUtilities.Symmetric3x3@,System.Numerics.Vector3@)">
            <summary>
            Applies an angular impulse to an angular velocity. Does not wake the body up.
            </summary>
            <param name="angularImpulse">Impulse to apply to the velocity.</param>
            <param name="inverseInertiaTensor">Inverse inertia tensor to transform the impulse with.</param>
            <param name="angularVelocity">Angular velocity to be modified.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyLinearImpulse(System.Numerics.Vector3,System.Single,System.Numerics.Vector3@)">
            <summary>
            Applies an impulse to a linear velocity. Does not wake the body up.
            </summary>
            <param name="impulse">Impulse to apply to the velocity.</param>
            <param name="inverseMass">Inverse mass to transform the impulse with.</param>
            <param name="linearVelocity">Linear velocity to be modified.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyImpulse(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Applies an impulse to a body at the given world space position. Does not modify activity states.
            </summary>
            <param name="impulse">Impulse to apply to the body.</param>
            <param name="impulseOffset">World space offset to apply the impulse at.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyLinearImpulse(System.Numerics.Vector3)">
            <summary>
            Applies an impulse to a linear velocity. Does not wake the body up.
            </summary>
            <param name="impulse">Impulse to apply to the velocity.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.GetVelocityForOffset(System.Numerics.Vector3,System.Numerics.Vector3@)">
            <summary>
            Computes the velocity of an offset point attached to the body.
            </summary>
            <param name="offset">Offset from the body's center to </param>
            <param name="velocity">Effective velocity of the point if it were attached to the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyAngularImpulse(System.Numerics.Vector3)">
            <summary>
            Applies an angular impulse to an angular velocity. Does not wake the body up.
            </summary>
            <param name="angularImpulse">Impulse to apply to the velocity.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.op_Implicit(BepuPhysics.BodyReference)~BepuPhysics.BodyHandle">
            <summary>
            Implicitly converts a <see cref="T:BepuPhysics.BodyReference"/> to the <see cref="T:BepuPhysics.BodyHandle"/> that the body reference was created from.
            </summary>
            <param name="reference">Body reference to extract the handle from.</param>
        </member>
        <member name="T:BepuPhysics.BodySet">
            <summary>
            Stores a group of bodies- either the set of active bodies, or the bodies involved in an inactive simulation island.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.IndexToHandle">
            <summary>
            Remaps a body index to its handle.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.DynamicsState">
            <summary>
            Stores all data involved in solving constraints for a body, including pose, velocity, and inertia.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.Collidables">
            <summary>
            The collidables owned by each body in the set. Speculative margins, continuity settings, and shape indices can be changed directly.
            Shape indices cannot transition between pointing at a shape and pointing at nothing or vice versa without notifying the broad phase of the collidable addition or removal.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.Activity">
            <summary>
            Activity states of bodies in the set.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.Constraints">
            <summary>
            List of constraints associated with each body in the set.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodySet.Allocated">
            <summary>
            Gets whether this instance is backed by allocated memory.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodySet.RemoveConstraintReference(System.Int32,BepuPhysics.ConstraintHandle,System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Removes a constraint from a body's constraint list.
            </summary>
            <param name="bodyIndex">Index of the body to remove the constraint reference from.</param>
            <param name="constraintHandle">Handle of the constraint to remove.</param>
            <param name="minimumConstraintCapacityPerBody">Minimum constraint capacity to maintain the body's constraint list. The list will automatically downsize as constraints are removed, but its capacity will not go below this threshold.</param>
            <param name="pool">Pool to use to resize the constraint list.</param>
            <returns>True if the number of constraints remaining attached to the body is 0, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.BodySet.DisposeBuffers(BepuUtilities.Memory.BufferPool)">
            <summary>
            Disposes the buffers, but nothing inside of the buffers. Per-body constraint lists stored in the set will not be returned.
            </summary>
            <param name="pool">Pool to return the set's top level buffers to.</param>
        </member>
        <member name="M:BepuPhysics.BodySet.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Disposes the body set's buffers and any resources within them.
            </summary>
            <param name="pool">Pool to return resources to.</param>
        </member>
        <member name="M:BepuPhysics.BoundingBoxHelpers.ExpandLocalBoundingBoxes(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,System.Single,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Expands the bounding box surrounding a shape A in the local space of some other collidable B.
            </summary>
        </member>
        <member name="M:BepuPhysics.BoundingBoxHelpers.GetLocalBoundingBoxForSweep(BepuPhysics.Collidables.TypedIndex,BepuPhysics.Collidables.Shapes,BepuPhysics.RigidPose@,System.Numerics.Quaternion,BepuPhysics.BodyVelocity@,System.Numerics.Vector3,System.Numerics.Quaternion,BepuPhysics.BodyVelocity@,System.Single,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the bounding box of a child shape A in the local space of some other collidable B with a sweep direction representing the net linear motion.
            </summary>
        </member>
        <member name="M:BepuPhysics.BoundingBoxHelpers.GetLocalBoundingBoxForSweep``1(``0@,System.Numerics.Quaternion,BepuPhysics.BodyVelocity@,System.Numerics.Vector3,System.Numerics.Quaternion,BepuPhysics.BodyVelocity@,System.Single,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the bounding box of shape A in the local space of some other collidable B with a sweep direction representing the net linear motion.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollidableProperty`1">
            <summary>
            Convenience collection that stores extra properties about bodies and statics, indexed by the body or static handle.
            </summary>
            <typeparam name="T">Type of the data to store.</typeparam>
            <remarks>This is built for use cases relying on random access like the narrow phase. For maximum performance with sequential access, an index-aligned structure would be better.</remarks>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.#ctor(BepuUtilities.Memory.BufferPool)">
            <summary>
            Constructs a new collection to store handle-aligned body properties. Assumes the Initialize function will be called later to provide the Bodies collection.
            </summary>
            <param name="pool">Pool from which to pull internal resources. If null, uses the later Initialize-provided Bodies pool.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.#ctor(BepuPhysics.Simulation,BepuUtilities.Memory.BufferPool)">
            <summary>
            Constructs a new collection to store handle-aligned body and static properties.
            </summary>
            <param name="simulation">Simulation to track.</param>
            <param name="pool">Pool from which to pull internal resources. If null, uses the Simulation pool.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Initialize(BepuPhysics.Simulation)">
            <summary>
            Initializes the property collection if the Bodies/Statics-less constructor was used.
            </summary>
            <param name="simulation">Simulation whose bodies and statics will be tracked.</param>
        </member>
        <member name="P:BepuPhysics.CollidableProperty`1.Item(BepuPhysics.BodyHandle)">
            <summary>
            Gets a reference to the properties associated with a body's handle.
            </summary>
            <param name="bodyHandle">Body handle to retrieve the properties for.</param>
            <returns>Reference to properties associated with a body handle.</returns>
        </member>
        <member name="P:BepuPhysics.CollidableProperty`1.Item(BepuPhysics.StaticHandle)">
            <summary>
            Gets a reference to the properties associated with a static's handle.
            </summary>
            <param name="staticHandle">Static handle to retrieve the properties for.</param>
            <returns>Reference to properties associated with a static handle.</returns>
        </member>
        <member name="P:BepuPhysics.CollidableProperty`1.Item(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Gets a reference to the properties associated with a collidable.
            </summary>
            <param name="staticHandle">Collidable to retrieve the properties for.</param>
            <returns>Reference to properties associated with a collidable.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Allocate(BepuPhysics.BodyHandle)">
            <summary>
            Ensures there is space for a given body handle and returns a reference to the used memory.
            </summary>
            <param name="bodyHandle">Body handle to allocate for.</param>
            <returns>Reference to the data for the given body.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Allocate(BepuPhysics.StaticHandle)">
            <summary>
            Ensures there is space for a given static handle and returns a reference to the used memory.
            </summary>
            <param name="handle">Static handle to allocate for.</param>
            <returns>Reference to the data for the given static.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Allocate(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Ensures there is space for a given collidable reference and returns a reference to the used memory.
            </summary>
            <param name="handle">Collidable reference to allocate for.</param>
            <returns>Reference to the data for the given collidable.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.EnsureBodyCapacity(System.Int32)">
            <summary>
            Ensures that the internal structures have at least the given capacity for bodies.
            </summary>
            <param name="capacity">Capacity to ensure.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.EnsureStaticCapacity(System.Int32)">
            <summary>
            Ensures that the internal structures have at least the given capacity for statics.
            </summary>
            <param name="capacity">Capacity to ensure.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.CompactBodies">
            <summary>
            Compacts the memory used by the collection for bodies to a safe minimum based on the Bodies collection.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.CompactStatics">
            <summary>
            Compacts the memory used by the collection for statics to a safe minimum based on the Statics collection.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Dispose">
            <summary>
            Returns all held resources.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.BigCompound">
            <summary>
            Compound shape containing a bunch of shapes accessible through a tree acceleration structure. Useful for compounds with lots of children.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.BigCompound.Tree">
            <summary>
            Acceleration structure for the compound children.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.BigCompound.Children">
            <summary>
            Buffer of children within this compound.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.BigCompound.#ctor(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild},BepuPhysics.Collidables.Shapes,BepuUtilities.Memory.BufferPool)">
            <summary>
            Creates a compound shape with an acceleration structure.
            </summary>
            <param name="children">Set of children in the compound.</param>
            <param name="shapes">Shapes set in which child shapes are allocated.</param>
            <param name="pool">Pool to use to allocate acceleration structures.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.BigCompound.Add(BepuPhysics.Collidables.CompoundChild,BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.Shapes)">
            <summary>
            Adds a child to the compound.
            </summary>
            <param name="child">Child to add to the compound.</param>
            <param name="pool">Pool to use to resize the compound's children buffer if necessary.</param>
            <param name="shapes">Shapes collection containing the compound's children.</param>
            <remarks><para>This function keeps the <see cref="F:BepuPhysics.Collidables.BigCompound.Tree"/> in a valid state, but significant changes over time may degrade the tree's quality and result in reduced collision/query performance.
            If this happens, consider calling <see cref="M:BepuPhysics.Trees.Tree.RefitAndRefine(BepuUtilities.Memory.BufferPool,System.Int32,System.Single)"/> with a refinementIndex that changes with each call (to prioritize different parts of the tree).
            Incrementing a counter with each call would work fine. The ideal frequency of refinement depends on the kind of modifications being made, but it's likely to be rare.</para></remarks>
        </member>
        <member name="M:BepuPhysics.Collidables.BigCompound.RemoveAt(System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Removes a child from the compound by index. The last child is pulled to fill the gap left by the removed child.
            </summary>
            <param name="childIndex">Index of the child to remove from the compound.</param>
            <param name="pool">Pool to use to resize the compound's children buffer if necessary.</param>
            <remarks>This function keeps the <see cref="F:BepuPhysics.Collidables.BigCompound.Tree"/> in a valid state, but significant changes over time may degrade the tree's quality and result in reduced collision/query performance.
            If this happens, consider calling <see cref="M:BepuPhysics.Trees.Tree.RefitAndRefine(BepuUtilities.Memory.BufferPool,System.Int32,System.Single)"/> with a refinementIndex that changes with each call (to prioritize different parts of the tree).
            Incrementing a counter with each call would work fine. The ideal frequency of refinement depends on the kind of modifications being made, but it's likely to be rare.</remarks>
        </member>
        <member name="M:BepuPhysics.Collidables.BigCompound.ComputeInertia(System.Span{System.Single},BepuPhysics.Collidables.Shapes)">
            <summary>
            Computes the inertia of a compound. Does not recenter the child poses.
            </summary>
            <param name="childMasses">Masses of the children.</param>
            <param name="shapes">Shapes collection containing the data for the compound child shapes.</param>
            <returns>Inertia of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.BigCompound.ComputeInertia(System.Span{System.Single},BepuPhysics.Collidables.Shapes,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of a compound. Recenters the child poses around the calculated center of mass.
            </summary>
            <param name="shapes">Shapes collection containing the data for the compound child shapes.</param>
            <param name="childMasses">Masses of the children.</param>
            <param name="centerOfMass">Calculated center of mass of the compound. Subtracted from all the compound child poses.</param>
            <returns>Inertia of the compound.</returns>
        </member>
        <member name="F:BepuPhysics.Collidables.BigCompound.Id">
            <summary>
            Type id of compound shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.Box">
            <summary>
            Collision shape representing a solid cuboid.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.HalfWidth">
            <summary>
            Half of the box's width along its local X axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.HalfHeight">
            <summary>
            Half of the box's height along its local Y axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.HalfLength">
            <summary>
            Half of the box's length along its local Z axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Box.Width">
            <summary>
            Gets or sets the width of the box along its local X axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Box.Height">
            <summary>
            Gets or sets the height of the box along its local Y axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Box.Length">
            <summary>
            Gets or sets the length of the box along its local Z axis.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Box.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a Box shape.
            </summary>
            <param name="width">Width of the box along the local X axis.</param>
            <param name="height">Height of the box along the local Y axis.</param>
            <param name="length">Length of the box along the local Z axis.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.Id">
            <summary>
            Type id of box shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.Capsule">
            <summary>
            Collision shape representing a sphere-expanded line segment.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Capsule.Radius">
            <summary>
            Spherical expansion applied to the internal line segment.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Capsule.HalfLength">
            <summary>
            Half of the length of the internal line segment. Oriented along the local Y axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Capsule.Length">
            <summary>
            Gets or sets the length of the capsule's internal line segment along the local Y axis.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Capsule.#ctor(System.Single,System.Single)">
            <summary>
            Creates a capsule shape.
            </summary>
            <param name="radius">Radius of the capsule.</param>
            <param name="length">Length of the capsule's internal line segment along the local Y axis.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Capsule.Id">
            <summary>
            Type id of capsule shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ContinuousDetectionMode">
            <summary>
            Defines how a collidable will handle collision detection in the presence of velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete">
            <summary>
            <para>No sweep tests are performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box will not be expanded by velocity beyond the speculative margin.</para>
            <para>This is the cheapest mode. If a Discrete mode collidable is moving quickly and the maximum speculative margin is limited,
            the fact that its bounding box is not expanded may cause it to miss a collision even with a non-Discrete collidable.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionMode.Passive">
            <summary>
            <para>No sweep tests are performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box will be expanded by velocity without being limited by the speculative margin.</para>
            <para>This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes 
            that should avoid missing collisions.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous">
            <summary>
            <para>Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision.</para>
            <para>This mode can capture angular motion with very few ghost collisions. It can, however, miss secondary collisions that would have occurred due to the primary impact's velocity change.</para>
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ContinuousDetection">
            <summary>
            Defines how a collidable handles collisions with significant velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetection.Mode">
            <summary>
            The continuous collision detection mode.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetection.MinimumSweepTimestep">
            <summary>
            If using <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous"/>, this defines the minimum progress that the sweep test will make when searching for the first time of impact.
            Collisions lasting less than <see cref="F:BepuPhysics.Collidables.ContinuousDetection.MinimumSweepTimestep"/> may be missed by the sweep test. Using larger values can significantly increase the performance of sweep tests.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetection.SweepConvergenceThreshold">
            <summary>
            If using <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous"/>, sweep tests will terminate if the time of impact region has been refined to be smaller than <see cref="F:BepuPhysics.Collidables.ContinuousDetection.SweepConvergenceThreshold"/>.
            Values closer to zero will converge more closely to the true time of impact, but for speculative contact generation larger values usually work fine.
            Larger values allow the sweep to terminate much earlier and can significantly improve sweep performance.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ContinuousDetection.AllowExpansionBeyondSpeculativeMargin">
            <summary>
            Gets whether the continuous collision detection configuration will permit bounding box expansion beyond the calculated speculative margin.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ContinuousDetection.Discrete">
            <summary>
            <para>No sweep tests are performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box will not be expanded by velocity beyond the speculative margin.</para>
            <para>This can be marginally cheaper than Passive modes if using a limited maximum speculative margin. If a Discrete mode collidable is moving quickly and the maximum speculative margin is limited,
            the fact that its bounding box is not expanded may cause it to miss a collision even with a non-Discrete collidable.</para>
            <para>Note that Discrete and Passive only differ if maximum speculative margin is restricted.</para>
            </summary>
            <returns>Detection settings for the given discrete configuration.</returns>
        </member>
        <member name="P:BepuPhysics.Collidables.ContinuousDetection.Passive">
            <summary>
            <para>No sweep tests are performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box and speculative margin will be expanded by velocity.</para>
            <para>This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes that should avoid missing collisions.</para>
            </summary>
            <returns>Detection settings for the passive configuration.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.ContinuousDetection.Continuous(System.Single,System.Single)">
            <summary>
            <para>Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision.</para>
            <para>This mode can capture angular motion with very few ghost collisions. It can, however, miss secondary collisions that would have occurred due to the primary impact's velocity change.</para>
            </summary>
            <param name="minimumSweepTimestep">Minimum progress that the sweep test will make when searching for the first time of impact.
            Collisions lasting less than MinimumProgress may be missed by the sweep test. Using larger values can significantly increase the performance of sweep tests.</param>
            <param name="sweepConvergenceThreshold">Threshold against which the time of impact region is compared for sweep termination. 
            If the region has been refined to be smaller than SweepConvergenceThreshold, the sweep will terminate.
            Values closer to zero will converge more closely to the true time of impact, but for speculative contact generation larger values usually work fine.
            Larger values allow the sweep to terminate much earlier and can significantly improve sweep performance.</param>
            <returns>Detection settings for the given continuous configuration.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.Collidable">
            <summary>
            Description of a collidable used by a body living in the broad phase and able to generate collision pairs.
            Collidables with a ShapeIndex that points to nothing (a default constructed <see cref="T:BepuPhysics.Collidables.TypedIndex"/>) are not capable of colliding with anything.
            This can be used for a body which needs no collidable representation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.Shape">
            <summary>
            Index of the shape used by the body. While this can be changed, any transition from shapeless->shapeful or shapeful->shapeless must be reported to the broad phase. 
            If you need to perform such a transition, consider using <see cref="M:BepuPhysics.Bodies.SetShape(BepuPhysics.BodyHandle,BepuPhysics.Collidables.TypedIndex)"/> or <see cref="M:BepuPhysics.Bodies.ApplyDescription(BepuPhysics.BodyHandle,BepuPhysics.BodyDescription@)"/>; those functions update the relevant state.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.Continuity">
            <summary>
            Continuous collision detection settings for this collidable. Includes the collision detection mode to use and tuning variables associated with those modes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.MinimumSpeculativeMargin">
            <summary>
            Lower bound on the value of the speculative margin used by the collidable.
            </summary>
            <remarks>0 tends to be a good default value. Higher values can be chosen if velocity magnitude is a poor proxy for speculative margins, but these cases are rare.
            In those cases, try to use the smallest value that still satisfies requirements to avoid creating unnecessary contact constraints.</remarks>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.MaximumSpeculativeMargin">
            <summary>
            Upper bound on the value of the speculative margin used by the collidable.
            </summary>
            <remarks><see cref="F:System.Single.MaxValue"/> tends to be a good default value for discrete or passive mode collidables. 
            The speculative margin will increase in size proportional to velocity magnitude, so having an unlimited maximum won't cost extra if the body isn't moving fast.
            <para>Smaller values can be useful for improving performance in chaotic situations where missing a collision is acceptable. When using <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous"/>, a speculative margin larger than the velocity magnitude will result in the sweep test being skipped, so lowering the maximum margin can help avoid ghost collisions.</para>
            </remarks>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.SpeculativeMargin">
            <summary>
            Automatically computed size of the margin around the surface of the shape in which contacts can be generated. These contacts will have negative depth and only contribute if the frame's velocities
            would push the shapes of a pair into overlap. 
            <para>This is automatically set by bounding box prediction each frame, and is bound by the collidable's <see cref="F:BepuPhysics.Collidables.Collidable.MinimumSpeculativeMargin"/> and <see cref="F:BepuPhysics.Collidables.Collidable.MaximumSpeculativeMargin"/> values.
            The effective speculative margin for a collision pair can also be modified from <see cref="T:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks"/> callbacks.</para>
            <para>This should be positive to avoid jittering.</para>
            <para>It can also be used as a form of continuous collision detection, but excessively high values combined with fast motion may result in visible 'ghost collision' artifacts. 
            For continuous collision detection with less chance of ghost collisions, use <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous"/>.</para>
            <para>If using <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous"/>, consider setting <see cref="F:BepuPhysics.Collidables.Collidable.MaximumSpeculativeMargin"/> to a smaller value to help filter ghost collisions.</para>
            <para>For more information, see the ContinuousCollisionDetection.md documentation.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.BroadPhaseIndex">
            <summary>
            Index of the collidable in the broad phase. Used to look up the target location for bounding box scatters. Under normal circumstances, this should not be set externally.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.CollidableDescription">
            <summary>
            Describes a collidable and how it should handle continuous collision detection.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableDescription.Shape">
            <summary>
            Shape of the collidable.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableDescription.Continuity">
            <summary>
            Continuous collision detection settings used by the collidable.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableDescription.MinimumSpeculativeMargin">
            <summary>
            Lower bound on the value of the speculative margin used by the collidable.
            </summary>
            <remarks>0 tends to be a good default value. Higher values can be chosen if velocity magnitude is a poor proxy for speculative margins, but these cases are rare.
            In those cases, try to use the smallest value that still satisfies requirements to avoid creating unnecessary contact constraints.</remarks>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableDescription.MaximumSpeculativeMargin">
            <summary>
            Upper bound on the value of the speculative margin used by the collidable.
            </summary>
            <remarks><see cref="F:System.Single.MaxValue"/> tends to be a good default value for discrete or passive mode collidables. 
            The speculative margin will increase in size proportional to velocity magnitude, so having an unlimited maximum won't cost extra if the body isn't moving fast.
            <para>Smaller values can be useful for improving performance in chaotic situations where missing a collision is acceptable. When using <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous"/>, a speculative margin larger than the velocity magnitude will result in the sweep test being skipped, so lowering the maximum margin can help avoid ghost collisions.</para>
            </remarks>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex,System.Single,System.Single,BepuPhysics.Collidables.ContinuousDetection)">
            <summary>
            Constructs a new collidable description.
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <param name="minimumSpeculativeMargin">Lower bound on the value of the speculative margin used by the collidable.</param>
            <param name="maximumSpeculativeMargin">Upper bound on the value of the speculative margin used by the collidable.</param>
            <param name="continuity">Continuous collision detection settings for the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex,System.Single,System.Single)">
            <summary>
            Constructs a new collidable description with <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete"/>.
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <param name="minimumSpeculativeMargin">Lower bound on the value of the speculative margin used by the collidable.</param>
            <param name="maximumSpeculativeMargin">Upper bound on the value of the speculative margin used by the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex,System.Single,BepuPhysics.Collidables.ContinuousDetection)">
            <summary>
            Constructs a new collidable description. Uses 0 for the <see cref="F:BepuPhysics.Collidables.CollidableDescription.MinimumSpeculativeMargin"/> .
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <param name="maximumSpeculativeMargin">Upper bound on the value of the speculative margin used by the collidable.</param>
            <param name="continuity">Continuous collision detection settings for the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex,BepuPhysics.Collidables.ContinuousDetection)">
            <summary>
            Constructs a new collidable description. Uses 0 for the <see cref="F:BepuPhysics.Collidables.CollidableDescription.MinimumSpeculativeMargin"/> and <see cref="F:System.Single.MaxValue"/> for the <see cref="F:BepuPhysics.Collidables.CollidableDescription.MaximumSpeculativeMargin"/> .
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <param name="continuity">Continuous collision detection settings for the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Constructs a new collidable description with <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Passive"/>. Will use a <see cref="F:BepuPhysics.Collidables.CollidableDescription.MinimumSpeculativeMargin"/> of 0 and a <see cref="F:BepuPhysics.Collidables.CollidableDescription.MaximumSpeculativeMargin"/> of <see cref="F:System.Single.MaxValue"/>.
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <remarks><see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Passive"/> and <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete"/> are equivalent in behavior when the <see cref="F:BepuPhysics.Collidables.CollidableDescription.MaximumSpeculativeMargin"/>  is <see cref="F:System.Single.MaxValue"/> since they both result in the same (unbounded) expansion of body bounding boxes in response to velocity.</remarks>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex,System.Single)">
            <summary>
            Constructs a new collidable description with <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete"/>. Will use a minimum speculative margin of 0 and the given maximumSpeculativeMargin.
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <param name="maximumSpeculativeMargin">Maximum speculative margin to be used with the discrete continuity configuration.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.op_Implicit(BepuPhysics.Collidables.TypedIndex)~BepuPhysics.Collidables.CollidableDescription">
            <summary>
            Constructs a new collidable description with <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Passive"/>. Will use a minimum speculative margin of 0 and a maximum of <see cref="F:System.Single.MaxValue"/>.
            </summary>
            <param name="shapeIndex">Shape index to use for the collidable.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.CollidableMobility">
            <summary>
            Represents how a collidable can interact and move.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableMobility.Dynamic">
            <summary>
            Marks a collidable as owned by a dynamic body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableMobility.Kinematic">
            <summary>
            Marks a collidable as owned by a kinematic body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableMobility.Static">
            <summary>
            Marks the collidable as an independent immobile collidable.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.CollidableReference">
            <summary>
            Uses a bitpacked representation to refer to a body or static collidable.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableReference.Packed">
            <summary>
            Bitpacked representation of the collidable reference.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.Mobility">
            <summary>
            Gets the mobility state of the owner of this collidable.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.BodyHandle">
            <summary>
            Gets the body handle of the owner of the collidable referred to by this instance.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.StaticHandle">
            <summary>
            Gets the static handle of the owner of the collidable referred to by this instance.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.RawHandleValue">
            <summary>
            Gets the integer value of the handle of the owner of the collidable referred to by this instance.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableReference.#ctor(BepuPhysics.Collidables.CollidableMobility,System.Int32)">
            <summary>
            Creates a collidable reference.
            </summary>
            <param name="mobility">Mobility type of the owner of the collidable.</param>
            <param name="handle">Handle of the owner of the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableReference.#ctor(BepuPhysics.Collidables.CollidableMobility,BepuPhysics.BodyHandle)">
            <summary>
            Creates a collidable reference for a body.
            </summary>
            <param name="mobility">Mobility type of the owner of the collidable.</param>
            <param name="handle">Handle of the owner of the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableReference.#ctor(BepuPhysics.StaticHandle)">
            <summary>
            Creates a collidable reference for a static.
            </summary>
            <param name="handle">Handle of the owner of the collidable.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.CompoundChild">
            <summary>
            Shape and pose of a child within a compound shape.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CompoundChild.LocalOrientation">
            <summary>
            Local orientation of the child in the compound.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CompoundChild.LocalPosition">
            <summary>
            Local position of the child in the compound.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CompoundChild.ShapeIndex">
            <summary>
            Index of the shape within whatever shape collection holds the compound's child shape data.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundChild.AsPose(BepuPhysics.Collidables.CompoundChild@)">
            <summary>
            Reintreprets the 32 bytes of a compound child as a pose.
            </summary>
            <param name="child">Child to reinterpret.</param>
            <returns>Reference to the child as a pose.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.Compound">
            <summary>
            Minimalist compound shape containing a list of child shapes. Does not make use of any internal acceleration structure; should be used only with small groups of shapes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Compound.Children">
            <summary>
            Buffer of children within this compound.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.#ctor(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild})">
            <summary>
            Creates a compound shape with no acceleration structure.
            </summary>
            <param name="children">Set of children in the compound.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.ValidateChildIndex(BepuPhysics.Collidables.TypedIndex,BepuPhysics.Collidables.Shapes)">
            <summary>
            Checks if a shape index.
            </summary>
            <param name="shapeIndex">Shape index to analyze.</param>
            <param name="shapeBatches">Shape collection into which the index indexes.</param>
            <returns>True if the index is valid, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.ValidateChildIndices(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,BepuPhysics.Collidables.Shapes)">
            <summary>
            Checks if a set of children shape indices are all valid.
            </summary>
            <param name="children">Children to examine.</param>
            <param name="shapeBatches">Shape collection into which the children index.</param>
            <returns>True if all child indices are valid, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.Add(BepuPhysics.Collidables.CompoundChild,BepuUtilities.Memory.BufferPool)">
            <summary>
            Adds a child to the compound.
            </summary>
            <param name="child">Child to add to the compound.</param>
            <param name="pool">Pool to use to resize the compound's children buffer if necessary.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.RemoveAt(System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Removes a child from the compound by index. The last child is pulled to fill the gap left by the removed child.
            </summary>
            <param name="childIndex">Index of the child to remove from the compound.</param>
            <param name="pool">Pool to use to resize the compound's children buffer if necessary.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.ComputeInertia(System.Span{System.Single},BepuPhysics.Collidables.Shapes)">
            <summary>
            Computes the inertia of a compound. Does not recenter the child poses.
            </summary>
            <param name="childMasses">Masses of the children.</param>
            <param name="shapes">Shapes collection containing the data for the compound child shapes.</param>
            <returns>Inertia of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.ComputeInertia(System.Span{System.Single},BepuPhysics.Collidables.Shapes,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of a compound. Recenters the child poses around the calculated center of mass.
            </summary>
            <param name="shapes">Shapes collection containing the data for the compound child shapes.</param>
            <param name="childMasses">Masses of the children.</param>
            <param name="centerOfMass">Calculated center of mass of the compound. Subtracted from all the compound child poses.</param>
            <returns>Inertia of the compound.</returns>
        </member>
        <member name="F:BepuPhysics.Collidables.Compound.Id">
            <summary>
            Type id of list based compound shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.CompoundBuilder">
            <summary>
            Reusable convenience type for incrementally building compound shapes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CompoundBuilder.Child.Weight">
            <summary>
            Weight associated with this child. Acts as the child's mass when interpreted as a dynamic compound.
            When interpreted as kinematic with recentering, it is used as a local pose weight to compute the center of rotation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CompoundBuilder.Child.LocalInverseInertia">
            <summary>
            Inverse inertia tensor of the child in its local space.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.#ctor(BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.Shapes,System.Int32)">
            <summary>
            Creates a compound builder.
            </summary>
            <param name="pool">Buffer pool to allocate memory from when necessary.</param>
            <param name="shapes">Shapes collection to access when constructing the compound children.</param>
            <param name="initialBuilderCapacity">Number of children the compound builder can hold without resizing.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Add(BepuPhysics.Collidables.TypedIndex,BepuPhysics.RigidPose@,BepuUtilities.Symmetric3x3@,System.Single)">
            <summary>
            Adds a new shape to the accumulator.
            </summary>
            <param name="shape">Index of the shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass. Otherwise, it is used for recentering.</param>
            <param name="localInverseInertia">Inverse inertia tensor of the shape being added in its local space. This is assumed to already be scaled as desired by the weight.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.AddForKinematic(BepuPhysics.Collidables.TypedIndex,BepuPhysics.RigidPose@,System.Single)">
            <summary>
            Adds a new shape to the accumulator, assuming it has infinite inertia.
            </summary>
            <param name="shape">Index of the shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape used for computing the center of rotation.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Add``1(``0@,BepuPhysics.RigidPose@,System.Single)">
            <summary>
            Adds a new shape to the accumulator, creating a new shape in the shapes set. The mass used to compute the inertia tensor will be based on the given weight.
            </summary>
            <typeparam name="TShape">Type of the shape to add to the accumulator and the shapes set.</typeparam>
            <param name="shape">Shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass and scales the inertia tensor. 
            Otherwise, it is used for recentering.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.AddForKinematic``1(``0@,BepuPhysics.RigidPose@,System.Single)">
            <summary>
            Adds a new shape to the accumulator, creating a new shape in the shapes set. Inertia is assumed to be infinite.
            </summary>
            <typeparam name="TShape">Type of the shape to add to the accumulator and the shapes set.</typeparam>
            <param name="shape">Shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass. Otherwise, it is used for recentering.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.GetOffsetInertiaContribution(System.Numerics.Vector3,System.Single,BepuUtilities.Symmetric3x3@)">
            <summary>
            Gets the contribution to an inertia tensor of a point mass at the given offset from the center of mass.
            </summary>
            <param name="offset">Offset from the center of mass.</param>
            <param name="mass">Mass of the point.</param>
            <param name="contribution">Contribution to the inertia tensor.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildDynamicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,BepuPhysics.BodyInertia@,System.Numerics.Vector3@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a dynamic compound.
            Computes a center of mass and recenters child shapes relative to it. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
            <param name="inertia">Combined inertia of the compound.</param>
            <param name="center">Computed center of rotation based on the poses and weights of accumulated children.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildDynamicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,BepuPhysics.BodyInertia@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a dynamic compound. Does not recenter the children. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
            <param name="inertia">Combined inertia of the compound.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInertiaForChild(BepuPhysics.RigidPose@,BepuUtilities.Symmetric3x3,System.Single)">
            <summary>
            Computes the uninverted inertia contribution of a child.
            </summary>
            <param name="pose">Pose of the child.</param>
            <param name="inverseLocalInertia">Inverse inertia tensor of the child in its local space.</param>
            <param name="mass">Mass of the child.</param>
            <returns>Inertia contribution of the child to a compound given its relative pose.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInertiaForChild(System.Numerics.Vector3,System.Numerics.Quaternion,BepuUtilities.Symmetric3x3,System.Single)">
            <summary>
            Computes the uninverted inertia contribution of a child.
            </summary>
            <param name="position">Position of the child.</param>
            <param name="orientation">Orientation of the child.</param>
            <param name="inverseLocalInertia">Inverse inertia tensor of the child in its local space.</param>
            <param name="mass">Mass of the child.</param>
            <returns>Inertia contribution of the child to a compound given its relative pose.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInverseInertia(System.Span{BepuPhysics.Collidables.CompoundChild},System.Span{BepuUtilities.Symmetric3x3},System.Span{System.Single})">
            <summary>
            Computes the inertia for a set of compound children based on their poses and the provided inverse inertias. Does not recenter the children.
            </summary>
            <param name="children">Children and their associated poses.</param>
            <param name="inverseLocalInertias">Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child.</param>
            <param name="childMasses">Masses of each child in the compound.</param>
            <returns><see cref="T:BepuPhysics.BodyInertia"/> of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInverseInertia(System.Span{BepuPhysics.RigidPose},System.Span{BepuUtilities.Symmetric3x3},System.Span{System.Single})">
            <summary>
            Computes the inverse inertia for a set of compound children based on their poses and the provided inverse inertias. Does not recenter the children.
            </summary>
            <param name="childPoses">Poses of the compound's children.</param>
            <param name="inverseLocalInertias">Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child.</param>
            <param name="childMasses">Masses of each child in the compound.</param>
            <returns><see cref="T:BepuPhysics.BodyInertia"/> of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeCenterOfMass(System.Span{BepuPhysics.Collidables.CompoundChild},System.Span{System.Single},System.Single@)">
            <summary>
            Computes the center of mass of a compound.
            </summary>
            <param name="children">Children of the compound.</param>
            <param name="childMasses">Masses of the children in the compound.</param>
            <param name="inverseMass">Inverse of the sum of all child masses.</param>
            <returns>The compound's center of mass.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeCenterOfMass(System.Span{BepuPhysics.RigidPose},System.Span{System.Single},System.Single@)">
            <summary>
            Computes the center of mass of a compound.
            </summary>
            <param name="childPoses">Poses of the children in the compound.</param>
            <param name="childMasses">Masses of the children in the compound.</param>
            <param name="inverseMass">Inverse of the sum of all child masses.</param>
            <returns>The compound's center of mass.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeCenterOfMass(System.Span{BepuPhysics.Collidables.CompoundChild},System.Span{System.Single})">
            <summary>
            Computes the center of mass of a compound.
            </summary>
            <param name="children">Children of the compound.</param>
            <param name="childMasses">Masses of the children in the compound.</param>
            <returns>The compound's center of mass.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeCenterOfMass(System.Span{BepuPhysics.RigidPose},System.Span{System.Single})">
            <summary>
            Computes the center of mass of a compound.
            </summary>
            <param name="childPoses">Poses of the children in the compound.</param>
            <param name="childMasses">Masses of the children in the compound.</param>
            <returns>The compound's center of mass.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInverseInertia(System.Span{BepuPhysics.Collidables.CompoundChild},System.Span{BepuUtilities.Symmetric3x3},System.Span{System.Single},System.Numerics.Vector3@)">
            <summary>
            Computes the inertia for a set of compound children based on their poses and the provided inverse inertias. Recenters the children onto the computed center of mass.
            </summary>
            <param name="children">Children and their associated poses. Center of mass will be subtracted from the child position.</param>
            <param name="inverseLocalInertias">Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child.</param>
            <param name="childMasses">Masses of each child in the compound.</param>
            <param name="centerOfMass">Computed center of mass that was subtracted from the child positions.</param>
            <returns><see cref="T:BepuPhysics.BodyInertia"/> of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInverseInertia(System.Span{BepuPhysics.RigidPose},System.Span{BepuUtilities.Symmetric3x3},System.Span{System.Single},System.Numerics.Vector3@)">
            <summary>
            Computes the inertia for a set of compound children based on their poses and the provided inverse inertias. Recenters the children onto the computed center of mass.
            </summary>
            <param name="childPoses">Poses of the compound's children. Center of mass will be subtracted from the child position.</param>
            <param name="inverseLocalInertias">Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child.</param>
            <param name="childMasses">Masses of each child in the compound.</param>
            <param name="centerOfMass">Computed center of mass that was subtracted from the child positions.</param>
            <returns><see cref="T:BepuPhysics.BodyInertia"/> of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInertia(System.Span{BepuPhysics.Collidables.CompoundChild},System.Span{System.Single},BepuPhysics.Collidables.Shapes)">
            <summary>
            Computes the inertia of a compound. Does not recenter the child poses.
            </summary>
            <param name="children">Children of the compound.</param>
            <param name="shapes">Shapes collection containing the data for the compound child shapes.</param>
            <param name="childMasses">Masses of the children.</param>
            <returns>Inertia of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.ComputeInertia(System.Span{BepuPhysics.Collidables.CompoundChild},System.Span{System.Single},BepuPhysics.Collidables.Shapes,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of a compound. Recenters the child poses around the calculated center of mass.
            </summary>
            <param name="children">Children of the compound. Child local positions will have the calculated center of mass subtracted from them.</param>
            <param name="shapes">Shapes collection containing the data for the compound child shapes.</param>
            <param name="childMasses">Masses of the children.</param>
            <param name="centerOfMass">Calculated center of mass of the compound. Subtracted from all the compound child poses.</param>
            <returns>Inertia of the compound.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildKinematicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,System.Numerics.Vector3@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a kinematic compound.
            Computes a center of mass and recenters child shapes relative to it. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
            <param name="center">Computed center of rotation based on the poses and weights of accumulated children.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildKinematicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a kinematic compound. Does not recenter children. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Reset">
            <summary>
            Empties out the accumulated children.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Dispose">
            <summary>
            Returns internal resources to the pool, rendering the builder unusable.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullBoundingPlanes.Normal">
            <summary>
            Normal of the bounding plane.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullBoundingPlanes.Offset">
            <summary>
            Offset from the origin to a point on the plane along the normal. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.Points">
            <summary>
            Bundled points of the convex hull.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.BoundingPlanes">
            <summary>
            Bundled bounding planes associated with the convex hull's faces.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.FaceVertexIndices">
            <summary>
            Combined set of vertices used by each face. Use FaceToVertexIndicesStart to index into this for a particular face. Indices stored in counterclockwise winding in right handed space, clockwise in left handed space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.FaceToVertexIndicesStart">
            <summary>
            Start indices of faces in the FaceVertexIndices.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHull.#ctor(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,System.Numerics.Vector3@)">
            <summary>
            Creates a convex hull from a point set.
            </summary>
            <param name="points">Points to compute the convex hull of.</param>
            <param name="pool">Pool in which to allocate the convex hull and any temporary resources needed to compute the hull.</param>
            <param name="center">Computed center of the convex hull before the hull was recentered.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.Id">
            <summary>
            Type id of convex hull shapes.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullWide.EstimateEpsilonScale(System.Numerics.Vector{System.Int32}@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Provides an estimate of the scale of a shape. 
            </summary>
            <param name="terminatedLanes">Mask of lanes which are inactive.</param>
            <param name="epsilonScale">Approximate scale of the shape for use in epsilons.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.HullFace">
            <summary>
            Stores references to the points composing one of a convex hull's faces.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.HullFace.VertexCount">
            <summary>
            Gets the number of vertices in the face.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.HullFace.Item(System.Int32)">
            <summary>
            Gets the index of the vertex associated with the given face vertex index in the source point set.
            </summary>
            <param name="index">Index into the face's vertex list.</param>
            <returns>Index of the vertex associated with the given face vertex index in the source point set.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.HullData">
            <summary>
            Raw data representing a convex hull.
            </summary>
            <remarks>This is not yet transformed into a runtime format. It requires additional processing to be used in a ConvexHull shape; see ConvexHullHelper.ProcessHull.</remarks>
        </member>
        <member name="F:BepuPhysics.Collidables.HullData.OriginalVertexMapping">
            <summary>
            Mapping of points on the convex hull back to the original point set.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullData.FaceVertexIndices">
            <summary>
            List of indices composing the faces of the hull. Individual faces indexed by the FaceIndices.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullData.FaceStartIndices">
            <summary>
            Starting index in the FaceVertexIndices for each face.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ConvexHullHelper">
            <summary>
            Helper methods to create and process convex hulls from point clouds.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ConvexHullHelper.EdgeFaceIndices">
            <summary>
            Tracks the faces associated with a detected surface edge. 
            During hull calculation, surface edges that have only one face associated with them should have an outstanding entry in the edges to visit set.
            Surface edges can never validly have more than two faces associated with them. Two means that an edge is 'complete', or should be.
            Detecting a third edge implies an error condition. By tracking *which* faces were associated with an edge, we can attempt to fix the error.
            This type of error tends to occur when there is a numerical disagreement about what vertices are coplanar with a face.
            One iteration could find what it thinks is a complete face, and a later iteration ends up finding more vertices *including* the ones already contained in the previous face.
            That's a recipe for excessive edge faces, but it's also a direct indicator that we should merge the involved faces for being close enough to coplanar that the error happened in the first place.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.ComputeHull(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.HullData@)">
            <summary>
            Computes the convex hull of a set of points.
            </summary>
            <param name="points">Point set to compute the convex hull of.</param>
            <param name="pool">Buffer pool to pull memory from when creating the hull.</param>
            <param name="hullData">Convex hull of the input point set.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateShape(System.Span{System.Numerics.Vector3},BepuPhysics.Collidables.HullData,BepuUtilities.Memory.BufferPool,System.Numerics.Vector3@,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Processes hull data into a runtime usable convex hull shape. Recenters the convex hull's points around its center of mass.
            </summary>
            <param name="points">Point array into which the hull data indexes.</param>
            <param name="hullData">Raw input data to process.</param>
            <param name="pool">Pool used to allocate resources for the hullShape.</param>
            <param name="hullShape">Convex hull shape created from the input data.</param>
            <param name="center">Computed center of mass of the convex hull before its points were recentered onto the origin.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateShape(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.HullData@,System.Numerics.Vector3@,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Creates a convex hull shape out of an input point set. Recenters the convex hull's points around its center of mass.
            </summary>
            <param name="points">Points to use to create the hull.</param>
            <param name="pool">Buffer pool used for temporary allocations and the output data structures.</param>
            <param name="hullData">Intermediate hull data that got processed into the convex hull.</param>
            <param name="center">Computed center of mass of the convex hull before its points were recentered onto the origin.</param>
            <param name="convexHull">Convex hull shape of the input point set.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateShape(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,System.Numerics.Vector3@,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Creates a convex hull shape out of an input point set. Recenters the convex hull's points around its center of mass.
            </summary>
            <param name="points">Points to use to create the hull.</param>
            <param name="pool">Buffer pool used for temporary allocations and the output data structures.</param>
            <param name="center">Computed center of mass of the convex hull before its points were recentered onto the origin.</param>
            <param name="convexHull">Convex hull shape of the input point set.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateTransformedCopy(BepuPhysics.Collidables.ConvexHull@,BepuUtilities.Matrix3x3@,BepuUtilities.Memory.Buffer{BepuUtilities.Vector3Wide},BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.HullBoundingPlanes})">
            <summary>
            Creates a transformed copy of a convex hull.
            </summary>
            <param name="source">Source convex hull to copy.</param>
            <param name="transform">Transform to apply to the hull points.</param>
            <param name="targetPoints">Transformed points in the copy target hull.</param>
            <param name="targetBoundingPlanes">Transformed bounding planes in the copy target hull.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateTransformedShallowCopy(BepuPhysics.Collidables.ConvexHull@,BepuUtilities.Matrix3x3@,BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Creates a transformed copy of a convex hull. FaceVertexIndices and FaceToVertexIndicesStart buffers from the source are reused in the copy target.
            Note that disposing two convex hulls with the same buffers will cause errors; disposal must be handled carefully to avoid double freeing the shared buffers.
            </summary>
            <param name="source">Source convex hull to copy.</param>
            <param name="transform">Transform to apply to the hull points.</param>
            <param name="pool">Pool from which to allocate the new hull's points and bounding planes buffers.</param>
            <param name="target">Target convex hull to copy into. FaceVertexIndices and FaceToVertexIndicesStart buffers are reused from the source.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateTransformedCopy(BepuPhysics.Collidables.ConvexHull@,BepuUtilities.Matrix3x3@,BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Creates a transformed copy of a convex hull. Unique FaceVertexIndices and FaceToVertexIndicesStart buffers are allocated for the copy target.
            </summary>
            <param name="source">Source convex hull to copy.</param>
            <param name="transform">Transform to apply to the hull points.</param>
            <param name="pool">Pool from which to allocate the new hull's buffers.</param>
            <param name="target">Target convex hull to copy into.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.Cylinder">
            <summary>
            Collision shape representing a cylinder.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Cylinder.Radius">
            <summary>
            Radius of the cylinder.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Cylinder.HalfLength">
            <summary>
            Half length of the cylinder along its local Y axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Cylinder.Length">
            <summary>
            Gets or sets the length of the cylinder along its local Y axis.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Cylinder.#ctor(System.Single,System.Single)">
            <summary>
            Creates a cylinder shape.
            </summary>
            <param name="radius">Radius of the cylinder.</param>
            <param name="length">Length of the cylinder along its local Y axis.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Cylinder.Id">
            <summary>
            Type id of cylinder shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.IShape">
            <summary>
            Defines a type usable as a shape by collidables.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.IShape.TypeId">
            <summary>
            Unique type id for this shape type.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.IShape.CreateShapeBatch(BepuUtilities.Memory.BufferPool,System.Int32,BepuPhysics.Collidables.Shapes)">
            <summary>
            Creates a shape batch for this type of shape.
            </summary>
            <param name="pool">Buffer pool used to create the batch.</param>
            <param name="initialCapacity">Initial capacity to allocate within the batch.</param>
            <param name="shapeBatches">The set of shapes to contain this batch.</param>
            <returns>Shape batch for the shape type.</returns>
            <remarks>This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine.
            Ideally, this would be implemented as a static abstract, but those aren't available yet.</remarks>
        </member>
        <member name="T:BepuPhysics.Collidables.IConvexShape">
            <summary>
            Defines functions available on all convex shapes. Convex shapes have no hollowed out regions; any line passing through a convex shape will never enter and exit more than once.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.IConvexShape.ComputeBounds(System.Numerics.Quaternion,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the bounding box of a shape given an orientation.
            </summary>
            <param name="orientation">Orientation of the shape to use when computing the bounding box.</param>
            <param name="min">Minimum corner of the bounding box.</param>
            <param name="max">Maximum corner of the bounding box.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IConvexShape.ComputeAngularExpansionData(System.Single@,System.Single@)">
            <summary>
            Computes information about how the bounding box should be expanded in response to angular velocity.
            </summary>
            <param name="maximumRadius"></param>
            <param name="maximumAngularExpansion"></param>
            <remarks>This is typically used in the engine for predicting bounding boxes at the beginning of the frame.
            Velocities are used to expand the bounding box so that likely future collisions will be detected.
            Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. 
            Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant.</remarks>
        </member>
        <member name="M:BepuPhysics.Collidables.IConvexShape.ComputeInertia(System.Single)">
            <summary>
            Computes the inertia for a body given a mass.
            </summary>
            <param name="mass">Mass to use to compute the body's inertia.</param>
            <returns>Inertia for the body.</returns>
            <remarks>Note that the <see cref="T:BepuPhysics.BodyInertia"/> returned by this stores the inverse mass and inverse inertia tensor. 
            This is because the most high frequency use of body inertia most naturally uses the inverse.</remarks>
        </member>
        <member name="M:BepuPhysics.Collidables.IConvexShape.RayTest(BepuPhysics.RigidPose@,System.Numerics.Vector3,System.Numerics.Vector3,System.Single@,System.Numerics.Vector3@)">
            <summary>
            Tests a ray against the shape.
            </summary>
            <param name="pose">Pose of the shape during the ray test.</param>
            <param name="origin">Origin of the ray to test against the shape relative to the shape.</param>
            <param name="direction">Direction of the ray to test against the shape.</param>
            <param name="t">Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t.</param>
            <param name="normal">Normal of the impact surface, if any.</param>
            <returns>True if the ray intersected the shape, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.ICompoundShape">
            <summary>
            Defines a compound shape type that has children of potentially different types.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ICompoundShape.ComputeBounds(System.Numerics.Quaternion,BepuPhysics.Collidables.Shapes,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the bounding box of a compound shape.
            </summary>
            <param name="orientation">Orientation of the compound.</param>
            <param name="shapeBatches">Shape batches to look up child shape information in.</param>
            <param name="min">Minimum of the compound's bounding box.</param>
            <param name="max">Maximum of the compound's bounding box.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ICompoundShape.AddChildBoundsToBatcher(BepuPhysics.BoundingBoxBatcher@,BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,System.Int32)">
            <summary>
            Submits child shapes to a bounding box batcher for vectorized bounds calculation.
            </summary>
            <remarks>This is used internally for bounding box calculation, but it is unlikely to be useful externally.</remarks>
            <param name="batcher">Batcher to accumulate children in.</param>
            <param name="pose">Pose of the compound.</param>
            <param name="velocity">Velocity of the compound used to expand child bounds.</param>
            <param name="bodyIndex">Index of the body in the active body set; used to accumulate child bounds results.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ICompoundShape.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RayData@,System.Single@,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Tests a ray against the shape.
            </summary>
            <param name="pose">Pose of the shape during the ray test.</param>
            <param name="ray">Ray to test against the shape.</param>
            <param name="maximumT">Maximum distance along the ray, in units of the ray direction's length, that the ray will test.</param>
            <param name="shapeBatches">Shape batches to look up child shapes in if necessary.</param>
            <param name="hitHandler">Callbacks called when the ray interacts with a test candidate.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ICompoundShape.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RaySource@,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Tests multiple rays against the shape.
            </summary>
            <param name="pose">Pose of the shape during the ray test.</param>
            <param name="rays">Rays to test against the shape.</param>
            <param name="shapeBatches">Shape batches to look up child shapes in if necessary.</param>
            <param name="hitHandler">Callbacks called when the ray interacts with a test candidate.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.ICompoundShape.ChildCount">
            <summary>
            Gets the number of children in the compound shape.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ICompoundShape.GetChild(System.Int32)">
            <summary>
            Gets a child from the compound by index.
            </summary>
            <param name="compoundChildIndex">Index of the child to look up.</param>
            <returns>Reference to the requested compound child.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.ICompoundShape.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Returns all resources used by the shape instance to the given pool.
            </summary>
            <param name="pool">Pool to return shape resources to.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.IHomogeneousCompoundShape`2">
            <summary>
            Defines a compound shape type that has children of only one type.
            </summary>
            <typeparam name="TChildShape">Type of the child shapes.</typeparam>
            <typeparam name="TChildShapeWide">Type of the child shapes, formatted in AOSOA layout.</typeparam>
        </member>
        <member name="M:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.ComputeBounds(System.Numerics.Quaternion,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the bounding box of a compound shape.
            </summary>
            <param name="orientation">Orientation of the compound.</param>
            <param name="min">Minimum of the compound's bounding box.</param>
            <param name="max">Maximum of the compound's bounding box.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RayData@,System.Single@,``0@)">
            <summary>
            Tests a ray against the shape.
            </summary>
            <param name="pose">Pose of the shape during the ray test.</param>
            <param name="ray">Ray to test against the shape.</param>
            <param name="maximumT">Maximum distance along the ray, in units of the ray direction's length, that the ray will test.</param>
            <param name="hitHandler">Callbacks called when the ray interacts with a test candidate.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RaySource@,``0@)">
            <summary>
            Tests multiple rays against the shape.
            </summary>
            <param name="pose">Pose of the shape during the ray test.</param>
            <param name="rays">Rays to test against the shape.</param>
            <param name="hitHandler">Callbacks called when the ray interacts with a test candidate.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.ChildCount">
            <summary>
            Gets the number of children in the compound shape.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.GetLocalChild(System.Int32,`0@)">
            <summary>
            Gets a child shape as it appears in the compound's local space.
            </summary>
            <param name="childIndex">Index of the child in the compound parent.</param>
            <param name="childData">Data representing the child.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.GetPosedLocalChild(System.Int32,`0@,BepuPhysics.RigidPose@)">
            <summary>
            Gets a child shape from the compound and compounds a pose for it in the local space of the compound parent.
            Useful for processes which require a child shape (like a triangle in a mesh) to have their center of mass at zero in the child's own local space.
            </summary>
            <param name="childIndex">Index of the child.</param>
            <param name="childData">Shape of the child.</param>
            <param name="childPose">Pose in the compound's local space that brings the child shape as described to the proper location in the parent compound's local space.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.GetLocalChild(System.Int32,`1@)">
            <summary>
            Gets a child shape as it appears in the compound's local space.
            </summary>
            <param name="childIndex">Index of the child in the compound parent.</param>
            <param name="childData">Reference to an AOSOA slot.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IHomogeneousCompoundShape`2.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Returns all resources used by the shape instance to the given pool.
            </summary>
            <param name="pool">Pool to return shape resources to.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.IShapeWide`1">
            <summary>
            Defines a widely vectorized bundle representation of a shape.
            </summary>
            <typeparam name="TShape">Scalar type of the shape.</typeparam>
        </member>
        <member name="P:BepuPhysics.Collidables.IShapeWide`1.AllowOffsetMemoryAccess">
            <summary>
            Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.IShapeWide`1.InternalAllocationSize">
            <summary>
            Gets the number of bytes required for allocations within the wide shape.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.Initialize(BepuUtilities.Memory.Buffer{System.Byte}@)">
            <summary>
            For types with a nonzero internal allocation size, provides memory to the shape for internal allocations.
            Memory should be assumed to be stack allocated.
            </summary>
            <param name="memory">Memory to use for internal allocations in the wide shape.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.WriteFirst(`0@)">
            <summary>
            Places the specified AOS-formatted shape into the first lane of the wide 'this' reference.
            </summary>
            <remarks>Note that we are effectively using the TShapeWide as a stride.
            The base address is offset by the user of this function, so the implementation only ever considers the first slot.</remarks>
            <param name="source">AOS-formatted shape to gather from.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.WriteSlot(System.Int32,`0@)">
            <summary>
            Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference.
            </summary>
            <param name="index">Index of the slot to put the data into.</param>
            <param name="source">Source of the data to insert.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.Broadcast(`0@)">
            <summary>
            Broadcasts a scalar shape into a bundle containing the same shape in every lane.
            </summary>
            <param name="shape">Scalar shape to broadcast.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.GetBounds(BepuUtilities.QuaternionWide@,System.Int32,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the bounds of all shapes in the bundle.
            </summary>
            <param name="orientations">Orientations of the shapes in the bundle.</param>
            <param name="countInBundle">Number of lanes filled in the bundle.</param>
            <param name="maximumRadius">Computed maximum radius of the shapes in the bundle.</param>
            <param name="maximumAngularExpansion">Computed maximum bounds expansion that can be caused by angular motion.</param>
            <param name="min">Minimum bounds of the shapes.</param>
            <param name="max">Maximum bounds of the shapes.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.IShapeWide`1.MinimumWideRayCount">
            <summary>
            Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.RayTest(BepuPhysics.RigidPoseWide@,BepuPhysics.Collidables.RayWide@,System.Numerics.Vector{System.Int32}@,System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@)">
            <summary>
            Tests a ray against the shape.
            </summary>
            <param name="poses">Poses of the shape bundle during the ray test.</param>
            <param name="rayWide">Ray to test against the shape bundle.</param>
            <param name="intersected">Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss.</param>
            <param name="t">Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t.</param>
            <param name="normal">Normal of the impact surface, if any.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.Mesh">
            <summary>
            Shape designed to contain a whole bunch of triangles. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Mesh.Tree">
            <summary>
            Acceleration structure of the mesh.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Mesh.Triangles">
            <summary>
            Buffer of triangles composing the mesh. Triangles will only collide with tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Mesh.Scale">
            <summary>
            Gets or sets the scale of the mesh.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.#ctor(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.Triangle},System.Numerics.Vector3,BepuUtilities.Memory.BufferPool)">
            <summary>
            Creates a mesh shape.
            </summary>
            <param name="triangles">Triangles to use in the mesh.</param>
            <param name="scale">Scale to apply to all vertices at runtime.
            Note that the scale is not baked into the triangles or acceleration structure; the same set of triangles and acceleration structure can be used across multiple Mesh instances with different scales.</param>
            <param name="pool">Pool used to allocate acceleration structures.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.#ctor(System.Span{System.Byte},BepuUtilities.Memory.BufferPool)">
            <summary>
            Loads a mesh from data stored in a byte buffer previously stored by the Serialize function.
            </summary>
            <param name="data">Data to load the mesh from.</param>
            <param name="pool">Pool to create the mesh with.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.GetSerializedByteCount">
            <summary>
            Gets the number of bytes it would take to store the given mesh in a byte buffer.
            </summary>
            <param name="mesh">Mesh to measure.</param>
            <returns>Number of bytes it would take to store the mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.Serialize(System.Span{System.Byte})">
            <summary>
            Writes a mesh's data to a byte buffer.
            </summary>
            <param name="mesh">Mesh to write into the byte buffer.</param>
            <param name="data">Byte buffer to store the mesh in.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RayData@,System.Single@,``0@)">
            <summary>
            Casts a ray against the mesh. Executes a callback for every test candidate and every hit.
            </summary>
            <typeparam name="TRayHitHandler">Type of the callback to execute for every test candidate and hit.</typeparam>
            <param name="pose">Pose of the mesh during the ray test.</param>
            <param name="ray">Ray to test against the mesh.</param>
            <param name="maximumT">Maximum length of the ray in units of the ray direction length.</param>
            <param name="hitHandler">Callback to execute for every hit.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RaySource@,``0@)">
            <summary>
            Casts a bunch of rays against the mesh at the same time, executing a callback for every test candidate and every hit.
            </summary>
            <typeparam name="TRayHitHandler">Type of the callback to execute for every ray test candidate and every hit.</typeparam>
            <param name="pose">Pose of the mesh during the ray test.</param>
            <param name="rays">Set of rays to cast against the mesh.</param>
            <param name="hitHandler">Callbacks to execute.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.Recenter(System.Numerics.Vector3)">
            <summary>
            Subtracts the newCenter from all points in the mesh hull.
            </summary>
            <param name="newCenter">New center that all points will be made relative to.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedInertia(System.Single,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of the mesh around its volumetric center and recenters the points of the mesh around it.
            Assumes the mesh is closed and should be treated as solid.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <param name="center">Center of the closed mesh.</param>
            <returns>Inertia tensor of the closed mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedInertia(System.Single)">
            <summary>
            Computes the inertia of the mesh.
            Assumes the mesh is closed and should be treated as solid.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <returns>Inertia tensor of the closed mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedCenterOfMass(System.Single@,System.Numerics.Vector3@)">
            <summary>
            Computes the volume and center of mass of the mesh. Assumes the mesh is closed and should be treated as solid.
            </summary>
            <param name="volume">Volume of the closed mesh.</param>
            <param name="center">Center of mass of the closed mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedCenterOfMass">
            <summary>
            Computes the center of mass of the mesh.
            Assumes the mesh is closed and should be treated as solid.
            </summary>
            <returns>Center of mass of the closed mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeOpenInertia(System.Single,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of the mesh around its volumetric center and recenters the points of the mesh around it.
            Assumes the mesh is open and should be treated as a triangle soup.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <param name="center">Center of the open mesh.</param>
            <returns>Inertia tensor of the closed mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeOpenInertia(System.Single)">
            <summary>
            Computes the inertia of the mesh.
            Assumes the mesh is open and should be treated as a triangle soup.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <returns>Inertia of the open mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeOpenCenterOfMass">
            <summary>
            Computes the center of mass of the mesh.
            Assumes the mesh is open and should be treated as a triangle soup.
            </summary>
            <returns>Center of mass of the open mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Returns the mesh's resources to a buffer pool.
            </summary>
            <param name="bufferPool">Pool to return the mesh's resources to.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Mesh.Id">
            <summary>
            Type id of mesh shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ITriangleSource">
            <summary>
            Defines a type capable of providing a sequence of triangles.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ITriangleSource.GetNextTriangle(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Gets the next triangle in the sequence, if any.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <returns>True if there was another triangle, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.MeshInertiaHelper">
            <summary>
            Provides helpers for computing the inertia of objects with triangular surfaces.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTetrahedronVolume(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Computes the signed volume of a tetrahedron where the fourth vertex is at the origin.
            Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates.
            </summary>
            <param name="a">First vertex of the tetrahedron.</param>
            <param name="b">Second vertex of the tetrahedron.</param>
            <param name="c">Third vertex of the tetrahedron.</param>
            <returns>Volume of the tetrahedron.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTetrahedronContribution(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Single@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Integrates the inertia contribution of a tetrahedron with vertices at a, b, c, and (0,0,0) assuming a density of 1.
            </summary>
            <param name="a">First vertex of the tetrahedron.</param>
            <param name="b">Second vertex of the tetrahedron.</param>
            <param name="c">Third vertex of the tetrahedron.</param>
            <param name="volume">Volume of the tetrahedron.</param>
            <param name="inertiaTensor">Inertia tensor of this tetrahedron assuming a density of 1.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeClosedInertia``1(``0@,System.Single,System.Single@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes the inertia of a closed mesh.
            Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="volume">Volume of the mesh.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeClosedInertia``1(``0@,System.Single,System.Single@,BepuUtilities.Symmetric3x3@,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of a closed mesh.
            Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="volume">Volume of the mesh.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
            <param name="center">Center of mass of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeClosedCenterOfMass``1(``0@,System.Single@,System.Numerics.Vector3@)">
            <summary>
            Computes the center of mass of a closed mesh.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="volume">Volume of the mesh.</param>
            <param name="center">Center of mass of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTriangleContribution(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Single,BepuUtilities.Symmetric3x3@)">
            <summary>
            Integrates the inertia contribution from a single triangle.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <param name="mass">Mass of the triangle.</param>
            <param name="inertiaTensor">Inertia tensor of the triangle.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTriangleArea(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Computes the area of a triangle.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <returns>Area of the triangle.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTriangleContribution(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Single@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Integrates the inertia contribution from a single triangle assuming a density of 1.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <param name="area">Area of the triangle.</param>
            <param name="inertiaTensor">Inertia tensor of the triangle assuming that the density is 1.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeOpenInertia``1(``0@,System.Single,BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes the inertia of an open mesh, treating it as a triangle soup.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeOpenInertia``1(``0@,System.Single,BepuUtilities.Symmetric3x3@,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of an open mesh, treating it as a triangle soup.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
            <param name="center">Center of mass of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeOpenCenterOfMass``1(``0@)">
            <summary>
            Computes the center of mass of an open mesh, treating it as a triangle soup.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <returns>Center of mass of the mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.GetInertiaOffset(System.Single,System.Numerics.Vector3,BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes an offset for an inertia tensor based on an offset frame of reference.
            </summary>
            <param name="mass">Mass associated with the inertia tensor being moved.</param>
            <param name="offset">Offset from the current inertia frame of reference to the new frame of reference.</param>
            <param name="inertiaOffset">Modification to add to the inertia tensor to move it into the new reference frame.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.Capacity">
            <summary>
            Gets the number of shapes that the batch can currently hold without resizing.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.TypeId">
            <summary>
            Gets the type id of the shape type in this batch.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.Compound">
            <summary>
            Gets whether this shape batch's contained type potentially contains children that require other shape batches.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.ShapeDataSize">
            <summary>
            Gets the size of the shape type stored in this batch in bytes.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.GetShapeData(System.Int32,System.Void*@,System.Int32@)">
            <summary>
            Gets a raw untyped pointer to a shape's data.
            </summary>
            <param name="shapeIndex">Index of the shape to look up.</param>
            <param name="shapePointer">Pointer to the indexed shape data.</param>
            <param name="shapeSize">Size of the shape data in bytes.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.Clear">
            <summary>
            Frees all shape slots without returning any resources to the pool.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.EnsureCapacity(System.Int32)">
            <summary>
            Increases the size of the type batch if necessary to hold the target capacity.
            </summary>
            <param name="shapeCapacity">Target capacity.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.Resize(System.Int32)">
            <summary>
            Changes the size of the type batch if the target capacity is different than the current capacity. Note that shrinking allocations is conservative; resizing will
            never allow an existing shape to point to unallocated memory.
            </summary>
            <param name="shapeCapacity">Target capacity.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.Dispose">
            <summary>
            Returns all backing resources to the pool, leaving the batch in an unusable state.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.ResizeIdPool(System.Int32)">
            <summary>
            Shrinks or expands the allocation of the batch's id pool. Note that shrinking allocations is conservative; resizing will never allow any pending ids to be lost.
            </summary>
            <param name="targetIdCapacity">Number of slots to allocate space for in the id pool.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch`1.Item(System.Int32)">
            <summary>
            Gets a reference to the shape associated with an index.
            </summary>
            <param name="shapeIndex">Index of the shape reference to retrieve.</param>
            <returns>Reference to the shape at the given index.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.IConvexShapeBatch">
            <summary>
            Defines a shape batch containing convex objects that support simple inertia calculations.
            </summary>
            <remarks>This interface gives compounds a way to compute inertia despite not having direct typed access to the child shapes.
            It's a layer of overhead that can usually be avoided, but it's sometimes convenient to be able to just enumerate child inertias.</remarks>
        </member>
        <member name="M:BepuPhysics.Collidables.IConvexShapeBatch.ComputeInertia(System.Int32,System.Single)">
            <summary>
            Computes the inertia of a shape.
            </summary>
            <param name="shapeIndex">Index of the shape to compute the inertia of.</param>
            <param name="mass">Mass to use to compute the inertia.</param>
            <returns>Inertia of the shape.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.UpdateBounds(BepuPhysics.RigidPose,BepuPhysics.Collidables.TypedIndex,BepuUtilities.BoundingBox@)">
            <summary>
            Computes a bounding box for a single shape.
            </summary>
            <param name="pose">Pose to calculate the bounding box of.</param>
            <param name="shapeIndex">Index of the shape.</param>
            <param name="bounds">Bounding box of the specified shape with the specified pose.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.UpdateBounds(System.Numerics.Vector3,System.Numerics.Quaternion,BepuPhysics.Collidables.TypedIndex,BepuUtilities.BoundingBox@)">
            <summary>
            Computes a bounding box for a single shape.
            </summary>
            <param name="position">Position of the shape.</param>
            <param name="orientation">Orientation of the shape.</param>
            <param name="shapeIndex">Index of the shape.</param>
            <param name="bounds">Bounding box of the specified shape with the specified pose.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.RecursivelyRemoveAndDispose(BepuPhysics.Collidables.TypedIndex,BepuUtilities.Memory.BufferPool)">
            <summary>
            Removes a shape and any existing children from the shapes collection and returns their resources to the given pool.
            </summary>
            <param name="shapeIndex">Index of the shape to remove.</param>
            <param name="pool">Pool to return all shape resources to.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.RemoveAndDispose(BepuPhysics.Collidables.TypedIndex,BepuUtilities.Memory.BufferPool)">
            <summary>
            Removes a shape from the shapes collection and returns its resources to the given pool. Does not remove or dispose any children.
            </summary>
            <param name="shapeIndex">Index of the shape to remove.</param>
            <param name="pool">Pool to return all shape resources to.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.Remove(BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Removes a shape without removing its children or disposing any resources.
            </summary>
            <param name="shapeIndex">Index of the shape to remove.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.Clear">
            <summary>
            Clears all shapes from existing batches. Does not release any memory.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.EnsureBatchCapacities(System.Int32)">
            <summary>
            Ensures a minimum capacity for all existing shape batches.
            </summary>
            <param name="shapeCapacity">Capacity to ensure for all existing shape batches.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.ResizeBatches(System.Int32)">
            <summary>
            Resizes all existing batches for a target capacity. Note that this is conservative; it will never orphan an existing shape.
            </summary>
            <param name="shapeCapacity">Capacity to target for all existing shape batches.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.Dispose">
            <summary>
            Releases all memory from existing batches. Leaves shapes set in an unusable state.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Sphere.Radius">
            <summary>
            Radius of the sphere.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Sphere.#ctor(System.Single)">
            <summary>
            Creates a sphere shape.
            </summary>
            <param name="radius">Radius of the sphere.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Sphere.Id">
            <summary>
            Type id of sphere shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.Triangle">
            <summary>
            Collision shape representing an individual triangle. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.A">
            <summary>
            First vertex of the triangle in local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.B">
            <summary>
            Second vertex of the triangle in local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.C">
            <summary>
            Third vertex of the triangle in local space.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Triangle.#ctor(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Creates a triangle shape.
            </summary>
            <param name="a">First vertex of the triangle in local space.</param>
            <param name="b">Second vertex of the triangle in local space.</param>
            <param name="c">Third vertex of the triangle in local space.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.Id">
            <summary>
            Type id of triangle shapes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.TriangleWide.BackfaceNormalDotRejectionThreshold">
            <summary>
            Minimum dot product between the detected local normal and the face normal of a triangle necessary to create contacts.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.TriangleWide.DegenerateTriangleEpsilon">
            <summary>
            Epsilon to apply to testing triangles for degeneracy (which will be scaled by a pair-determined epsilon scale). Degenerate triangles do not have well defined normals and should not contribute 
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.TypedIndex">
            <summary>
            Represents an index with an associated type packed into a single integer.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.TypedIndex.Packed">
            <summary>
            Bit packed representation of the typed index.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.TypedIndex.Type">
            <summary>
            Gets the type index of the object.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.TypedIndex.Index">
            <summary>
            Gets the index of the object.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.TypedIndex.Exists">
            <summary>
            Gets whether this index actually refers to anything. The Type and Index should only be used if this is true.
            </summary>
        </member>
        <member name="P:BepuPhysics.BoundsContinuation.BodyIndex">
            <summary>
            Gets the index of the body associated with this continuation.
            </summary>
        </member>
        <member name="P:BepuPhysics.BoundsContinuation.CompoundChild">
            <summary>
            Gets whether this continuation is associated with a compound's child.
            </summary>
        </member>
        <member name="M:BepuPhysics.BoundsContinuation.CreateContinuation(System.Int32)">
            <summary>
            Creates a bounding box calculation continuation for a given noncompound body.
            </summary>
            <param name="bodyIndex">Index of the body to set the bounding box of.</param>
        </member>
        <member name="M:BepuPhysics.BoundsContinuation.CreateCompoundChildContinuation(System.Int32)">
            <summary>
            Creates a bounding box calculation continuation for a given compound body.
            </summary>
            <param name="compoundBodyIndex">Index of the compound body to set the bounding box of.</param>
        </member>
        <member name="F:BepuPhysics.BoundingBoxBatcher.CollidablesPerFlush">
            <summary>
            The number of bodies to accumulate per type before executing an AABB update. The more bodies per batch, the less virtual overhead and execution divergence.
            However, this should be kept low enough such that the data that has to be gathered by the bounding box update is still usually in L1.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.BroadPhase">
            <summary>
            Manages scene acceleration structures for collision detection and queries.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.BroadPhase.ActiveLeaves">
            <summary>
            Collidable references contained within the <see cref="F:BepuPhysics.CollisionDetection.BroadPhase.ActiveTree"/>. Note that values at or beyond the <see cref="F:BepuPhysics.CollisionDetection.BroadPhase.ActiveTree"/>.LeafCount are not defined.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.BroadPhase.StaticLeaves">
            <summary>
            Collidable references contained within the <see cref="F:BepuPhysics.CollisionDetection.BroadPhase.StaticTree"/>. Note that values at or beyond <see cref="F:BepuPhysics.CollisionDetection.BroadPhase.StaticTree"/>.LeafCount are not defined.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.BroadPhase.Pool">
            <summary>
            Pool used by the broad phase.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.BroadPhase.ActiveTree">
            <summary>
            Tree containing wakeful bodies.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.BroadPhase.StaticTree">
            <summary>
            Tree containing sleeping bodies and statics.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.GetActiveBoundsPointers(System.Int32,System.Numerics.Vector3*@,System.Numerics.Vector3*@)">
            <summary>
            Gets pointers to the leaf's bounds stored in the broad phase's active tree.
            </summary>
            <param name="index">Index of the active collidable to examine.</param>
            <param name="minPointer">Pointer to the minimum bounds in the tree.</param>
            <param name="maxPointer">Pointer to the maximum bounds in the tree.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.GetStaticBoundsPointers(System.Int32,System.Numerics.Vector3*@,System.Numerics.Vector3*@)">
            <summary>
            Gets pointers to the leaf's bounds stored in the broad phase's static tree.
            </summary>
            <param name="index">Index of the static to examine.</param>
            <param name="minPointer">Pointer to the minimum bounds in the tree.</param>
            <param name="maxPointer">Pointer to the maximum bounds in the tree.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.UpdateActiveBounds(System.Int32,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Applies updated bounds to the given active leaf index, refitting the tree to match.
            </summary>
            <param name="broadPhaseIndex">Index of the leaf to update.</param>
            <param name="min">New minimum bounds for the leaf.</param>
            <param name="max">New maximum bounds for the leaf.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.UpdateStaticBounds(System.Int32,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Applies updated bounds to the given active leaf index, refitting the tree to match.
            </summary>
            <param name="broadPhaseIndex">Index of the leaf to update.</param>
            <param name="min">New minimum bounds for the leaf.</param>
            <param name="max">New maximum bounds for the leaf.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Clear">
            <summary>
            Clears out the broad phase's structures without releasing any resources.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.EnsureCapacity(System.Int32,System.Int32)">
            <summary>
            Ensures that the broad phase structures can hold at least the given number of leaves.
            </summary>
            <param name="activeCapacity">Number of leaves to allocate space for in the active tree.</param>
            <param name="staticCapacity">Number of leaves to allocate space for in the static tree.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Resize(System.Int32,System.Int32)">
            <summary>
            Resizes the broad phase structures to hold the given number of leaves. Note that this is conservative; it will never orphan any existing leaves.
            </summary>
            <param name="activeCapacity">Number of leaves to allocate space for in the active tree.</param>
            <param name="staticCapacity">Number of leaves to allocate space for in the static tree.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Dispose">
            <summary>
            Releases memory used by the broad phase. Leaves the broad phase unusable.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.RayCast``1(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,``0@,System.Int32)">
            <summary>
            Finds any intersections between a ray and leaf bounding boxes.
            </summary>
            <typeparam name="TRayTester">Type of the callback to execute on ray-leaf bounding box intersections.</typeparam>
            <param name="origin">Origin of the ray to cast.</param>
            <param name="direction">Direction of the ray to cast.</param>
            <param name="maximumT">Maximum length of the ray traversal in units of the direction's length.</param>
            <param name="rayTester">Callback to execute on ray-leaf bounding box intersections.</param>
            <param name="id">User specified id of the ray.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Sweep``1(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Single,``0@)">
            <summary>
            Finds any intersections between a swept bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TSweepTester">Type of the callback to execute on sweep-leaf bounding box intersections.</typeparam>
            <param name="min">Minimum bounds of the box to sweep.</param>
            <param name="max">Maximum bounds of the box to sweep.</param>
            <param name="direction">Direction along which to sweep the bounding box.</param>
            <param name="maximumT">Maximum length of the sweep in units of the direction's length.</param>
            <param name="sweepTester">Callback to execute on sweep-leaf bounding box intersections.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Sweep``1(BepuUtilities.BoundingBox@,System.Numerics.Vector3,System.Single,``0@)">
            <summary>
            Finds any intersections between a swept bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TSweepTester">Type of the callback to execute on sweep-leaf bounding box intersections.</typeparam>
            <param name="boundingBox">Bounding box to sweep.</param>
            <param name="direction">Direction along which to sweep the bounding box.</param>
            <param name="maximumT">Maximum length of the sweep in units of the direction's length.</param>
            <param name="sweepTester">Callback to execute on sweep-leaf bounding box intersections.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.GetOverlaps``1(System.Numerics.Vector3,System.Numerics.Vector3,``0@)">
            <summary>
            Finds any overlaps between a bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TOverlapEnumerator">Type of the enumerator to call for overlaps.</typeparam>
            <param name="min">Minimum bounds of the query box.</param>
            <param name="max">Maximum bounds of the query box.</param>
            <param name="overlapEnumerator">Enumerator to call for overlaps.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.GetOverlaps``1(BepuUtilities.BoundingBox@,``0@)">
            <summary>
            Finds any overlaps between a bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TOverlapEnumerator">Type of the enumerator to call for overlaps.</typeparam>
            <param name="boundingBox">Query box bounds.</param>
            <param name="overlapEnumerator">Enumerator to call for overlaps.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.IBroadPhaseSweepTester">
            <summary>
            Defines a type that can act as a callback for broad phase sweep tests.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionBatcher`1.Dt">
            <summary>
            Timestep duration used by pairs which rely on velocity to compute local bounding boxes for pruning.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionBatcher`1.Flush">
            <summary>
            Forces any remaining partial batches to execute and disposes the batcher.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionBatcher`1.ProcessConvexResult(BepuPhysics.CollisionDetection.ConvexContactManifold@,BepuPhysics.CollisionDetection.PairContinuation@)">
            <summary>
            Reports the result of a convex collision test to the callbacks and, if necessary, to any continuations for postprocessing.
            </summary>
            <remarks>Unless you're building custom compound collision pairs or adding new contact processing continuations, you can safely ignore this.</remarks>
            <param name="manifold">Contacts detected for the pair.</param>
            <param name="continuation">Continuation describing the pair and what to do with it.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionBatcher`1.ProcessEmptyResult(BepuPhysics.CollisionDetection.PairContinuation@)">
            <summary>
            Reports the zero result of a convex collision test to the callbacks and, if necessary, to any continuations for postprocessing.
            </summary>
            <remarks>Unless you're building custom compound collision pairs or adding new contact processing continuations, you can safely ignore this.</remarks>
            <param name="continuation">Continuation describing the pair and what to do with it.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionBatcher`1.ProcessUntestedSubpairConvexResult(BepuPhysics.CollisionDetection.PairContinuation@)">
            <summary>
            Submits a subpair whose testing was blocked by user callback as complete to any relevant continuations.
            </summary>
            <remarks>Unless you're building custom compound collision pairs or adding new contact processing continuations, you can safely ignore this.</remarks>
            <param name="continuation">Continuation describing the pair and what to do with it.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ICollisionTestContinuation">
            <summary>
            Defines a type which includes information necessary to apply some form of post processing to a collision test result.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionTestContinuation.Create(System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Creates a collision test continuation with the given number of slots for subpairs.
            </summary>
            <param name="slots">Number of subpair slots to include in the continuation.</param>
            <param name="pool">Pool to take resources from.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionTestContinuation.OnChildCompleted``1(BepuPhysics.CollisionDetection.PairContinuation@,BepuPhysics.CollisionDetection.ConvexContactManifold@,BepuPhysics.CollisionDetection.CollisionBatcher{``0}@)">
            <summary>
            Handles what to do next when the child pair has finished execution and the resulting manifold is available.
            </summary>
            <typeparam name="TCallbacks">Type of the callbacks used in the batcher.</typeparam>
            <param name="report">Continuation instance being considered.</param>
            <param name="manifold">Contact manifold for the child pair.</param>
            <param name="batcher">Collision batcher processing the pair.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionTestContinuation.OnUntestedChildCompleted``1(BepuPhysics.CollisionDetection.PairContinuation@,BepuPhysics.CollisionDetection.CollisionBatcher{``0}@)">
            <summary>
            Handles what to do next when the child pair was rejected for testing, and no manifold exists.
            </summary>
            <typeparam name="TCallbacks">Type of the callbacks used in the batcher.</typeparam>
            <param name="report">Continuation instance being considered.</param>
            <param name="batcher">Collision batcher processing the pair.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionTestContinuation.TryFlush``1(System.Int32,BepuPhysics.CollisionDetection.CollisionBatcher{``0}@)">
            <summary>
            Checks if the parent pair is complete and should be flushed.
            </summary>
            <typeparam name="TCallbacks">Type of the callbacks used in the batcher.</typeparam>
            <param name="pairId">Id of the pair to attempt to flush.</param>
            <param name="batcher">Collision batcher processing the pair.</param>
            <returns>True if the pair was done and got flushed, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionContinuationType">
            <summary>
            Describes the flow control to apply to a convex-convex pair report.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.Direct">
            <summary>
            Marks a pair as requiring no further processing before being reported to the user supplied continuations.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.NonconvexReduction">
            <summary>
            Marks a pair as part of a set of a higher (potentially multi-manifold) pair, potentially requiring contact reduction.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.MeshReduction">
            <summary>
            Marks a pair as a part of a set of mesh-convex collisions, potentially requiring mesh boundary smoothing.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.CompoundMeshReduction">
            <summary>
            Marks a pair as a part of a set of mesh-convex collisions spawned by a mesh-compound pair, potentially requiring mesh boundary smoothing.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairContinuation.ChildIndexBits">
            <summary>
            Covers bits [0, 20) in the packed representation. Refers to the child pair index in a subtask generating collision task that generated this continuation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairContinuation.ContinuationIndexBits">
            <summary>
            Covers bits [20, 30) in the packed representation. Refers to the index of a subpair in a continuation processor.
            Maximum number should be equal to the sum of the batch sizes subtask generating collision tasks, which as of this writing is 384, but we'll include a little buffer.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairContinuation.ContinuationTypeBits">
            <summary>
            Covers bits [30, 32) in the packed representation. Refers to which continuation processor should be used for this subpair.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ICollisionCallbacks">
            <summary>
            Callbacks invoked by a <see cref="T:BepuPhysics.CollisionDetection.CollisionBatcher`1"/>.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionCallbacks.OnPairCompleted``1(System.Int32,``0@)">
            <summary>
            Called when a pair submitted to a collision batcher has finished collision detection.
            </summary>
            <typeparam name="TManifold">Type of the contact manifold generated by collision detection.</typeparam>
            <param name="pairId">Id of the pair that completed.</param>
            <param name="manifold">Contact manifold generated by collision testing.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionCallbacks.OnChildPairCompleted(System.Int32,System.Int32,System.Int32,BepuPhysics.CollisionDetection.ConvexContactManifold@)">
            <summary>
            Provides control over subtask generated results before they are reported to the parent task.
            </summary>
            <param name="pairId">Id of the parent pair that spawned this child pair.</param>
            <param name="childA">Index of the child belonging to collidable A in the subpair under consideration.</param>
            <param name="childB">Index of the child belonging to collidable B in the subpair under consideration.</param>
            <param name="manifold">Manifold of the child pair to configure.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionCallbacks.AllowCollisionTesting(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether further collision testing should be performed for a given subtask.
            </summary>
            <param name="pairId">Id of the parent pair.</param>
            <param name="childA">Index of the child belonging to collidable A in the subpair under consideration.</param>
            <param name="childB">Index of the child belonging to collidable B in the subpair under consideration.</param>
            <returns>True if testing should proceed, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTask">
            <summary>
            Parent type of tasks which handle collision tests between batches of shapes of a particular type.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.BatchSize">
            <summary>
            Gets the number of tasks to batch together before executing this task.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.ShapeTypeIndexA">
            <summary>
            Gets the first shape type index associated with the task. Shape pairs provided to the task for execution should be in the order defined by these type two indices.
            If a collision task isn't a top level shape pair task, this should be -1.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.ShapeTypeIndexB">
            <summary>
            Gets the second shape type index associated with the task. Shape pairs provided to the task for execution should be in the order defined by these type two indices.
            If a collision task isn't a top level shape pair task, this should be -1.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.SubtaskGenerator">
            <summary>
            Gets whether the task is capable of generating subtasks. Note that subtask generators cannot generate subtasks that are themselves subtask generators.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.PairType">
            <summary>
            Gets the pair type that the ExecuteBatch call requires.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionTask.ExecuteBatch``1(BepuPhysics.CollisionDetection.UntypedList@,BepuPhysics.CollisionDetection.CollisionBatcher{``0}@)">
            <summary>
            Executes the task on the given input.
            </summary>
            <typeparam name="TCallbacks">Type of the callbacks used to handle results of collision tasks.</typeparam>
            <param name="batcher">Batcher responsible for the invocation.</param>
            <param name="batch">Batch of pairs to test.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTaskPairType">
            <summary>
            Describes the data requirements for a collision pair type in a <see cref="T:BepuPhysics.CollisionDetection.CollisionBatcher`1"/>.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.StandardPair">
            <summary>
            General pair for two shapes with full pose and flip mask, but no bounds related data.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.FliplessPair">
            <summary>
            Pair specialized for convex pairs between two shapes of the same type.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.SpherePair">
            <summary>
            Pair specialized for two spheres, requiring no flip mask or orientations.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.SphereIncludingPair">
            <summary>
            Pair specialized for convex pairs that involve one sphere which requires no orientation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.BoundsTestedPair">
            <summary>
            Pair that requires computing local bounding boxes, and so requires extra information like velocity.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTaskReference">
            <summary>
            Metadata about a collision task.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskReference.TaskIndex">
            <summary>
            Index of the task in the registry.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskReference.BatchSize">
            <summary>
            Number of pairs to accumulate in a batch before dispatching tests.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskReference.ExpectedFirstTypeId">
            <summary>
            The type id that is expected to come first in the collision pair.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskReference.PairType">
            <summary>
            Data requirements for the collision pair type in a <see cref="T:BepuPhysics.CollisionDetection.CollisionBatcher`1"/>.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTaskRegistry">
            <summary>
            Registry of collision tasks used to handle various shape pair types.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTaskRegistry.Item(System.Int32)">
            <summary>
            Gets the collision task associated with a task index.
            </summary>
            <param name="taskIndex">Task index to look up.</param>
            <returns>Task associated with the task index.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionTaskRegistry.#ctor(System.Int32)">
            <summary>
            Creates a new collision task registry.
            </summary>
            <param name="initialShapeCount">Initial number of shape types to allocate space for in the registry.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionTaskRegistry.Register(BepuPhysics.CollisionDetection.CollisionTask)">
            <summary>
            Registers a collision task.
            </summary>
            <param name="task">Task to register.</param>
            <returns>Index of the task in the registry.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionTaskRegistry.GetTaskReference(System.Int32,System.Int32)">
            <summary>
            Gets metadata about the task associated with a shape type pair.
            </summary>
            <param name="topLevelTypeA">Type index of the first shape.</param>
            <param name="topLevelTypeB">Type index of the second shape.</param>
            <returns>Reference to the metadata for the task.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionTaskRegistry.GetTaskReference``2">
            <summary>
            Gets metadata about the task associated with a shape type pair.
            </summary>
            <typeparam name="TShapeA">Type of the first shape.</typeparam>
            <typeparam name="TShapeB">Type of the second shape.</typeparam>
            <returns>Reference to the metadata for the task.</returns>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTasks.IPairTester`3.BatchSize">
            <summary>
            Gets the nubmer of pairs which would ideally be gathered together before executing a wide test.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPair`1">
            <summary>
            Defines a type that holds scalar data for the collision batcher.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPair`1.PairType">
            <summary>
            Gets the enumeration type associated with this pair type.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTasks.CollisionPair.FlipMask">
            <summary>
            Stores whether the types involved in pair require that the resulting contact manifold be flipped to be consistent with the user-requested pair order.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTasks.SphereIncludingPair.FlipMask">
            <summary>
            Stores whether the types involved in pair require that the resulting contact manifold be flipped to be consistent with the user-requested pair order.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTasks.BoundsTestedPair">
            <summary>
            Pair of objects awaiting collision processing that involves velocities for bounds calculation.
            </summary>
            <typeparam name="TA">Type of the first shape in the pair.</typeparam>
            <typeparam name="TB">Type of the second shape in the pair.</typeparam>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ConstraintRemover">
            <summary>
            Accumulates constraints to remove from multiple threads, and efficiently removes them all as a batch.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConstraintRemover.CreateFlushJobs(System.Boolean)">
            <summary>
            Processes enqueued constraint removals and prepares removal jobs.
            </summary>
            <param name="deterministic">True if the constraint remover should maintain determinism at an added cost, false otherwise.</param>
            <returns>The number of removal jobs created. To complete the jobs, execute RemoveConstraintsFromTypeBatch for every index from 0 to the returned job count.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConstraintRemover.ReturnConstraintHandles">
            <summary>
            Returns the handles associated with all removed constraints to the solver's handle pool.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConstraintRemover.MarkAffectedConstraintsAsRemovedFromSolver">
            <summary>
            For uses of the ConstraintRemover that fully remove a constraint from the simulation (rather than simply moving it somewhere else),
            the handle->constraint mapping must be updated. This has to wait until after the multithreaded operations actually complete to avoid corrupting parallel operations.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ContactConstraintAccessor">
            <summary>
            Provides indirection for reading from and updating constraints in the narrow phase.
            </summary>
            <remarks>This, like many other similar constructions in the engine, could conceptually be replaced by static function pointers and a few supplementary data fields.
            We probably will do exactly that at some point.</remarks>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactData``1(BepuPhysics.ConstraintHandle,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintHandle">Handle of the contact constraint to extract.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactData``1(BepuPhysics.ConstraintLocation@,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintLocation">Location of the constraint in the solver.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactPrestepAndImpulses``1(BepuPhysics.ConstraintHandle,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintHandle">Handle of the contact constraint to extract.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactPrestepAndImpulses``1(BepuPhysics.ConstraintLocation@,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintLocation">Location of the constraint in the solver.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.NonconvexContact">
            <summary>
            Information about a single contact in a nonconvex collidable pair.
            Nonconvex pairs can have different surface bases at each contact point, since the contact surface is not guaranteed to be a plane.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.Offset">
            <summary>
            Offset from the position of collidable A to the contact position. 
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.Depth">
            <summary>
            Penetration depth between the two collidables at this contact. Negative values represent separation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.Normal">
            <summary>
            Surface basis of the contact. If transformed into a rotation matrix, X and Z represent tangent directions and Y represents the contact normal. Points from collidable B to collidable A.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.FeatureId">
            <summary>
            Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the
            same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ConvexContact">
            <summary>
            Information about a single contact in a convex collidable pair. Convex collidable pairs share one surface basis across the manifold, since the contact surface is guaranteed to be a plane.
            </summary>    
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContact.Offset">
            <summary>
            Offset from the position of collidable A to the contact position. 
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContact.Depth">
            <summary>
            Penetration depth between the two collidables at this contact. Negative values represent separation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContact.FeatureId">
            <summary>
            Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the
            same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.IContactManifold`1.Count">
            <summary>
            Gets the number of contacts in the manifold.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.IContactManifold`1.Convex">
            <summary>
            Gets whether the contact manifold was created by a pair of convex objects or not. True if convex, false if nonconvex.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetFeatureId(System.Int32)">
            <summary>
            Retrieves the feature id associated with a requested contact.
            </summary>
            <param name="contactIndex">Index of the contact to grab the feature id of.</param>
            <returns>Feature id of the requested contact.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetContact(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,System.Int32@)">
            <summary>
            Retrieves a copy of a contact's data.
            </summary>
            <param name="contactIndex">Index of the contact to copy data from.</param>
            <param name="offset">Offset from the first collidable's position to the contact position.</param>
            <param name="normal">Normal of the contact surface at the requested contact. Points from collidable B to collidable A.</param>
            <param name="depth">Penetration depth at the requested contact.</param>
            <param name="featureId">Feature id of the requested contact.
            Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetDepth(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's depth.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's depth.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetNormal(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's normal. Points from collidable B to collidable A. For convex manifolds that share a normal, all contact indices will simply return a reference to the manifold-wide normal.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's normal (or the manifold-wide normal in a convex manifold).</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetOffset(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's offset.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's offset.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetFeatureId(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's feature id.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's feature id.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.NonconvexContactManifold">
            <summary>
            Contains the data associated with a nonconvex contact manifold.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContactManifold.OffsetB">
            <summary>
            Offset from collidable A to collidable B.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContactManifold.MaximumContactCount">
            <summary>
            The maximum number of contacts that can exist within a nonconvex manifold.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetContact(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,System.Int32@)">
            <summary>
            Retrieves a copy of a contact's data.
            </summary>
            <param name="contactIndex">Index of the contact to copy data from.</param>
            <param name="offset">Offset from the first collidable's position to the contact position.</param>
            <param name="normal">Normal of the contact surface at the requested contact. Points from collidable B to collidable A.</param>
            <param name="depth">Penetration depth at the requested contact.</param>
            <param name="featureId">Feature id of the requested contact.
            Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetFeatureId(System.Int32)">
            <summary>
            Retrieves the feature id associated with a requested contact.
            </summary>
            <param name="contactIndex">Index of the contact to grab the feature id of.</param>
            <returns>Feature id of the requested contact.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetDepth(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's depth.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's depth.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetNormal(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's normal. Points from collidable B to collidable A.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's normal.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetOffset(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's offset.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's offset.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetFeatureId(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's feature id.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's feature id.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ConvexContactManifold">
            <summary>
            Contains the data associated with a convex contact manifold.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContactManifold.OffsetB">
            <summary>
            Offset from collidable A to collidable B.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContactManifold.Normal">
            <summary>
            Surface normal shared by all contacts. Points from collidable B to collidable A.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetFeatureId(System.Int32)">
            <summary>
            Retrieves the feature id associated with a requested contact.
            </summary>
            <param name="contactIndex">Index of the contact to grab the feature id of.</param>
            <returns>Feature id of the requested contact.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetContact(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,System.Int32@)">
            <summary>
            Retrieves a copy of a contact's data.
            </summary>
            <param name="contactIndex">Index of the contact to copy data from.</param>
            <param name="offset">Offset from the first collidable's position to the contact position.</param>
            <param name="normal">Normal of the contact surface at the requested contact. Points from collidable B to collidable A.</param>
            <param name="depth">Penetration depth at the requested contact.</param>
            <param name="featureId">Feature id of the requested contact.
            Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetDepth(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's depth.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's depth.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetNormal(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact manifold's normal. Points from collidable B to collidable A. Convex manifolds share a single normal across all contacts.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to the contact manifold's normal.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetOffset(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's offset.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's offset.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetFeatureId(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's feature id.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's feature id.</returns>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CCDContinuationIndex.Index">
            <summary>
            Gets the index of the continuation.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CCDContinuationIndex.Type">
            <summary>
            Gets the type index of the continuation.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CCDContinuationIndex.Exists">
            <summary>
            Gets whether this index actually refers to anything. The Type and Index should only be used if this is true.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.DepthRefiner`6">
            <summary>
            Incrementally refines a sample direction to approach a local minimum depth between two convex bodies.
            </summary>
            <remarks>
            The DepthRefiner implements a Tootbird search: an incremental algorithm that takes steps towards the Tootbird.
            The Tootbird is the origin projected on the support plane of the best(lowest depth) support direction observed so far.
            This uses a simplex that updates with rules similar to a simplified version of GJK.The Tootbird is definitionally not inside the minkowski sum.</remarks>
            <typeparam name="TShapeA">Type of the first shape.</typeparam>
            <typeparam name="TShapeWideA">SIMD type of the first shape.</typeparam>
            <typeparam name="TSupportFinderA">Type providing support sampling for the first shape.</typeparam>
            <typeparam name="TShapeB">Type of the second shape.</typeparam>
            <typeparam name="TShapeWideB">SIMD type of the second shape.</typeparam>
            <typeparam name="TSupportFinderB">Type providing support sampling for the second shape.</typeparam>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.PairMaterialProperties">
            <summary>
            Material properties governing the interaction between colliding bodies. Used by the narrow phase to create constraints of the appropriate configuration.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairMaterialProperties.FrictionCoefficient">
            <summary>
            Coefficient of friction to apply for the constraint. Maximum friction force will be equal to the normal force times the friction coefficient.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairMaterialProperties.MaximumRecoveryVelocity">
            <summary>
            Maximum relative velocity along the contact normal at which the collision constraint will recover from penetration. Clamps the velocity goal created from the spring settings.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairMaterialProperties.SpringSettings">
            <summary>
            Defines the constraint's penetration recovery spring properties.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.PairMaterialProperties.#ctor(System.Single,System.Single,BepuPhysics.Constraints.SpringSettings)">
            <summary>
            Constructs a pair's material properties.
            </summary>
            <param name="frictionCoefficient">Coefficient of friction to apply for the constraint. Maximum friction force will be equal to the normal force times the friction coefficient.</param>
            <param name="maximumRecoveryVelocity">Maximum relative velocity along the contact normal at which the collision constraint will recover from penetration. Clamps the velocity goal created from the spring settings. </param>
            <param name="springSettings">Defines the constraint's penetration recovery spring properties.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks">
            <summary>
            Defines handlers for narrow phase events.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.Initialize(BepuPhysics.Simulation)">
            <summary>
            Performs any required initialization logic after the Simulation instance has been constructed.
            </summary>
            <param name="simulation">Simulation that owns these callbacks.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.AllowContactGeneration(System.Int32,BepuPhysics.Collidables.CollidableReference,BepuPhysics.Collidables.CollidableReference,System.Single@)">
            <summary>
            Chooses whether to allow contact generation to proceed for two overlapping collidables.
            </summary>
            <param name="workerIndex">Index of the worker that identified the overlap.</param>
            <param name="a">Reference to the first collidable in the pair.</param>
            <param name="b">Reference to the second collidable in the pair.</param>
            <param name="speculativeMargin">Reference to the speculative margin used by the pair.
            The value was already initialized by the narrowphase by examining the speculative margins of the involved collidables, but it can be modified.</param>
            <returns>True if collision detection should proceed, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.ConfigureContactManifold``1(System.Int32,BepuPhysics.CollisionDetection.CollidablePair,``0@,BepuPhysics.CollisionDetection.PairMaterialProperties@)">
            <summary>
            Provides a notification that a manifold has been created for a pair. Offers an opportunity to change the manifold's details. 
            </summary>
            <param name="workerIndex">Index of the worker thread that created this manifold.</param>
            <param name="pair">Pair of collidables that the manifold was detected between.</param>
            <param name="manifold">Set of contacts detected between the collidables.</param>
            <param name="pairMaterial">Material properties of the manifold.</param>
            <returns>True if a constraint should be created for the manifold, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.AllowContactGeneration(System.Int32,BepuPhysics.CollisionDetection.CollidablePair,System.Int32,System.Int32)">
            <summary>
            Chooses whether to allow contact generation to proceed for the children of two overlapping collidables in a compound-including pair.
            </summary>
            <param name="workerIndex">Index of the worker thread processing this pair.</param>
            <param name="pair">Parent pair of the two child collidables.</param>
            <param name="childIndexA">Index of the child of collidable A in the pair. If collidable A is not compound, then this is always 0.</param>
            <param name="childIndexB">Index of the child of collidable B in the pair. If collidable B is not compound, then this is always 0.</param>
            <returns>True if collision detection should proceed, false otherwise.</returns>
            <remarks>This is called for each sub-overlap in a collidable pair involving compound collidables. If neither collidable in a pair is compound, this will not be called.
            For compound-including pairs, if the earlier call to AllowContactGeneration returns false for owning pair, this will not be called. Note that it is possible
            for this function to be called twice for the same subpair if the pair has continuous collision detection enabled; 
            the CCD sweep test that runs before the contact generation test also asks before performing child pair tests.</remarks>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.ConfigureContactManifold(System.Int32,BepuPhysics.CollisionDetection.CollidablePair,System.Int32,System.Int32,BepuPhysics.CollisionDetection.ConvexContactManifold@)">
            <summary>
            Provides a notification that a manifold has been created between the children of two collidables in a compound-including pair.
            Offers an opportunity to change the manifold's details. 
            </summary>
            <param name="workerIndex">Index of the worker thread that created this manifold.</param>
            <param name="pair">Pair of collidables that the manifold was detected between.</param>
            <param name="childIndexA">Index of the child of collidable A in the pair. If collidable A is not compound, then this is always 0.</param>
            <param name="childIndexB">Index of the child of collidable B in the pair. If collidable B is not compound, then this is always 0.</param>
            <param name="manifold">Set of contacts detected between the collidables.</param>
            <returns>True if this manifold should be considered for constraint generation, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.Dispose">
            <summary>
            Releases any resources held by the callbacks. Called by the owning narrow phase when it is being disposed.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.ISupportFinder`2.HasMargin">
            <summary>
            Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ISupportFinder`2.GetMargin(`1@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Margin associated with the shape according to this support finder.
            </summary>
            <param name="shape">Shape to find the margin of.</param>
            <param name="margin">Margin of the shape.</param>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.FaceCollisionFlag">
            <summary>
            Flag used to mark a contact as being generated by the face of a triangle in its feature id.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.MinimumDotForFaceCollision">
            <summary>
            Minimum dot product between a triangle face and the contact normal for a collision to be considered a triangle face contact.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.TestTriangle.Blocked">
            <summary>
            True if the manifold associated with this triangle has been blocked due to its detected infringement on another triangle, false otherwise.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.TestTriangle.ForceDeletionOnBlock">
            <summary>
            True if the triangle did not act as a blocker for any other manifold and so can be removed if it is blocked, false otherwise.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.TestTriangle.CorrectedNormal">
            <summary>
            Normal of a triangle detected as being infringed by the manifold associated with this triangle in mesh space.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.TryGetContactConstraintAccessor(System.Int32,BepuPhysics.CollisionDetection.ContactConstraintAccessor@)">
            <summary>
            Looks up the contact constraint accessor for the given constraint type id if it exists.
            </summary>
            <param name="constraintTypeId">Constraint type id to look up a constraint accessor for.</param>
            <param name="accessor">Accessor for the given type id.</param>
            <returns>True if the constraint type id refers to a registered accessor, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.TryExtractSolverContactData``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Tries to extract contact prestep, impulse, and body reference data from the given handle. If it's not a contact constraint, returns false.
            </summary>
            <typeparam name="TExtractor">Type of the extractor used to collect contact data from the solver.</typeparam>
            <param name="constraintHandle">Constraint to try to extract data from.</param>
            <param name="extractor">Extractor used to collect contact data from the solver.</param>
            <returns>True if the constraint was a contact type, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.TryExtractSolverContactPrestepAndImpulses``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Tries to extract prestep and impulse contact data from the given handle. If it's not a contact constraint, returns false.
            </summary>
            <typeparam name="TExtractor">Type of the extractor used to collect contact data from the solver.</typeparam>
            <param name="constraintHandle">Constraint to try to extract data from.</param>
            <param name="extractor">Extractor used to collect contact data from the solver.</param>
            <returns>True if the constraint was a contact type, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.IsContactConstraintType(System.Int32)">
            <summary>
            Gets whether a constraint type id maps to a contact constraint.
            </summary>
            <param name="constraintTypeId">Id of the constraint to check.</param>
            <returns>True if the type id refers to a contact constraint. False otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.SortCollidableReferencesForPair(BepuPhysics.Collidables.CollidableReference,BepuPhysics.Collidables.CollidableReference,BepuPhysics.Collidables.CollidableMobility@,BepuPhysics.Collidables.CollidableMobility@,BepuPhysics.Collidables.CollidableReference@,BepuPhysics.Collidables.CollidableReference@)">
            <summary>
            Sorts references to guarantee that two collidables in the same pair will always be in the same order.
            </summary>
            <param name="a">First collidable reference to sort.</param>
            <param name="b">First collidable reference to sort.</param>
            <param name="aMobility">Mobility extracted from collidable A.</param>
            <param name="bMobility">Mobility extracted from collidable B.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.NarrowPhase`1">
            <summary>
            Turns broad phase overlaps into contact manifolds and uses them to manage constraints in the solver.
            </summary>
            <typeparam name="TCallbacks">Type of the callbacks to use.</typeparam>
            <summary>
            When notified of a new constraint, immediately adds it to the solver.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NarrowPhase`1.ConstraintGeneratorType.Discrete">
            <summary>
            Pair which will directly produce constraints.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NarrowPhase`1.ConstraintGeneratorType.Continuous">
            <summary>
            Pair which samples a swept location for contacts and needs to be rewound to compute proper speculative depths in a post process.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase`1.PendingConstraintAddCache.FlushSequentially(BepuPhysics.Simulation,BepuPhysics.CollisionDetection.PairCache)">
            <summary>
            Flushes pending constraints into the simulation without any form of synchronization. Adds occur in the order of manifold generation.
            If the contact manifold generation is deterministic, then the result of this add will be deterministic.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase`1.PendingConstraintAddCache.FlushWithSpeculativeBatches(BepuPhysics.Simulation,BepuPhysics.CollisionDetection.PairCache@)">
            <summary>
            Flushes pending constraints into the simulation without any form of synchronization. Adds occur in the order of manifold generation.
            If the contact manifold generation is deterministic, then the result of this add will be deterministic.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.TwoBodyHandles">
            <summary>
            Associated with a pair of two collidables that each are controlled by bodies.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.AwakenerPhaseOne">
            <summary>
            Phase one job in the awakener. JobIndex used to identify sub-job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.SortContactConstraintType">
            <summary>
            Sorts the constraints of a single type across all workers. Used by deterministic preflushes to schedule adds.
            Accesses no buffer pools; memory is allocated and returned on main thread.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.SpeculativeConstraintBatchSearch">
            <summary>
            Identifies a first guess at the constraint batch to which every new constraint should be added to. 
            Accesses no buffer pools; memory is allocated and returned on main thread.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.DeterministicConstraintAdd">
            <summary>
            Adds constraints to the solver and constraint graph in an order determined by the previous sorts and with the help of the speculatively computed batch targets. Locally sequential.
            Accesses main thread buffer pool when type batches are created or resized.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.NondeterministicConstraintAdd">
            <summary>
            Adds constraints to the solver and constraint graph in an order determined by the collision detection phase. If the collision detection phase is nondeterministic due to threading, then 
            this will result in nondeterministic adds to the solver.
            Accesses main thread buffer pool when type batches are created or resized.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.AwakenerPhaseTwo">
            <summary>
            Phase two job in the awakener. JobIndex used to identify sub-job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.CheckFreshness">
            <summary>
            Check the freshness bytes in a region to remove stale pairs.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.Start">
            <summary>
            Start region of a CheckFreshness or SpeculativeConstraintBatchSearch job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.End">
            <summary>
            End region of a CheckFreshness or SpeculativeConstraintBatchSearch job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.TypeIndex">
            <summary>
            Narrow phase constraint type index targeted by a SpeculativeConstraintBatchSearch or SortContactConstraintType.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.WorkerIndex">
            <summary>
            Index of the worker in which a range of constraints starts. 
            Used by SpeculativeConstraintBatchSearch.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.WorkerCount">
            <summary>
            Number of worker threads containing constraints to read in the SortContactConstraintType and NondeterministicConstraintAdd tasks.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.JobIndex">
            <summary>
            Index of the job. Used by AwakenerPhaseOne and AwakenerPhaseTwo tasks.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexReductionChild.OffsetA">
            <summary>
            Offset from the origin of the first shape's parent to the child's location in world space. If there is no parent, this is the zero vector.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexReductionChild.OffsetB">
            <summary>
            Offset from the origin of the second shape's parent to the child's location in world space. If there is no parent, this is the zero vector.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.PairCacheChangeIndex">
            <summary>
            Refers to a change in a <see cref="T:BepuPhysics.CollisionDetection.PairCache"/>.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairCacheChangeIndex.WorkerIndex">
            <summary>
            Index of the <see cref="T:BepuPhysics.CollisionDetection.WorkerPendingPairChanges"/> storing the pending change, if any. If -1, then this pair cache change refers to a change directly to the mapping.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairCacheChangeIndex.Index">
            <summary>
            Index of the change in the cache. For pending changes, refers to the index within the pending cache; for a direct mapping changes, refers to the pair index.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.PairCacheChangeIndex.IsPending">
            <summary>
            Gets whether this change is in the <see cref="T:BepuPhysics.CollisionDetection.PairCache"/>
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ConstraintCache">
            <summary>
            Stores information about a contact constraint from the previous timestep.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConstraintCache.ConstraintHandle">
            <summary>
            Handle of the contact constraint associated with this cache.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConstraintCache.FeatureId0">
            <summary>
            Feature id of the first contact in the constraint associated with this cache.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConstraintCache.FeatureId1">
            <summary>
            Feature id of the second contact in the constraint associated with this cache.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConstraintCache.FeatureId2">
            <summary>
            Feature id of the third contact in the constraint associated with this cache.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConstraintCache.FeatureId3">
            <summary>
            Feature id of the fourth contact in the constraint associated with this cache.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairCache.PairFreshness">
            <summary>
            Per-pair 'freshness' flags set when a pair is added or updated by the narrow phase execution. Only initialized for the duration of the narrowphase's execution.
            </summary>
            <remarks>
            This stores one byte per pair. While it could be compressed to 1 bit, that requires manually ensuring thread safety. By using bytes, we rely on the 
            atomic setting behavior for data types no larger than the native pointer size. Further, smaller sizes actually pay a higher price in terms of increased false sharing.
            Choice of data type is a balancing act between the memory bandwidth of the post analysis and the frequency of false sharing.
            </remarks>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.PairCache.PrepareFlushJobs(BepuUtilities.Collections.QuickList{BepuPhysics.CollisionDetection.NarrowPhaseFlushJob}@)">
            <summary>
            Flush all deferred changes from the last narrow phase execution.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.PairCache.CompleteConstraintAdd``1(BepuPhysics.CollisionDetection.NarrowPhase,BepuPhysics.Solver,``0@,BepuPhysics.CollisionDetection.PairCacheChangeIndex,BepuPhysics.ConstraintHandle,BepuPhysics.CollisionDetection.CollidablePair@)">
            <summary>
            Completes the addition of a constraint by filling in the narrowphase's pointer to the constraint and by distributing accumulated impulses.
            </summary>
            <typeparam name="TContactImpulses">Count-specialized type containing cached accumulated impulses.</typeparam>
            <param name="narrowPhase">Narrow phase that triggered the constraint add.</param>
            <param name="solver">Solver containing the constraint to set the impulses of.</param>
            <param name="impulses">Warm starting impulses to apply to the contact constraint.</param>
            <param name="pairCacheChangeIndex">Index of the change associated with this constraint in the <see cref="T:BepuPhysics.CollisionDetection.PairCache"/>.</param>
            <param name="constraintHandle">Constraint handle associated with the constraint cache being updated.</param>
            <param name="pair">Collidable pair associated with the new constraint.</param>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairCache.ConstraintHandleToPair">
            <summary>
            Mapping from constraint handle back to collision detection pair cache locations.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1">
            <summary>
            Helps test the broad phase's active and static trees with a custom leaf tester.
            </summary>
            <typeparam name="TRayTester">Type used to test rays against leaves.</typeparam>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.#ctor(BepuUtilities.Memory.BufferPool,BepuPhysics.CollisionDetection.BroadPhase,`0,System.Int32)">
            <summary>
            Constructs a ray batcher for the broad phase and initializes its backing resources.
            </summary>
            <param name="pool">Pool to pull resources from.</param>
            <param name="broadPhase">Broad phase to be tested.</param>
            <param name="rayTester">Ray tester used to test leaves found by the broad phase tree traversals.</param>
            <param name="batcherRayCapacity">Maximum number of rays to execute in each traversal.
            This should typically be chosen as the highest value which avoids spilling data out of L2 cache.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.Add(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,System.Int32)">
            <summary>
            Adds a ray to the batcher to test against the broad phase trees.
            If the underlying ray batcher hits its maximum capacity, all the accumulated rays will be tested against the broad phase trees and the accumulator will be reset.
            </summary>
            <param name="origin">Origin of the ray to test against the tree.</param>
            <param name="direction">Direction of the ray to test against the tree.</param>
            <param name="maximumT">Maximum distance that the ray will travel in units of the ray's length.</param>
            <param name="id">Identifier value for the ray. Leaf tests will have access to the id.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.Flush">
            <summary>
            Tests any accumulated rays against the broad phase trees and then resets the batcher.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.Dispose">
            <summary>
            Disposes the underlying batcher resources.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.SimulationRayBatcher`1">
            <summary>
            Tests batches of rays against the simulation.
            </summary>
            <typeparam name="TRayHitHandler">Type used to handle hits against objects in the simulation.</typeparam>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.SimulationRayBatcher`1.Add(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,System.Int32)">
            <summary>
            Adds a ray to the batcher to test against the simulation.
            If the underlying ray batcher hits its maximum capacity, all the accumulated rays will be tested against the simulation and the accumulator will be reset.
            </summary>
            <param name="origin">Origin of the ray to test against the simulation.</param>
            <param name="direction">Direction of the ray to test against the simulation.</param>
            <param name="maximumT">Maximum distance that the ray will travel in units of the ray's length.</param>
            <param name="id">Identifier value for the ray. Callbacks will have access to the id.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.SimulationRayBatcher`1.Flush">
            <summary>
            Tests any accumulated rays against the broad phase trees and then resets the batcher.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ISweepFilter.AllowTest(System.Int32,System.Int32)">
            <summary>
            Checks whether a swept test should be performed for children of swept shapes.
            </summary>
            <param name="childA">Index of the child belonging to collidable A.</param>
            <param name="childB">Index of the child belonging to collidable B.</param>
            <returns>True if testing should proceed, false otherwise.</returns>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.SweepTask.ShapeTypeIndexA">
            <summary>
            Gets the first shape type index associated with the task.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.SweepTask.ShapeTypeIndexB">
            <summary>
            Gets the second shape type index associated with the task.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.UntypedList.Allocate(System.Int32,System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Allocates an element in the list, initializing the backing buffer if needed.
            </summary>
            <param name="elementSizeInBytes">Number of bytes per element.</param>
            <param name="minimumElementCount">Minimum size of the backing buffer to create if this is a new allocation.</param>
            <param name="pool">Pool to pull allocations from.</param>
            <returns>Index of the element in bytes within the list's buffer.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.WideRayTester">
            <summary>
            Helper class for creating runtime specialized vectorized ray intersection tests with shapes that support broadcasting.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.WorkerPendingPairChanges">
            <summary>
            Contains the pending pair cache changes created by a single worker during the last execution of narrow phase pair processing.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.WorkerPendingPairChanges.PendingAdds">
            <summary>
            The set of pair-pointer associations created by this worker that should be added to the pair mapping.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.WorkerPendingPairChanges.PendingRemoves">
            <summary>
            The set of pairs to remove from the pair cache generated by the worker.
            </summary>
        </member>
        <member name="T:BepuPhysics.ConstraintBatch">
            <summary>
            Contains a set of type batches whose constraints share no body references.
            </summary>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.GetTypeBatch(System.Int32)">
            <summary>
            Gets a type batch in the batch matching the given type id.
            Requires that there exists at least one constraint in the type batch.
            </summary>
            <param name="typeId">Id of the TypeBatch's type to retrieve.</param>
            <returns>TypeBatch instance associated with the given type.</returns>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.GetTypeBatchPointer(System.Int32)">
            <summary>
            Gets a pointer to the type batch in the batch matching the given type id.
            Requires that there exists at least one constraint in the type batch.
            </summary>
            <param name="typeId">Id of the TypeBatch's type to retrieve.</param>
            <returns>TypeBatch instance associated with the given type.</returns>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.EnsureTypeBatchCapacities(BepuPhysics.Solver)">
            <summary>
            Ensures that all type batches within this constraint batch meet or exceed the size requirements of the per-type capacities defined by the solver.
            </summary>
            <param name="solver">Solver to pull minimum capacities from.</param>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.ResizeTypeBatchCapacities(BepuPhysics.Solver)">
            <summary>
            Applies the solver-defined minimum capacities to existing type batches.
            </summary>
            <param name="solver">Solver to pull minimum capacities from.</param>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Releases all memory used by the batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.ConstraintLocation">
            <summary>
            Location in memory where a constraint is stored.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLocation.SetIndex">
            <summary>
            Index of the constraint set that owns the constraint. If zero, the constraint is attached to bodies that are awake.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLocation.BatchIndex">
            <summary>
            Index of the constraint batch the constraint belongs to.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLocation.TypeId">
            <summary>
            Type id of the constraint. Used to look up the type batch index in a constraint batch's type id to type batch index table.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLocation.IndexInTypeBatch">
            <summary>
            Index of the constraint in a type batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.ConstraintReference">
            <summary>
            Reference to a constraint's memory location in the solver.
            </summary>
        </member>
        <member name="P:BepuPhysics.ConstraintReference.TypeBatch">
            <summary>
            Gets a reference to the type batch holding the constraint.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintReference.IndexInTypeBatch">
            <summary>
            Index in the type batch where the constraint is allocated.
            </summary>
        </member>
        <member name="M:BepuPhysics.ConstraintReference.#ctor(BepuPhysics.Constraints.TypeBatch*,System.Int32)">
            <summary>
            Creates a new constraint reference from a constraint memory location.
            </summary>
            <param name="typeBatchPointer">Pointer to the type batch where the constraint lives.</param>
            <param name="indexInTypeBatch">Index in the type batch where the constraint is allocated.</param>
        </member>
        <member name="P:BepuPhysics.ConstraintSet.BundleCount">
            <summary>
            Gets the total number of bundles across all types and batches.
            </summary>
        </member>
        <member name="P:BepuPhysics.ConstraintSet.ConstraintCount">
            <summary>
            Gets the total number of bundles across all types and batches.
            </summary>
        </member>
        <member name="P:BepuPhysics.ConstraintSet.Allocated">
            <summary>
            Gets whether this constraint set is allocated. 
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularAxisGearMotor">
            <summary>
            Constrains body B's angular velocity around an axis anchored to body A to equal body A's velocity around that axis with a scaling factor applied.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisGearMotor.LocalAxisA">
            <summary>
            Axis of rotation in body A's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisGearMotor.VelocityScale">
            <summary>
            <para>Scale to apply to body A's velocity around the axis to get body B's target velocity.</para>
            <para>In other words, a VelocityScale of 2 means that body A could have a velocity of 3 while body B has a velocity of 6.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisGearMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularAxisMotor">
            <summary>
            Constrains the relative angular velocity of two bodies around a local axis attached to body A to a target velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisMotor.LocalAxisA">
            <summary>
            Axis of rotation in body A's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisMotor.TargetVelocity">
            <summary>
            Target relative angular velocity around the axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularHinge">
            <summary>
            Angular component of a hinge. Constrains the angular degrees of freedom of two bodies such that they can only rotate relative to each other around the hinge's axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularHinge.LocalHingeAxisA">
            <summary>
            Hinge axis in the local space of A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularHinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularHinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularMotor">
            <summary>
            Constrains the relative angular velocity between two bodies to a target.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularMotor.TargetVelocityLocalA">
            <summary>
            Target relative angular velocity between A and B, stored in A's local space. Target world space angular velocity of B is AngularVelocityA + TargetVelocityLocalA * OrientationA.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularServo">
            <summary>
            Constrains two bodies to have a target relative rotation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularServo.TargetRelativeRotationLocalA">
            <summary>
            The target relative rotation from body A to body B in body A's local space. The constraint tries to maintain OrientationB = TargetRelativeRotationLocalA * OrientationA.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularSwivelHinge">
            <summary>
            Constrains two bodies with the angular component of a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularSwivelHinge.LocalSwivelAxisA">
            <summary>
            Swivel axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularSwivelHinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of body B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularSwivelHinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AreaConstraint">
            <summary>
            Constrains the area of a triangle connecting the centers of three bodies to match a goal area. 
            Scaled volume computed from ||ab x ac||.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AreaConstraint.TargetScaledArea">
            <summary>
            2 times the target area of the triangle. Computed from ||ab x ac||.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AreaConstraint.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.AreaConstraint.#ctor(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,BepuPhysics.Constraints.SpringSettings)">
            <summary>
            Creates a new area constraint, initializing the target area using a set of initial positions.
            </summary>
            <param name="a">Initial position of the first body.</param>
            <param name="b">Initial position of the second body.</param>
            <param name="c">Initial position of the third body.</param>
            <param name="springSettings">Spring settings to apply to the volume constraint.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.AreaConstraintTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of area constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocket">
            <summary>
            Constrains a point on one body to a point on another body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocket.LocalOffsetA">
            <summary>
            Offset from the center of body A to its attachment in A's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocket.LocalOffsetB">
            <summary>
            Offset from the center of body B to its attachment in B's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocket.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketMotor">
            <summary>
            Controls the relative linear velocity from the center of body A to an attachment point on body B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketMotor.LocalOffsetB">
            <summary>
            Offset from body B to its attachment in B's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketMotor.TargetVelocityLocalA">
            <summary>
            Target relative linear velocity between A and B, stored in A's local space. Target world space linear velocity of B is LinearVelocityA + TargetVelocityLocalA * OrientationA.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketMotorTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket motor constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketServo">
            <summary>
            Constrains a point on one body to a point on another body.
            Provides speed and force configuration that the BallSocket joint does not.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.LocalOffsetA">
            <summary>
            Offset from the center of body A to its attachment in A's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.LocalOffsetB">
            <summary>
            Offset from the center of body B to its attachment in B's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketServoTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket servo constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketShared">
            <summary>
            Provides shared functionality for constraints with jacobians similar to the BallSocket.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.CenterDistanceConstraint">
            <summary>
            Constrains the center of two bodies to be separated by a goal distance.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.CenterDistanceConstraint.TargetDistance">
            <summary>
            Target distance between the body centers.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.CenterDistanceConstraint.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.CenterDistanceTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of distance servos.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.CenterDistanceLimit">
            <summary>
            Constrains the center of two bodies to be separated by a distance within a range.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.CenterDistanceLimit.MinimumDistance">
            <summary>
            Minimum distance between the body centers.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.CenterDistanceLimit.MaximumDistance">
            <summary>
            Maximum distance between the body centers.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.CenterDistanceLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.CenterDistanceLimitTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of distance servos.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsFiniteNumber(System.Single)">
            <summary>
            Checks if a value is a finite number- neither infinite nor NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is neither infinite nor NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsPositiveNumber(System.Single)">
            <summary>
            Checks if a value is a finite value greater than zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number greater than zero and not NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsNonnegativeNumber(System.Single)">
            <summary>
            Checks if a value is a finite value greater than or equal to zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number greater than or equal to zero and not NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsNegativeNumber(System.Single)">
            <summary>
            Checks if a value is a finite value less than zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number less than zero and not NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsNonpositiveNumber(System.Single)">
            <summary>
            Checks if a value is a finite value less than or equal to zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number less than or equal to zero and not NaN, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact1OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 1-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact1TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 1-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2NonconvexTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact nonconvex two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2NonconvexOneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact nonconvex one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3NonconvexTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact nonconvex two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3NonconvexOneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact nonconvex one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4NonconvexTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact nonconvex two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4NonconvexOneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact nonconvex one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor">
            <summary>
            Callbacks for direct references to the solver's contact constraint data.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.ConvexOneBody``2(BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a convex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandle">Body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.ConvexTwoBody``2(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a convex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandleA">First body handle referenced by the constraint.</param>
            <param name="bodyHandleB">Second body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.NonconvexOneBody``2(BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandle">Body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.NonconvexTwoBody``2(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandleA">First body handle referenced by the constraint.</param>
            <param name="bodyHandleB">Second body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor">
            <summary>
            Callbacks for direct references to the solver's contact constraint data. Includes only prestep and impulse data.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.ConvexOneBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a convex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.ConvexTwoBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a convex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.NonconvexOneBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.NonconvexTwoBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TangentFriction">
            <summary>
            Handles the tangent friction implementation.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TangentFriction.ApplyImpulse(BepuPhysics.Constraints.Contact.TangentFriction.Jacobians@,BepuPhysics.BodyInertiaWide@,BepuPhysics.BodyInertiaWide@,BepuUtilities.Vector2Wide@,BepuPhysics.BodyVelocityWide@,BepuPhysics.BodyVelocityWide@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TangentFrictionOneBody">
            <summary>
            Handles the tangent friction implementation for one body contact constraints.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TangentFrictionOneBody.ApplyImpulse(BepuPhysics.Constraints.Contact.TangentFrictionOneBody.Jacobians@,BepuPhysics.BodyInertiaWide@,BepuUtilities.Vector2Wide@,BepuPhysics.BodyVelocityWide@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TwistFriction">
            <summary>
            Handles the tangent friction implementation.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TwistFriction.ApplyImpulse(BepuUtilities.Vector3Wide@,BepuPhysics.BodyInertiaWide@,BepuPhysics.BodyInertiaWide@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocityWide@,BepuPhysics.BodyVelocityWide@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TwistFrictionOneBody">
            <summary>
            Handles the tangent friction implementation.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TwistFrictionOneBody.ApplyImpulse(BepuUtilities.Vector3Wide@,BepuPhysics.BodyInertiaWide@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocityWide@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceLimit">
            <summary>
            Constrains points on two bodies to be separated by a distance within a range.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.MinimumDistance">
            <summary>
            Minimum distance permitted between the point on A and the point on B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.MaximumDistance">
            <summary>
            Maximum distance permitted between the point on A and the point on B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.DistanceLimit.#ctor(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,System.Single,BepuPhysics.Constraints.SpringSettings@)">
            <summary>
            Creates a distance limit description.
            </summary>
            <param name="localOffsetA">Local offset from the center of body A to its attachment point.</param>
            <param name="localOffsetB">Local offset from the center of body B to its attachment point.</param>
            <param name="minimumDistance">Minimum distance permitted between the point on A and the point on B.</param>
            <param name="maximumDistance">Maximum distance permitted between the point on A and the point on B.</param>
            <param name="springSettings">Spring frequency and damping parameters.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceLimitTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of distance servos.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceServo">
            <summary>
            Constrains points on two bodies to be separated by a goal distance.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.TargetDistance">
            <summary>
            Distance that the constraint will try to reach between the attachment points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.DistanceServo.#ctor(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,BepuPhysics.Constraints.SpringSettings@,BepuPhysics.Constraints.ServoSettings@)">
            <summary>
            Creates a distance servo description.
            </summary>
            <param name="localOffsetA">Local offset from the center of body A to its attachment point.</param>
            <param name="localOffsetB">Local offset from the center of body B to its attachment point.</param>
            <param name="targetDistance">Distance that the constraint will try to reach between the attachment points.</param>
            <param name="springSettings">Spring frequency and damping parameters.</param>
            <param name="servoSettings">Servo control parameters.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceServoTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of distance servos.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.FourBodyReferences">
            <summary>
            A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IFourBodyConstraintFunctions`2">
            <summary>
            Prestep, warm start and solve iteration functions for a four body constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
        </member>
        <member name="P:BepuPhysics.Constraints.IFourBodyConstraintFunctions`2.RequiresIncrementalSubstepUpdates">
            <summary>
            Gets whether this constraint type requires incremental updates for each substep taken beyond the first.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.FourBodyTypeProcessor`11">
            <summary>
            Shared implementation across all four body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Hinge">
            <summary>
            Constrains two bodies with a hinge. Equivalent to a BallSocket constraint and an AngularHinge constraint solved together.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalHingeAxisA">
            <summary>
            Hinge axis in the local space of A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IBatchIntegrationMode">
            <summary>
            Marks a type as determining the integration mode for a solver batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BatchShouldAlwaysIntegrate">
            <summary>
            The batch was determined to have only constraints with integration responsibilities, so there's no need to check.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BatchShouldNeverIntegrate">
            <summary>
            The batch was determined to have no constraints with integration responsibilities, so there's no need to check.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BatchShouldConditionallyIntegrate">
            <summary>
            The batch was determined to have some constraints with integration responsibilities.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IBatchPoseIntegrationAllowed">
            <summary>
            Marks a type as determining whether pose integration should be performed on bodies within the constraint batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AllowPoseIntegration">
            <summary>
            Marks a batch as integrating poses for any bodies with integration responsibility within the constraint batch.
            Constraints which need to be updated in response to pose integration will also have their UpdateForNewPose function called.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.DisallowPoseIntegration">
            <summary>
            Marks a batch as not integrating poses for any bodies within the constraint batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IBodyAccessFilter">
            <summary>
            Constrains which body properties should be accessed in a body during constraint data gathering/scattering.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IBodyAccessFilter.GatherPosition">
            <summary>
            Gets whether position is loaded by the constraint.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IBodyAccessFilter.GatherOrientation">
            <summary>
            Gets whether orientation is loaded by the constraint.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IBodyAccessFilter.GatherMass">
            <summary>
            Gets whether body mass is loaded by this constraint.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IBodyAccessFilter.GatherInertiaTensor">
            <summary>
            Gets whether body inertia tensor is loaded by this constraint.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IBodyAccessFilter.AccessLinearVelocity">
            <summary>
            Gets whether to load or store body linear velocity in this constraint.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IBodyAccessFilter.AccessAngularVelocity">
            <summary>
            Gets whether to load or store body linear velocity in this constraint.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AccessAll">
            <summary>
            Marks all body properties as necessary for gather/scatter.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AccessNoInertia">
            <summary>
            Used for kinematic integration; the inertias are known ahead of time and there's no reason to gather them.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IConstraintDescription`1">
            <summary>
            Marks a type as a description of a constraint associated with a particular batch.
            </summary>
            <remarks>
            Note that one batch may have multiple description types associated with it, each one potentially offering a different subset of properties or translation logic.
            </remarks>
            <typeparam name="TDescription">Type of the description object.</typeparam>
        </member>
        <member name="M:BepuPhysics.Constraints.IConstraintDescription`1.ApplyDescription(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32)">
            <summary>
            Changes the batch-held memory at a given location to match the given description.
            </summary>
            <param name="batch">Batch to modify.</param>
            <param name="bundleIndex">Index of the target constraint's bundle.</param>
            <param name="innerIndex">Index of the target constraint within its bundle.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.IConstraintDescription`1.BuildDescription(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,`0@)">
            <summary>
            Creates a description from the batch-held memory at a given location.
            </summary>
            <param name="batch">Batch to read.</param>
            <param name="bundleIndex">Index of the source constraint's bundle.</param>
            <param name="innerIndex">Index of the source constraint within its bundle.</param>
            <param name="description">Description of the constraint.</param>
        </member>
        <member name="P:BepuPhysics.Constraints.IConstraintDescription`1.ConstraintTypeId">
            <summary>
            Gets the type id of the constraint that this is a description of.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IConstraintDescription`1.TypeProcessorType">
            <summary>
            Gets the type of the type batch which contains described constraints.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.IConstraintDescription`1.CreateTypeProcessor">
            <summary>
            Creates a type processor for this constraint type.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IOneBodyConstraintDescription`1">
            <summary>
            Marks a type as a one body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="T:BepuPhysics.Constraints.ITwoBodyConstraintDescription`1">
            <summary>
            Marks a type as a two body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="T:BepuPhysics.Constraints.IThreeBodyConstraintDescription`1">
            <summary>
            Marks a type as a three body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="T:BepuPhysics.Constraints.IFourBodyConstraintDescription`1">
            <summary>
            Marks a type as a four body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="M:BepuPhysics.Constraints.Inequality2Body1DOF.ApplyImpulse(BepuPhysics.Constraints.Projection2Body1DOF@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocityWide@,BepuPhysics.BodyVelocityWide@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.LinearAxisLimit">
            <summary>
            Constrains points on two bodies to a range of offsets from each other along a direction anchored to body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.LocalAxis">
            <summary>
            Direction of the motorized axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.MinimumOffset">
            <summary>
            Minimum offset along the world axis between A and B's anchor points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.MaximumOffset">
            <summary>
            Maximum offset along the world axis between A and B's anchor points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.LinearAxisMotor">
            <summary>
            Constrains points on two bodies to move relative to each other along a direction.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.LocalAxis">
            <summary>
            Direction of the motorized axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.TargetVelocity">
            <summary>
            Target relative velocity along the world axis between A and B's anchor points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.LinearAxisServo">
            <summary>
            Constrains points on two bodies to be on a plane defined in the local space of one of the bodies.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.LocalPlaneNormal">
            <summary>
            Direction of the plane normal in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.TargetOffset">
            <summary>
            Target offset from A's plane anchor to B's anchor along the plane normal.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.MotorSettings">
            <summary>
            Defines some of the shared behavior across motor constraints.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.MotorSettings.MaximumForce">
            <summary>
            Maximum amount of force the motor can apply in one unit of time.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.MotorSettings.Damping">
            <summary>
            Mass-scaled damping constant. If you want to simulate a viscous damping coefficient of D with an object of mass M, set this damping value to D / M.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.MotorSettings.Softness">
            <summary>
            Gets or sets how soft the constraint is. Values range from 0 to infinity. Softness is inverse damping; 0 is perfectly rigid, 1 is very soft, float.MaxValue is effectively nonexistent.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.MotorSettings.Validate(BepuPhysics.Constraints.MotorSettings@)">
            <summary>
            Checks if a settings instance has valid nonnegative values.
            </summary>
            <param name="settings">Instance to examine.</param>
            <returns>True if the settings are valid, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.MotorSettings.#ctor(System.Single,System.Single)">
            <summary>
            Defines settings for a motor constraint.
            </summary>
            <param name="maximumForce">Maximum amount of force the motor can apply in one unit of time.</param>
            <param name="softness">Gets or sets how soft the constraint is. Values range from 0 to infinity. Softness is inverse damping; 0 is perfectly rigid, 1 is very soft, float.MaxValue is effectively nonexistent.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyAngularMotor">
            <summary>
            Constrains the angular velocity of one body to the target.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularMotor.TargetVelocity">
            <summary>
            Target angular velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyAngularServo">
            <summary>
            Constrains a single body to a target orientation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularServo.TargetOrientation">
            <summary>
            Target orientation of the constraint.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyLinearMotor">
            <summary>
            Constrains a point on a body to have a target linear velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearMotor.LocalOffset">
            <summary>
            Offset to the attachment point in the local space of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearMotor.TargetVelocity">
            <summary>
            Target velocity of the attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyLinearServo">
            <summary>
            Constrains a point on a body to a target location.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.LocalOffset">
            <summary>
            Offset to the attachment point in the local space of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.Target">
            <summary>
            Target position.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IOneBodyConstraintFunctions`2">
            <summary>
            Prestep, warm start and solve iteration functions for a constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
        </member>
        <member name="P:BepuPhysics.Constraints.IOneBodyConstraintFunctions`2.RequiresIncrementalSubstepUpdates">
            <summary>
            Gets whether this constraint type requires incremental updates for each substep taken beyond the first.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyTypeProcessor`5">
            <summary>
            Shared implementation across all one body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.PointOnLineServo">
            <summary>
            Constrains a point on body B to be on a line attached to body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.LocalDirection">
            <summary>
            Direction of the line in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.ServoSettings.Default">
            <summary>
            Gets settings representing a servo with unlimited force, speed, and no base speed.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.ServoSettings.Validate(BepuPhysics.Constraints.ServoSettings@)">
            <summary>
            Checks servo settings to ensure valid values.
            </summary>
            <param name="settings">Settings to check.</param>
            <returns>True if the settings contain valid values, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.SpringSettingsWide.ComputeSpringiness(BepuPhysics.Constraints.SpringSettingsWide@,System.Single,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes springiness values for a set of constraints.
            </summary>
            <param name="settings">Spring settings associated with the constraints.</param>
            <param name="dt">Duration of the time step.</param>
            <param name="positionErrorToVelocity">The multiplier applied to error to get bias velocity.</param>
            <param name="effectiveMassCFMScale">Scaling factor to apply to the effective mass to get the softened effective mass.</param>
            <param name="softnessImpulseScale">Scaling factor to apply to the accumulated impulse during the solve to soften the target velocity.</param>
        </member>
        <member name="F:BepuPhysics.Constraints.SpringSettings.AngularFrequency">
            <summary>
            Target number of undamped oscillations per unit of time, scaled by 2 * PI.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SpringSettings.TwiceDampingRatio">
            <summary>
            Twice the ratio of the spring's actual damping to its critical damping.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.SpringSettings.Frequency">
            <summary>
            Gets or sets the target number of undamped oscillations per unit of time.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.SpringSettings.DampingRatio">
            <summary>
            Gets or sets the ratio of the spring's actual damping to its critical damping. 0 is undamped, 1 is critically damped, and higher values are overdamped.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.SpringSettings.Validate(BepuPhysics.Constraints.SpringSettings@)">
            <summary>
            Checks if a spring settings instance contains valid values.
            </summary>
            <param name="springSettings">Settings to check.</param>
            <returns>True if the spring settings are valid, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.SpringSettings.#ctor(System.Single,System.Single)">
            <summary>
            Constructs a new spring settings instance.
            </summary>
            <param name="frequency">Target number of undamped oscillations per unit of time.</param>
            <param name="dampingRatio">Ratio of the spring's actual damping to its critical damping. 0 is undamped, 1 is critically damped, and higher values are overdamped.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.SwingLimit">
            <summary>
            Restricts axes attached to two bodies to fall within a maximum swing angle.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.AxisLocalA">
            <summary>
            Axis attached to body A in its local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.AxisLocalB">
            <summary>
            Axis attached to body B in its local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.MinimumDot">
            <summary>
            Minimum dot product between the world space A and B axes that the constraint attempts to maintain.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.SwingLimit.MaximumSwingAngle">
            <summary>
            Gets or sets the maximum swing angle that the constraint allows between world axis A and B. Based on the MinimumDot field.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.SwivelHinge">
            <summary>
            Constrains two bodies with a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen. Equivalent to a BallSocket constraint and an AngularSwivelHinge constraint solved together.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalSwivelAxisA">
            <summary>
            Swivel axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of body B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.ThreeBodyReferences">
            <summary>
            A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IThreeBodyConstraintFunctions`2">
            <summary>
            Prestep, warm start and solve iteration functions for a three body constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
        </member>
        <member name="P:BepuPhysics.Constraints.IThreeBodyConstraintFunctions`2.RequiresIncrementalSubstepUpdates">
            <summary>
            Gets whether this constraint type requires incremental updates for each substep taken beyond the first.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.ThreeBodyTypeProcessor`9">
            <summary>
            Shared implementation across all three body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwistLimit">
            <summary>
            Constrains two bodies' rotations around attached twist axes to a range of permitted twist angles.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.LocalBasisA">
            <summary>
            Local space basis attached to body A against which to measure body B's transformed axis. Expressed as a 3x3 rotation matrix, the X axis corresponds with 0 degrees, 
            the Y axis corresponds to 90 degrees, and the Z axis is the twist axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.LocalBasisB">
            <summary>
            Local space basis attached to body B that will be measured against body A's basis.
            Expressed as a 3x3 rotation matrix, the transformed X axis will be measured against A's X and Y axes. The Z axis is the twist axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.MinimumAngle">
            <summary>
            Minimum angle between B's axis to measure and A's measurement axis. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.MaximumAngle">
            <summary>
            Maximum angle between B's axis to measure and A's measurement axis. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwistMotor">
            <summary>
            Constrains the twist velocity between two bodies to a target.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.LocalAxisA">
            <summary>
            Local twist axis attached to body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.LocalAxisB">
            <summary>
            Local twist axis attached to body B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.TargetVelocity">
            <summary>
            Goal relative twist velocity around the body axes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwistServo">
            <summary>
            Constrains two bodies to maintain a target twist angle around body-attached axes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.LocalBasisA">
            <summary>
            Local space basis attached to body A against which to measure body B's transformed axis. Expressed as a 3x3 rotation matrix, the X axis corresponds with 0 degrees, 
            the Y axis corresponds to 90 degrees, and the -Z axis is the twist axis. When viewed along the twist axis, positive change in angle causes counterclockwise rotation in right handed coordinates.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.LocalBasisB">
            <summary>
            Local space basis attached to body B that will be measured against body A's basis.
            Expressed as a 3x3 rotation matrix, the transformed X axis will be measured against A's X and Y axes. The Z axis is the twist axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.TargetAngle">
            <summary>
            Target angle between B's axis to measure and A's measurement axis. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwoBodyReferences">
            <summary>
            A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve.
            Two address streams isn't much of a problem for prefetching.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.ITwoBodyConstraintFunctions`2">
            <summary>
            Prestep, warm start and solve iteration functions for a two body constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
        </member>
        <member name="P:BepuPhysics.Constraints.ITwoBodyConstraintFunctions`2.RequiresIncrementalSubstepUpdates">
            <summary>
            Gets whether this constraint type requires incremental updates for each substep taken beyond the first.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwoBodyTypeProcessor`7">
            <summary>
            Shared implementation across all two body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TypeBatch">
            <summary>
            Stores the raw AOSOA formatted data associated with constraints in a type batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TypeProcessor">
            <summary>
            Superclass of constraint type batch processors. Responsible for interpreting raw type batches for the purposes of bookkeeping and solving.
            </summary>
            <remarks>
            <para>This class holds no actual state of its own. A solver creates a unique type processor for each registered constraint type, and all instances are held in untyped memory.
            Splitting the functionality from the data allows for far fewer GC-tracked instances and allows the raw data layout to be shared more easily.</para>
            <para>For example, sleeping simulation islands store type batches, but they are created and used differently- and for convenience, they are stored on a per-island basis.
            Using the same system but with reference type TypeBatches, tens of thousands of inactive islands would imply tens of thousands of GC-tracked objects.</para>
            That's not acceptable, so here we are. 
            <para>Conceptually, you can think of the solver's array of TypeProcessors like C function pointers.</para>
            </remarks>
        </member>
        <member name="P:BepuPhysics.Constraints.TypeProcessor.BodiesPerConstraint">
            <summary>
            Gets the number of bodies associated with each constraint in this type processor.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.TypeProcessor.ConstrainedDegreesOfFreedom">
            <summary>
            Gets the number of degrees of freedom that each constraint in this type processor constrains. Equal to the number of entries in the accumulated impulses.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor.AllocateInTypeBatch(BepuPhysics.Constraints.TypeBatch@,BepuPhysics.ConstraintHandle,System.Span{System.Int32},BepuUtilities.Memory.BufferPool)">
            <summary>
            Allocates a slot in the batch, assuming the batch is not a fallback batch.
            </summary>
            <param name="typeBatch">Type batch to allocate in.</param>
            <param name="handle">Handle of the constraint to allocate. Establishes a link from the allocated constraint to its handle.</param>
            <param name="encodedBodyIndices">List of body indices (not handles!) with count equal to the type batch's expected number of involved bodies.</param>
            <param name="pool">Allocation provider to use if the type batch has to be resized.</param>
            <returns>Index of the slot in the batch.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor.AllocateInTypeBatchForFallback(BepuPhysics.Constraints.TypeBatch@,BepuPhysics.ConstraintHandle,System.Span{System.Int32},BepuUtilities.Memory.BufferPool)">
            <summary>
            Allocates a slot in the batch, assuming the batch is a fallback batch.
            </summary>
            <param name="typeBatch">Type batch to allocate in.</param>
            <param name="handle">Handle of the constraint to allocate. Establishes a link from the allocated constraint to its handle.</param>
            <param name="encodedBodyIndices">List of body indices (not handles!) with count equal to the type batch's expected number of involved bodies.</param>
            <param name="pool">Allocation provider to use if the type batch has to be resized.</param>
            <returns>Index of the slot in the batch.</returns>
        </member>
        <member name="T:BepuPhysics.Constraints.TypeProcessor.ActiveKinematicFlaggedBodyHandleCollector">
            <summary>
            Collects body references from active constraints and converts them into properly flagged constraint kinematic body handles.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor.TransferConstraint(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,BepuPhysics.Solver,BepuPhysics.Bodies,System.Int32)">
            <summary>
            Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type.
            </summary>
            <param name="sourceTypeBatch">Source type batch to transfer the constraint out of.</param>
            <param name="sourceBatchIndex">Index of the batch that owns the type batch that is the source of the constraint transfer.</param>
            <param name="indexInTypeBatch">Index of the constraint to move in the current type batch.</param>
            <param name="solver">Solver that owns the batches.</param>
            <param name="bodies">Bodies set that owns all the constraint's bodies.</param>
            <param name="targetBatchIndex">Index of the ConstraintBatch in the solver to copy the constraint into.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor.TransferConstraint(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,BepuPhysics.Solver,BepuPhysics.Bodies,System.Int32,System.Span{BepuPhysics.BodyHandle},System.Span{System.Int32})">
            <summary>
            Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type.
            </summary>
            <param name="sourceTypeBatch">Source type batch to transfer the constraint out of.</param>
            <param name="sourceBatchIndex">Index of the batch that owns the type batch that is the source of the constraint transfer.</param>
            <param name="indexInTypeBatch">Index of the constraint to move in the current type batch.</param>
            <param name="solver">Solver that owns the batches.</param>
            <param name="bodies">Bodies set that owns all the constraint's bodies.</param>
            <param name="targetBatchIndex">Index of the ConstraintBatch in the solver to copy the constraint into.</param>
            <param name="dynamicBodyHandles">Set of body handles in the constraint referring to dynamic bodies.</param>
            <param name="encodedBodyIndices">Set of encoded body indices to use in the new constraint allocation.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor.UpdateForBodyMemoryMove(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Updates a type batch's body index references for the movement of a body in memory.
            </summary>
            <param name="typeBatch">Type batch containing a constraint that references the body.</param>
            <param name="indexInTypeBatch">Index of the constraint in the type batch.</param>
            <param name="bodyIndexInConstraint">Index within the constraint of the body.</param>
            <param name="newBodyLocation">New index of the body in the bodies active set.</param>
            <returns>True if the body being moved was kinematic according to the constraint's reference.</returns>
        </member>
        <member name="P:BepuPhysics.Constraints.TypeProcessor.RequiresIncrementalSubstepUpdates">
            <summary>
            Gets whether this type requires incremental updates for each substep in a frame beyond the first.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.ISortKeyGenerator`1">
            <summary>
            Defines a function that creates a sort key from body references in a type batch. Used by constraint layout optimization.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor`3.Move(`0@,`1@,`2@,BepuPhysics.ConstraintHandle,System.Int32,`0@,`1@,`2@,BepuPhysics.ConstraintHandle@,System.Int32,System.Int32,BepuUtilities.Memory.Buffer{BepuPhysics.ConstraintLocation}@)">
            <summary>
            Overwrites all the data in the target constraint slot with source data.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor`3.Remove(BepuPhysics.Constraints.TypeBatch@,System.Int32,BepuUtilities.Memory.Buffer{BepuPhysics.ConstraintLocation}@,System.Boolean)">
            <summary>
            Removes a constraint from the batch.
            </summary>
            <param name="typeBatch">Type batch to remove a constraint from.</param>
            <param name="index">Index of the constraint to remove.</param>
            <param name="handlesToConstraints">The handle to constraint mapping used by the solver that could be modified by a swap on removal.</param>
            <param name="isFallback">True if the type batch being removed from belongs to the fallback batch, false otherwise.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor`3.TransferConstraint(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,BepuPhysics.Solver,BepuPhysics.Bodies,System.Int32,System.Span{BepuPhysics.BodyHandle},System.Span{System.Int32})">
            <summary>
            Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type.
            </summary>
            <param name="sourceTypeBatch">Source type batch to transfer the constraint out of.</param>
            <param name="sourceBatchIndex">Index of the batch that owns the type batch that is the source of the constraint transfer.</param>
            <param name="indexInTypeBatch">Index of the constraint to move in the current type batch.</param>
            <param name="solver">Solver that owns the batches.</param>
            <param name="bodies">Bodies set that owns all the constraint's bodies.</param>
            <param name="targetBatchIndex">Index of the ConstraintBatch in the solver to copy the constraint into.</param>
            <param name="dynamicBodyHandles">Set of body handles in the constraint referring to dynamic bodies.</param>
            <param name="encodedBodyIndices">Set of encoded body indices to use in the new constraint allocation.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.VolumeConstraint">
            <summary>
            Constrains the volume of a tetrahedron connecting the centers of four bodies to match a goal volume. 
            Scaled volume computed from (ab x ac) * ad; the volume may be negative depending on the winding of the tetrahedron.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.VolumeConstraint.TargetScaledVolume">
            <summary>
            6 times the target volume of the tetrahedra. Computed from (ab x ac) * ad; this may be negative depending on the winding of the tetrahedron.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.VolumeConstraint.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.VolumeConstraint.#ctor(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,BepuPhysics.Constraints.SpringSettings)">
            <summary>
            Creates a new volume constraint, initializing the target volume using a set of initial positions.
            </summary>
            <param name="a">Initial position of the first body.</param>
            <param name="b">Initial position of the second body.</param>
            <param name="c">Initial position of the third body.</param>
            <param name="d">Initial position of the fourth body.</param>
            <param name="springSettings">Spring settings to apply to the volume constraint.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.VolumeConstraintTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of volume constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Weld">
            <summary>
            Constrains two bodies to maintain a relative position and orientation. All six degrees of freedom are solved simultaneously.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Weld.LocalOffset">
            <summary>
            Offset from body A to body B in the local space of A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Weld.LocalOrientation">
            <summary>
            Target orientation of body B in body A's local space. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Weld.SpringSettings">
            <summary>
            Springiness of the position and orientation constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.WeldTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.DefaultTimestepper">
            <summary>
            Updates the simulation in the order of: sleeper -> predict body bounding boxes -> collision detection -> substepping solve -> data structure optimization.
            Each substep of the solve simulates and integrates a sub-timestep of length dt/substepCount.
            </summary>
        </member>
        <member name="E:BepuPhysics.DefaultTimestepper.Slept">
            <summary>
            Fires after the sleeper completes and before bodies are integrated.
            </summary>
        </member>
        <member name="E:BepuPhysics.DefaultTimestepper.BeforeCollisionDetection">
            <summary>
            Fires after bodies have their bounding boxes updated for the frame's predicted motion and before collision detection.
            </summary>
        </member>
        <member name="E:BepuPhysics.DefaultTimestepper.CollisionsDetected">
            <summary>
            Fires after all collisions have been identified, but before the substep loop begins.
            </summary>
        </member>
        <member name="E:BepuPhysics.DefaultTimestepper.ConstraintsSolved">
            <summary>
            Fires after the solver executes and before the final integration step.
            </summary>
        </member>
        <member name="T:BepuPhysics.DefaultTypes">
            <summary>
            Helper class to register the default types within a simulation instance.
            </summary>
        </member>
        <member name="M:BepuPhysics.DefaultTypes.RegisterDefaults(BepuPhysics.Solver,BepuPhysics.CollisionDetection.NarrowPhase)">
            <summary>
            Registers the set of constraints that are packaged in the engine.
            </summary>
        </member>
        <member name="M:BepuPhysics.DefaultTypes.CreateDefaultCollisionTaskRegistry">
            <summary>
            Creates a task registry containing the default collision pair types.
            </summary>
        </member>
        <member name="M:BepuPhysics.DefaultTypes.CreateDefaultSweepTaskRegistry">
            <summary>
            Creates a task registry containing the default sweep task types.
            </summary>
        </member>
        <member name="T:BepuPhysics.BodyHandle">
            <summary>
            Unique identifier of a body belonging to a simulation's Bodies collection.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyHandle.Value">
            <summary>
            Index in the handle-to-memory mapping table used to look up the current memory location of the body. 
            This value will not (and must not) change during the body's lifespan, but the memory that the table points to could change.
            </summary>
        </member>
        <member name="T:BepuPhysics.StaticHandle">
            <summary>
            Unique identifier of a static belonging to a simulation's Statics collection.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticHandle.Value">
            <summary>
            Index in the handle-to-memory mapping table used to look up the current memory location of the body. 
            This value will not (and must not) change during the body's lifespan, but the memory that the table points to could change.
            </summary>
        </member>
        <member name="T:BepuPhysics.ConstraintHandle">
            <summary>
            Unique identifier of a constraint belonging to a simulation's Solver.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintHandle.Value">
            <summary>
            Index in the handle-to-memory mapping table used to look up the current memory location of the constraint. 
            This value will not (and must not) change during the constraint's lifespan, but the memory that the table points to could change.
            </summary>
        </member>
        <member name="T:BepuPhysics.ActiveConstraintBodyHandleCollector">
            <summary>
            Collects body handles associated with an active constraint as integers.
            </summary>
        </member>
        <member name="T:BepuPhysics.ActiveConstraintDynamicBodyHandleCollector">
            <summary>
            Collects body handles associated with an active constraint as integers.
            </summary>
        </member>
        <member name="T:BepuPhysics.ActiveConstraintBodyIndexCollector">
            <summary>
            Collects body indices associated with an active constraint. Encoded metadata is stripped.
            </summary>
        </member>
        <member name="T:BepuPhysics.PassthroughReferenceCollector">
            <summary>
            Directly reports references as provided by whatever is being enumerated.
            For example, when used directly with the TypeProcessor's EnumerateConnectedRawBodyReferences, if the constraint is active, this will report encoded body indices. If the constraint is sleeping, this will report body handles.
            If used with an enumerator that does filtering, the filtered results will be reported unmodified.
            </summary>
        </member>
        <member name="T:BepuPhysics.Helpers">
            <summary>
            Shared miscellaneous helper functions.
            </summary>
        </member>
        <member name="T:BepuPhysics.HashDiagnosticType">
            <summary>
            Hardcoded hash types used by invasive hash diagnostics.
            </summary>
        </member>
        <member name="T:BepuPhysics.InvasiveHashDiagnostics">
            <summary>
            Helper diagnostics class for monitoring internal state determinism across runs.
            Typically used by inserting tests into engine internals.
            </summary>
        </member>
        <member name="F:BepuPhysics.InvasiveHashDiagnostics.HashTypeCount">
            <summary>
            This is meant as an internal diagnostic utility, so hardcoding some things is totally fine.
            </summary>
        </member>
        <member name="T:BepuPhysics.IslandAwakener">
            <summary>
            Provides functionality for efficiently waking up sleeping bodies.
            </summary>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenBody(BepuPhysics.BodyHandle)">
            <summary>
            Wakes up a body if it is sleeping. All bodies that can be found by traversing the constraint graph from the body will also be awakened.
            If the body is already awake, this does nothing.
            </summary>
            <param name="bodyHandle">Handle of the body to awaken.</param>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenConstraint(BepuPhysics.ConstraintHandle)">
            <summary>
            Wakes up any sleeping bodies associated with a constraint. All bodies that can be found by traversing the constraint graph from the constraint referenced bodies will also be awakened.
            If all bodies associated with the constraint are already awake, this does nothing.
            </summary>
            <param name="constraintHandle">Handle of the constraint to awaken.</param>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenSet(System.Int32)">
            <summary>
            Wakes up all bodies and constraints within a set. Doesn't do anything if the set is awake (index zero).
            </summary>
            <param name="setIndex">Index of the set to awaken.</param>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenSets(BepuUtilities.Collections.QuickList{System.Int32}@,BepuUtilities.IThreadDispatcher)">
            <summary>
            Awakens a list of set indices.
            </summary>
            <param name="setIndices">List of set indices to wake up.</param>
            <param name="threadDispatcher">Thread dispatcher to use when waking the bodies. Pass null to run on a single thread.</param>
        </member>
        <member name="T:BepuPhysics.IslandScaffold">
            <summary>
            Represents the constraint batch structure and all references in an island. Holds everything necessary to create and gather a full island.
            </summary>
        </member>
        <member name="P:BepuPhysics.IslandSleeper.TestedFractionPerFrame">
            <summary>
            Gets or sets the multiplier applied to the active body count used to calculate the number of sleep traversals in a given timestep.
            </summary>
        </member>
        <member name="P:BepuPhysics.IslandSleeper.TargetSleptFraction">
            <summary>
            Gets or sets the fraction of the active set to target as the number of bodies slept in a given frame.
            This is only a goal; the actual number of slept bodies may be more or less.
            </summary>
        </member>
        <member name="P:BepuPhysics.IslandSleeper.TargetTraversedFraction">
            <summary>
            Gets or sets the fraction of the active set to target as the number of bodies traversed for sleeping in a given frame.
            This is only a goal; the actual number of traversed bodies may be more or less.
            </summary>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.CollectIsland``1(BepuUtilities.Memory.BufferPool,System.Int32,``0@,BepuUtilities.Collections.QuickList{System.Int32}@,BepuUtilities.Collections.QuickList{BepuPhysics.ConstraintHandle}@)">
            <summary>
            Traverses the active constraint graph collecting bodies that match a predicate. If any body visited during the traversal fails to match the predicate, the traversal terminates.
            </summary>
            <typeparam name="TTraversalPredicate">Type of the predicate to test each body index with.</typeparam>
            <param name="pool">Pool to allocate temporary collections from.</param>
            <param name="startingActiveBodyIndex">Index of the active body to start the traversal at.</param>
            <param name="predicate">Predicate to test each traversed body with. If any body results in the predicate returning false, the traversal stops and the function returns false.</param>
            <param name="bodyIndices">List to fill with body indices traversed during island collection. Bodies failing the predicate will not be included.</param>
            <param name="constraintHandles">List to fill with constraint handles traversed during island collection.</param>
            <returns>True if the simulation graph was traversed without ever finding a body that made the predicate return false. False if any body failed the predicate.
            The bodyIndices and constraintHandles lists will contain all traversed predicate-passing bodies and constraints.</returns>
        </member>
        <member name="F:BepuPhysics.IslandSleeper.GatheringJob.IsBodyJob">
            <summary>
            If true, this job relates to a subset of body indices. If false, this job relates to a subset of constraint handles.
            </summary>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.Sleep(BepuUtilities.Collections.QuickList{System.Int32}@,BepuUtilities.IThreadDispatcher,System.Boolean)">
            <summary>
            Forcefully sleeps a list of bodies and all bodies that can be reached by traversing the constraint graph from those bodies.
            </summary>
            <param name="bodyIndices">List of body indices to sleep.</param>
            <param name="threadDispatcher">Thread dispatcher to use for the sleep attempt, if any. If null, sleep is performed on the calling thread.</param>
            <param name="deterministic">True if the sleep should produce deterministic results at higher cost, false otherwise.</param>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.Sleep(System.Int32)">
            <summary>
            Forces a body and all bodies that can be found by traversing the constraint graph from that body to go to sleep.
            </summary>
            <param name="bodyIndex">Index of the body to sleep in the active set.</param>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.EnsureSetsCapacity(System.Int32)">
            <summary>
            Ensures that the Bodies, Solver, and NarrowPhase can hold at least the given number of sets (BodySets for the Bodies collection, ConstraintSets for the Solver, PairSubcaches for the NarrowPhase.PairCache).
            </summary>
            <param name="setsCapacity">Number of sets to guarantee space for.</param>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.ResizeSetsCapacity(System.Int32)">
            <summary>
            Ensures that the Bodies and Solver can hold the given number of sets. 
            If the existing allocation is smaller than the requested sets capacity, the allocation will be enlarged.
            If the existing allocation is larger than both the existing potentially allocated set range and the requested sets capacity, the allocation will be shrunk.
            Shrinks will never cause an existing set to be lost.
            </summary>
            <param name="setsCapacity">Target number of sets to allocate space for.</param>
        </member>
        <member name="T:BepuPhysics.TimestepperStageHandler">
            <summary>
            Delegate used by ITimesteppers for their stage callbacks.
            </summary>
            <param name="dt">Time step duration.</param>
            <param name="threadDispatcher">Thread dispatcher used for this timestep.</param>
        </member>
        <member name="T:BepuPhysics.ITimestepper">
            <summary>
            Defines a type capable of updating the simulation state for a given elapsed time.
            </summary>
        </member>
        <member name="E:BepuPhysics.ITimestepper.BeforeCollisionDetection">
            <summary>
            Callbacks to execute immediately before collision detection executes.
            </summary>
        </member>
        <member name="E:BepuPhysics.ITimestepper.CollisionsDetected">
            <summary>
            Callbacks to execute after collision detection completes.
            </summary>
        </member>
        <member name="M:BepuPhysics.ITimestepper.Timestep(BepuPhysics.Simulation,System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Performs one timestep of the given length.
            </summary>
            <param name="simulation">Simulation to be stepped forward in time.</param>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="T:BepuPhysics.LocalSpinWait">
            <summary>
            Behaves like a framework SpinWait, but never voluntarily relinquishes the timeslice to off-core threads.
            </summary>
            <remarks><para>There are two big reasons for using this over the regular framework SpinWait:</para>
            <para>1) The framework spinwait relies on spins for quite a while before resorting to any form of timeslice surrender.
            Empirically, this is not ideal for the solver- if the sync condition isn't met within several nanoseconds, it will tend to be some microseconds away.
            This spinwait is much more aggressive about moving to yields.</para>
            <para>2) After a number of yields, the framework SpinWait will resort to calling Sleep.
            This widens the potential set of schedulable threads to those not native to the current core. If we permit that transition, it is likely to evict cached solver data.
            (For very large simulations, the use of Sleep(0) isn't that concerning- every iteration can be large enough to evict all of cache- 
            but there still isn't much benefit to using it over yields in context.)</para>
            <para>SpinWait will also fall back to Sleep(1) by default which obliterates performance, but that behavior can be disabled.</para>
            <para>Note that this isn't an indication that the framework SpinWait should be changed, but rather that the solver's requirements are extremely specific and don't match
            a general purpose solution very well.</para></remarks>
        </member>
        <member name="T:BepuPhysics.AngularIntegrationMode">
            <summary>
            Defines how a pose integrator should handle angular velocity integration.
            </summary>
        </member>
        <member name="F:BepuPhysics.AngularIntegrationMode.Nonconserving">
            <summary>
            Angular velocity is directly integrated and does not change as the body pose changes. Does not conserve angular momentum.
            </summary>
        </member>
        <member name="F:BepuPhysics.AngularIntegrationMode.ConserveMomentum">
            <summary>
            Approximately conserves angular momentum by updating the angular velocity according to the change in orientation. Does a decent job for gyroscopes, but angular velocities will tend to drift towards a minimal inertia axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.AngularIntegrationMode.ConserveMomentumWithGyroscopicTorque">
            <summary>
            Approximately conserves angular momentum by including an implicit gyroscopic torque. Best option for Dzhanibekov effect simulation, but applies a damping effect that can make gyroscopes less useful.
            </summary>
        </member>
        <member name="T:BepuPhysics.IPoseIntegratorCallbacks">
            <summary>
            Defines a type that handles callbacks for body pose integration.
            </summary>
        </member>
        <member name="P:BepuPhysics.IPoseIntegratorCallbacks.AngularIntegrationMode">
            <summary>
            Gets how the pose integrator should handle angular velocity integration.
            </summary>
        </member>
        <member name="P:BepuPhysics.IPoseIntegratorCallbacks.AllowSubstepsForUnconstrainedBodies">
            <summary>
            Gets whether the integrator should use only one step for unconstrained bodies when using a substepping solver.
            If true, unconstrained bodies use a single step of length equal to the dt provided to <see cref="M:BepuPhysics.Simulation.Timestep(System.Single,BepuUtilities.IThreadDispatcher)"/>. 
            If false, unconstrained bodies will be integrated with the same number of substeps as the constrained bodies in the solver.
            </summary>
        </member>
        <member name="P:BepuPhysics.IPoseIntegratorCallbacks.IntegrateVelocityForKinematics">
            <summary>
            Gets whether the velocity integration callback should be called for kinematic bodies.
            If true, <see cref="M:BepuPhysics.IPoseIntegratorCallbacks.IntegrateVelocity(System.Numerics.Vector{System.Int32},BepuUtilities.Vector3Wide,BepuUtilities.QuaternionWide,BepuPhysics.BodyInertiaWide,System.Numerics.Vector{System.Int32},System.Int32,System.Numerics.Vector{System.Single},BepuPhysics.BodyVelocityWide@)"/> will be called for bundles including kinematic bodies.
            If false, kinematic bodies will just continue using whatever velocity they have set.
            Most use cases should set this to false.
            </summary>
        </member>
        <member name="M:BepuPhysics.IPoseIntegratorCallbacks.Initialize(BepuPhysics.Simulation)">
            <summary>
            Performs any required initialization logic after the Simulation instance has been constructed.
            </summary>
            <param name="simulation">Simulation that owns these callbacks.</param>
        </member>
        <member name="M:BepuPhysics.IPoseIntegratorCallbacks.PrepareForIntegration(System.Single)">
            <summary>
            Callback invoked ahead of dispatches that may call into <see cref="M:BepuPhysics.IPoseIntegratorCallbacks.IntegrateVelocity(System.Numerics.Vector{System.Int32},BepuUtilities.Vector3Wide,BepuUtilities.QuaternionWide,BepuPhysics.BodyInertiaWide,System.Numerics.Vector{System.Int32},System.Int32,System.Numerics.Vector{System.Single},BepuPhysics.BodyVelocityWide@)"/>.
            It may be called more than once with different values over a frame. For example, when performing bounding box prediction, velocity is integrated with a full frame time step duration.
            During substepped solves, integration is split into substepCount steps, each with fullFrameDuration / substepCount duration.
            The final integration pass for unconstrained bodies may be either fullFrameDuration or fullFrameDuration / substepCount, depending on the value of AllowSubstepsForUnconstrainedBodies. 
            </summary>
            <param name="dt">Current integration time step duration.</param>
            <remarks>This is typically used for precomputing anything expensive that will be used across velocity integration.</remarks>
        </member>
        <member name="M:BepuPhysics.IPoseIntegratorCallbacks.IntegrateVelocity(System.Numerics.Vector{System.Int32},BepuUtilities.Vector3Wide,BepuUtilities.QuaternionWide,BepuPhysics.BodyInertiaWide,System.Numerics.Vector{System.Int32},System.Int32,System.Numerics.Vector{System.Single},BepuPhysics.BodyVelocityWide@)">
            <summary>
            Callback for a bundle of bodies being integrated.
            </summary>
            <param name="bodyIndices">Indices of the bodies being integrated in this bundle.</param>
            <param name="position">Current body positions.</param>
            <param name="orientation">Current body orientations.</param>
            <param name="localInertia">Body's current local inertia.</param>
            <param name="integrationMask">Mask indicating which lanes are active in the bundle. Active lanes will contain 0xFFFFFFFF, inactive lanes will contain 0.</param>
            <param name="workerIndex">Index of the worker thread processing this bundle.</param>
            <param name="dt">Durations to integrate the velocity over. Can vary over lanes.</param>
            <param name="velocity">Velocity of bodies in the bundle. Any changes to lanes which are not active by the integrationMask will be discarded.</param>
        </member>
        <member name="T:BepuPhysics.PoseIntegration">
            <summary>
            Provides helper functions for integrating body poses.
            </summary>
        </member>
        <member name="M:BepuPhysics.PoseIntegration.FallbackIfInertiaIncompatible(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Uses the previous angular velocity if attempting to conserve angular momentum introduced infinities or NaNs. Happens when attempting to conserve momentum with a kinematic or partially inertia locked body.
            </summary>
        </member>
        <member name="T:BepuPhysics.PoseIntegrator`1">
            <summary>
            Handles body integration work that isn't bundled into the solver's execution. Predicts bounding boxes, integrates velocity and poses for unconstrained bodies, and does final post-substepping pose integration for constrained bodies.
            </summary>
        </member>
        <member name="M:BepuPhysics.PoseIntegrator`1.IntegrateKinematicVelocities(BepuUtilities.Memory.Buffer{System.Int32},System.Int32,System.Int32,System.Single,System.Int32)">
            <summary>
            Integrates the velocities of kinematic bodies as a prepass to the first substep during solving.
            Kinematics have to be integrated ahead of time since they don't block constraint batch membership; the same kinematic could appear in the batch multiple times.
            </summary>
        </member>
        <member name="M:BepuPhysics.PoseIntegrator`1.IntegrateKinematicPosesAndVelocities(BepuUtilities.Memory.Buffer{System.Int32},System.Int32,System.Int32,System.Single,System.Int32)">
            <summary>
            Integrates the poses *then* velocities of kinematic bodies as a prepass to the second or later substeps during solving.
            Kinematics have to be integrated ahead of time since they don't block constraint batch membership; the same kinematic could appear in the batch multiple times.
            </summary>
        </member>
        <member name="T:BepuPhysics.SequentialFallbackBatch">
            <summary>
            Contains constraints that could not belong to any lower constraint batch due to their involved bodies. All of the contained constraints will be solved using a fallback solver that
            trades rigidity for parallelism.
            </summary>
        </member>
        <member name="P:BepuPhysics.SequentialFallbackBatch.BodyCount">
            <summary>
            Gets the number of bodies in the fallback batch.
            </summary>
        </member>
        <member name="M:BepuPhysics.SequentialFallbackBatch.RemoveOneBodyReferenceFromDynamicsSet(System.Int32,BepuUtilities.Collections.QuickList{System.Int32}@)">
            <summary>
            Removes a constraint from a body in the fallback batch.
            </summary>
            <param name="bodyReference">Body associated with a constraint in the fallback batch.</param>
            <param name="allocationIdsToFree">Allocations that should be freed once execution is back in a safe context.</param>
            <returns>True if the body was dynamic and no longer has any constraints associated with it in the fallback batch, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.SequentialFallbackBatch.TryRemoveDynamicBodyFromTracking(System.Int32,BepuUtilities.Collections.QuickList{System.Int32}@)">
            <summary>
            Removes a body from the fallback batch's dynamic body constraint counts if it is present.
            </summary>
            <param name="bodyReference">Reference to the body to remove from the fallback batch.</param>
            <param name="allocationIdsToFree">Allocations that should be freed once execution is back in a safe context.</param>
            <returns>True if the body was present in the fallback batch and was removed, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.Simulation">
            <summary>
            Orchestrates the bookkeeping and execution of a full dynamic simulation.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.Profiler">
            <summary>
            Gets the simulation profiler. Note that the SimulationProfiler implementation only exists when the library is compiled with the PROFILE compilation symbol; if not defined, returned times are undefined.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.BufferPool">
            <summary>
            Gets the main memory pool used to fill persistent structures and main thread ephemeral resources across the engine.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.Timestepper">
            <summary>
            Gets the timestepper used to update the simulation state.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.Deterministic">
            <summary>
            Gets or sets whether to use a deterministic time step when using multithreading. When set to true, additional time is spent sorting constraint additions and transfers.
            Note that this can only affect determinism locally- different processor architectures may implement instructions differently.
            </summary>
        </member>
        <member name="M:BepuPhysics.Simulation.Create``2(BepuUtilities.Memory.BufferPool,``0,``1,BepuPhysics.SolveDescription,BepuPhysics.ITimestepper,System.Nullable{BepuPhysics.SimulationAllocationSizes})">
            <summary>
            Constructs a simulation supporting dynamic movement and constraints with the specified narrow phase callbacks.
            </summary>
            <param name="bufferPool">Buffer pool used to fill persistent structures and main thread ephemeral resources across the engine.</param>
            <param name="narrowPhaseCallbacks">Callbacks to use in the narrow phase.</param>
            <param name="poseIntegratorCallbacks">Callbacks to use in the pose integrator.</param>
            <param name="timestepper">Timestepper that defines how the simulation state should be updated. If null, <see cref="T:BepuPhysics.DefaultTimestepper"/> is used.</param>
            <param name="solveDescription">Describes how the solver should execute, including the number of substeps and the number of velocity iterations per substep.</param>
            <param name="initialAllocationSizes">Allocation sizes to initialize the simulation with. If left null, default values are chosen.</param>
            <returns>New simulation.</returns>
        </member>
        <member name="M:BepuPhysics.Simulation.Sleep(BepuUtilities.IThreadDispatcher)">
            <summary>
            Executes the sleep stage, moving candidate
            </summary>
            <param name="threadDispatcher">Thread dispatcher to use for the sleeper execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.PredictBoundingBoxes(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Predicts the bounding boxes of active bodies by speculatively integrating velocity. Does not actually modify body velocities. Updates deactivation candidacy.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.CollisionDetection(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Updates the broad phase structure for the current body bounding boxes, finds potentially colliding pairs, and then executes the narrow phase for all such pairs. Generates contact constraints for the solver.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Solve(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Updates the broad phase structure for the current body bounding boxes, finds potentially colliding pairs, and then executes the narrow phase for all such pairs. Generates contact constraints for the solver.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.IncrementallyOptimizeDataStructures(BepuUtilities.IThreadDispatcher)">
            <summary>
            Incrementally improves body and constraint storage for better performance.
            </summary>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Timestep(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Performs one timestep of the given length.
            </summary>
            <remarks>
            Be wary of variable timesteps. They can harm stability. Whenever possible, keep the timestep the same across multiple frames unless you have a specific reason not to.
            </remarks>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Clear">
            <summary>
            Clears the simulation of every object, only returning memory to the pool that would be returned by sequential removes. 
            Other persistent allocations, like those in the Bodies set, will remain.
            </summary>
        </member>
        <member name="M:BepuPhysics.Simulation.EnsureCapacity(BepuPhysics.SimulationAllocationSizes)">
            <summary>
            Increases the allocation size of any buffers too small to hold the allocation target.
            </summary>
            <remarks>
            <para>
            The final size of the allocated buffers are constrained by the allocator. It is not guaranteed to be exactly equal to the target, but it is guaranteed to be at least as large.
            </para>
            <para>
            This is primarily a convenience function. Everything it does internally can be done externally.
            For example, if only type batches need to be resized, the solver's own functions can be used directly.
            </para>
            </remarks>
            <param name="allocationTarget">Allocation sizes to guarantee sufficient size for.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Resize(BepuPhysics.SimulationAllocationSizes)">
            <summary>
            Increases the allocation size of any buffers too small to hold the allocation target, and decreases the allocation size of any buffers that are unnecessarily large.
            </summary>
            <remarks>
            <para>
            The final size of the allocated buffers are constrained by the allocator. It is not guaranteed to be exactly equal to the target, but it is guaranteed to be at least as large.
            </para>
            <para>
            This is primarily a convenience function. Everything it does internally can be done externally.
            For example, if only type batches need to be resized, the solver's own functions can be used directly.
            </para>
            </remarks>
            <param name="allocationTarget">Allocation sizes to guarantee sufficient size for.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Dispose">
            <summary>
            Clears the simulation of every object and returns all pooled memory to the buffer pool. Leaves the simulation in an unusable state.
            </summary>
        </member>
        <member name="M:BepuPhysics.Simulation.RayCast``1(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,``0@,System.Int32)">
            <summary>
            Intersects a ray against the simulation.
            </summary>
            <typeparam name="THitHandler">Type of the callbacks to execute on ray-object intersections.</typeparam>
            <param name="origin">Origin of the ray to cast.</param>
            <param name="direction">Direction of the ray to cast.</param>
            <param name="maximumT">Maximum length of the ray traversal in units of the direction's length.</param>
            <param name="hitHandler">callbacks to execute on ray-object intersections.</param>
            <param name="id">User specified id of the ray.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Sweep``2(``0,BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,System.Single,BepuUtilities.Memory.BufferPool,``1@,System.Single,System.Single,System.Int32)">
            <summary>
            Sweeps a shape against the simulation.
            </summary>
            <typeparam name="TShape">Type of the shape to sweep.</typeparam>
            <typeparam name="TSweepHitHandler">Type of the callbacks executed when a sweep impacts an object in the scene.</typeparam>
            <param name="shape">Shape to sweep.</param>
            <param name="pose">Starting pose of the sweep.</param>
            <param name="velocity">Velocity of the swept shape.</param>
            <param name="maximumT">Maximum length of the sweep in units of time used to integrate the velocity.</param>
            <param name="pool">Pool to allocate any temporary resources in during execution.</param>
            <param name="hitHandler">Callbacks executed when a sweep impacts an object in the scene.</param>
            <remarks>Simulation objects are treated as stationary during the sweep.</remarks>
            <param name="minimumProgression">Minimum amount of progress in terms of t parameter that any iterative sweep tests should make for each sample.</param>
            <param name="convergenceThreshold">Threshold in terms of t parameter under which iterative sweep tests are permitted to exit in collision.</param>
            <param name="maximumIterationCount">Maximum number of iterations to use in iterative sweep tests.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Sweep``2(``0@,BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,System.Single,BepuUtilities.Memory.BufferPool,``1@)">
            <summary>
            Sweeps a shape against the simulation.
            </summary>
            <typeparam name="TShape">Type of the shape to sweep.</typeparam>
            <typeparam name="TSweepHitHandler">Type of the callbacks executed when a sweep impacts an object in the scene.</typeparam>
            <param name="shape">Shape to sweep.</param>
            <param name="pose">Starting pose of the sweep.</param>
            <param name="velocity">Velocity of the swept shape.</param>
            <param name="maximumT">Maximum length of the sweep in units of time used to integrate the velocity.</param>
            <param name="pool">Pool to allocate any temporary resources in during execution.</param>
            <param name="hitHandler">Callbacks executed when a sweep impacts an object in the scene.</param>
            <remarks>Simulation objects are treated as stationary during the sweep.</remarks>
        </member>
        <member name="T:BepuPhysics.SimulationAllocationSizes">
            <summary>
            The common set of allocation sizes for a simulation.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Bodies">
            <summary>
            The number of bodies to allocate space for.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Statics">
            <summary>
            The number of statics to allocate space for.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Islands">
            <summary>
            The number of inactive islands to allocate space for.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.ShapesPerType">
            <summary>
            Minimum number of shapes to allocate space for in each shape type batch.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Constraints">
            <summary>
            The number of constraints to allocate bookkeeping space for. This does not affect actual type batch allocation sizes, only the solver-level constraint handle storage.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.ConstraintsPerTypeBatch">
            <summary>
            The minimum number of constraints to allocate space for in each individual type batch.
            New type batches will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.
            The number of constraints can vary greatly across types- there are usually far more contacts than ragdoll constraints.
            Per type estimates can be assigned within the Solver.TypeBatchAllocation if necessary. This value acts as a lower bound for all types.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.ConstraintCountPerBodyEstimate">
            <summary>
            The minimum number of constraints to allocate space for in each body's constraint list.
            New bodies will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.
            </summary>
        </member>
        <member name="M:BepuPhysics.SimulationAllocationSizes.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a description of simulation allocations.
            </summary>
            <param name="bodies">The number of bodies to allocate space for.</param>
            <param name="statics">The number of statics to allocate space for.</param>
            <param name="islands">The number of inactive islands to allocate space for.</param>
            <param name="shapesPerType">Minimum number of shapes to allocate space for in each shape type batch.</param>
            <param name="constraints">The number of constraints to allocate bookkeeping space for. This does not affect actual type batch allocation sizes, only the solver-level constraint handle storage.</param>
            <param name="constraintsPerTypeBatch">The minimum number of constraints to allocate space for in each individual type batch.
            New type batches will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.
            The number of constraints can vary greatly across types- there are usually far more contacts than ragdoll constraints.
            Per type estimates can be assigned within the Solver.TypeBatchAllocation if necessary. This value acts as a lower bound for all types.</param>
            <param name="constraintCountPerBodyEstimate">The minimum number of constraints to allocate space for in each body's constraint list.
            New bodies will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.</param>
        </member>
        <member name="T:BepuPhysics.SimulationProfiler">
            <summary>
            Stores profiling information for the previous simulation execution.
            </summary>
        </member>
        <member name="P:BepuPhysics.SimulationProfiler.Item(System.Object)">
            <summary>
            Gets the time it took to complete the last execution of the given stage. If no stage matching the given object ran, returns -1.
            </summary>
            <param name="stage">Stage to look up the time for.</param>
            <returns>Time it took to complete the last execution of the given stage.</returns>
        </member>
        <member name="M:BepuPhysics.IShapeRayHitHandler.AllowTest(System.Int32)">
            <summary>
            Checks whether the child of a collidable should be tested against a ray. Only called by shape types that can have more than one child.
            </summary>
            <param name="childIndex">Index of the candidate in the parent collidable.</param>
            <returns>True if the child should be tested by the ray, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.IShapeRayHitHandler.OnRayHit(BepuPhysics.Trees.RayData@,System.Single@,System.Single,System.Numerics.Vector3,System.Int32)">
            <summary>
            Called when a ray impact has been found.
            </summary>
            <param name="ray">Information about the ray associated with this hit.</param>
            <param name="maximumT">Maximum distance along the ray that the traversal is allowed to go in units of ray direction length. Can be set to limit future tests.</param>
            <param name="t">Distance along the ray to the impact in units of ray direction length. In other words, hitLocation = ray.Origin + ray.Direction * t.</param>
            <param name="normal">Surface normal at the hit location.</param>
            <param name="childIndex">Index of the hit child. For convex shapes or other types that don't have multiple children, this is always zero.</param>
        </member>
        <member name="T:BepuPhysics.IRayHitHandler">
            <summary>
            Defines a type capable of filtering ray test candidates and handling ray hit results.
            </summary>
        </member>
        <member name="M:BepuPhysics.IRayHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Checks whether a collidable identified by the acceleration structure should be tested against a ray.
            </summary>
            <param name="collidable">Candidate collidable for ray testing.</param>
            <returns>True if the collidable should be tested by the ray, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.IRayHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference,System.Int32)">
            <summary>
            Checks whether the child of a collidable should be tested against a ray. Only called by shape types that can have more than one child.
            </summary>
            <param name="collidable">Parent of the candidate.</param>
            <param name="childIndex">Index of the candidate in the parent collidable.</param>
            <returns>True if the child should be tested by the ray, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.IRayHitHandler.OnRayHit(BepuPhysics.Trees.RayData@,System.Single@,System.Single,System.Numerics.Vector3,BepuPhysics.Collidables.CollidableReference,System.Int32)">
            <summary>
            Called when a ray impact has been found.
            </summary>
            <param name="ray">Information about the ray associated with this hit.</param>
            <param name="maximumT">Maximum distance along the ray that the traversal is allowed to go in units of ray direction length. Can be set to limit future tests.</param>
            <param name="t">Distance along the ray to the impact in units of ray direction length. In other words, hitLocation = ray.Origin + ray.Direction * t.</param>
            <param name="normal">Surface normal at the hit location.</param>
            <param name="collidable">Collidable hit by the ray.</param>
            <param name="childIndex">Index of the hit child. For convex shapes or other types that don't have multiple children, this is always zero.</param>
        </member>
        <member name="T:BepuPhysics.ISweepHitHandler">
            <summary>
            Defines a type capable of filtering sweep candidates and handling sweep results.
            </summary>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Checks whether to run a detailed sweep test against a target collidable.
            </summary>
            <param name="collidable">Collidable to check.</param>
            <returns>True if the sweep test should be attempted, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference,System.Int32)">
            <summary>
            Checks whether to run a detailed sweep test against a target collidable's child.
            </summary>
            <param name="collidable">Collidable to check.</param>
            <param name="child">Index of the child in the collidable to check.</param>
            <returns>True if the sweep test should be attempted, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.OnHit(System.Single@,System.Single,System.Numerics.Vector3,System.Numerics.Vector3,BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Called when a sweep test detects a hit with nonzero T value.
            </summary>
            <param name="maximumT">Reference to maximumT passed to the traversal.</param>
            <param name="t">Time of impact for the sweep test.</param>
            <param name="hitLocation">Location of the first hit detected by the sweep.</param>
            <param name="hitNormal">Surface normal at the hit location.</param>
            <param name="collidable">Collidable hit by the traversal.</param>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.OnHitAtZeroT(System.Single@,BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Called when a sweep test detects a hit at T = 0, meaning that no location or normal can be computed.
            </summary>
            <param name="maximumT">Reference to maximumT passed to the traversal.</param>
            <param name="collidable">Collidable hit by the traversal.</param>
        </member>
        <member name="T:BepuPhysics.SubstepVelocityIterationScheduler">
            <summary>
            Callback executed to determine how many velocity iterations should be used for a given substep.
            </summary>
            <param name="substepIndex">Index of the substep to schedule velocity iterations for.</param>
            <returns>Number of velocity iterations to use for the substep. If nonpositive, <see cref="F:BepuPhysics.SolveDescription.VelocityIterationCount"/> will be used for the substep instead.</returns>
        </member>
        <member name="T:BepuPhysics.SolveDescription">
            <summary>
            Describes how the solver should schedule substeps and velocity iterations.
            </summary>
        </member>
        <member name="F:BepuPhysics.SolveDescription.VelocityIterationCount">
            <summary>
            Number of velocity iterations to use in the solver if there is no <see cref="F:BepuPhysics.SolveDescription.VelocityIterationScheduler"/> or if it returns a non-positive value for a substep.
            </summary>
        </member>
        <member name="F:BepuPhysics.SolveDescription.SubstepCount">
            <summary>
            Number of substeps to execute each time the solver runs.
            </summary>
        </member>
        <member name="F:BepuPhysics.SolveDescription.FallbackBatchThreshold">
            <summary>
            Number of synchronzed constraint batches to use before using a fallback approach.
            </summary>
        </member>
        <member name="F:BepuPhysics.SolveDescription.VelocityIterationScheduler">
            <summary>
            Callback executed to determine how many velocity iterations should be used for a given substep. If null, or if it returns a non-positive value, the <see cref="F:BepuPhysics.SolveDescription.VelocityIterationCount"/> will be used instead.
            </summary>
        </member>
        <member name="F:BepuPhysics.SolveDescription.DefaultFallbackBatchThreshold">
            <summary>
            Default number of synchronized constraint batches to use before falling back to an alternative solving method.
            </summary>
        </member>
        <member name="M:BepuPhysics.SolveDescription.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a solve description.
            </summary>
            <param name="velocityIterationCount">Number of velocity iterations per substep.</param>
            <param name="substepCount">Number of substeps in the solve.</param>
            <param name="fallbackBatchThreshold">Number of synchronzed constraint batches to use before using a fallback approach.</param>
        </member>
        <member name="M:BepuPhysics.SolveDescription.#ctor(System.Int32,BepuPhysics.SubstepVelocityIterationScheduler,System.Int32,System.Int32)">
            <summary>
            Creates a solve description.
            </summary>
            <param name="substepCount">Number of substeps in the solve.</param>
            <param name="velocityIterationScheduler"></param>
            <param name="fallbackVelocityIterationCount">Number of velocity iterations per substep for any substep that is not given a positive number of velocity iterations by the scheduler.</param>
            <param name="fallbackBatchThreshold">Number of synchronzed constraint batches to use before using a fallback approach.</param>
        </member>
        <member name="M:BepuPhysics.SolveDescription.#ctor(System.ReadOnlySpan{System.Int32},System.Int32,System.Int32)">
            <summary>
            Creates a solve description.
            </summary>
            <param name="substepVelocityIterations">Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span.</param>
            <param name="fallbackVelocityIterationCount">Number of velocity iterations per substep for any substep that is not given a positive number of velocity iterations by the scheduler.</param>
            <param name="fallbackBatchThreshold">Number of synchronzed constraint batches to use before using a fallback approach.</param>
        </member>
        <member name="M:BepuPhysics.SolveDescription.op_Implicit(System.Int32)~BepuPhysics.SolveDescription">
            <summary>
            Creates a solve description with the given number of velocity iterations and a single substep, with a fallback threshold of <see cref="F:BepuPhysics.SolveDescription.DefaultFallbackBatchThreshold"/>.
            </summary>
            <param name="velocityIterationCount">Number of velocity iterations per substep.</param>
        </member>
        <member name="M:BepuPhysics.SolveDescription.op_Implicit(System.ValueTuple{System.Int32,System.Int32})~BepuPhysics.SolveDescription">
            <summary>
            Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of <see cref="F:BepuPhysics.SolveDescription.DefaultFallbackBatchThreshold"/>.
            </summary>
            <param name="schedule">Number of substeps and iterations per solve.</param>
        </member>
        <member name="M:BepuPhysics.SolveDescription.op_Implicit(System.ReadOnlySpan{System.Int32})~BepuPhysics.SolveDescription">
            <summary>
            Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of <see cref="F:BepuPhysics.SolveDescription.DefaultFallbackBatchThreshold"/>.
            </summary>
            <param name="substepVelocityIterations">Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span.</param>
        </member>
        <member name="M:BepuPhysics.SolveDescription.op_Implicit(System.Int32[])~BepuPhysics.SolveDescription">
            <summary>
            Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of <see cref="F:BepuPhysics.SolveDescription.DefaultFallbackBatchThreshold"/>.
            </summary>
            <param name="substepVelocityIterations">Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span.</param>
        </member>
        <member name="M:BepuPhysics.SolveDescription.op_Implicit(BepuUtilities.Memory.Buffer{System.Int32})~BepuPhysics.SolveDescription">
            <summary>
            Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of <see cref="F:BepuPhysics.SolveDescription.DefaultFallbackBatchThreshold"/>.
            </summary>
            <param name="substepVelocityIterations">Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span.</param>
        </member>
        <member name="T:BepuPhysics.Solver">
            <summary>
            Holds and solves constraints between bodies in a simulation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.Sets">
            <summary>
            Buffer containing all constraint sets. The first slot is dedicated to the active set; subsequent slots may be occupied by the constraints associated with inactive islands.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.ActiveSet">
            <summary>
            Gets a reference to the active set of constraints, stored in the first set slot.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.TypeProcessors">
            <summary>
            Set of processors applied to batches of constraints of particular types, indexed by the constraint type id.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.HandlePool">
            <summary>
            Pool to retrieve constraint handles from when creating new constraints.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.HandleToConstraint">
            <summary>
            Mapping from constraint handle (via its internal integer value) to the location of a constraint in memory.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.FallbackBatchThreshold">
            <summary>
            Gets the maximum number of solver batches to allow before resorting to a fallback solver.
            If a single body is constrained by more than FallbackBatchThreshold constraints, all constraints beyond FallbackBatchThreshold are placed into a fallback batch.
            The fallback batch uses a different solver that can handle multiple constraints affecting a single body in a single batch, allowing greater parallelism at the cost of convergence speed.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.constrainedKinematicLock">
            <summary>
            Lock used to add to the constrained kinematic handles from multiple threads, if necessary.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.ConstrainedKinematicHandles">
            <summary>
            Set of body handles associated with constrained kinematic bodies. These will be integrated during substepping.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.SubstepCount">
            <summary>
            Gets or sets the number of substeps the solver will simulate per call to Solve.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.VelocityIterationCount">
            <summary>
            Gets or sets the number of solver velocity iterations to compute per substep.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.VelocityIterationScheduler">
            <summary>
            Callback executed to determine how many velocity iterations should be used for a given substep. If null, or if it returns a non-positive value, the <see cref="P:BepuPhysics.Solver.VelocityIterationCount"/> will be used instead.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.MinimumCapacityPerTypeBatch">
            <summary>
            Gets or sets the minimum amount of space, in constraints, initially allocated in any new type batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.Solver.SubstepEvent">
            <summary>
            Delegate type of solver substep begin/end events.
            </summary>
            <param name="substepIndex">Index of the substep that the event is about.</param>
        </member>
        <member name="E:BepuPhysics.Solver.SubstepStarted">
            <summary>
            Event invoked when the solver begins a substep. If the solver is executing on multiple threads, this will be invoked within the multithreaded dispatch on worker thread 0.
            </summary>
            <remarks>Take care when attempting to dispatch multithreaded operations from within this event.
            If using the same <see cref="T:BepuUtilities.IThreadDispatcher"/> instance as the solver, the dispatcher implementation must be reentrant. The demos implementation is not.</remarks>
        </member>
        <member name="E:BepuPhysics.Solver.SubstepEnded">
            <summary>
            Event invoked when the solver completes a substep. If the solver is executing on multiple threads, this will be invoked within the multithreaded dispatch on worker thread 0.
            </summary>
            <remarks>Take care when attempting to dispatch multithreaded operations from within this event.
            If using the same <see cref="T:BepuUtilities.IThreadDispatcher"/> instance as the solver, the dispatcher implementation must be reentrant. The demos implementation is not.</remarks>
        </member>
        <member name="M:BepuPhysics.Solver.SetMinimumCapacityForType(System.Int32,System.Int32)">
            <summary>
            Sets the minimum capacity initially allocated to a new type batch of the given type.
            </summary>
            <param name="typeId">Id of the constraint type to check the initial capacity of.</param>
            <param name="minimumInitialCapacityForType">Minimum capacity to use for the type.</param>
        </member>
        <member name="M:BepuPhysics.Solver.GetMinimumCapacityForType(System.Int32)">
            <summary>
            Gets the minimum initial capacity for a given type.
            The returned value is the larger of MinimumCapacityPerTypeBatch and the value set by SetMinimumCapacityForType for the given type id.
            </summary>
            <param name="typeId">Type id to retrieve the minm</param>
            <returns>Larger of MinimumCapacityPerTypeBatch and the given type's minimum set by SetMinimumCapacityForType.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.ResetPerTypeInitialCapacities">
            <summary>
            Resets all per-type initial capacities to zero. Leaves the minimum capacity across all constraints unchanged.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.CountConstraintsInTypeBatch(System.Int32,System.Int32,System.Int32)">
            <summary>
            Counts the number of constraints in a particular type batch.
            </summary>
            <param name="setIndex">Index of the set containing the type batch.</param>
            <param name="batchIndex">Index of the batch containing the type batch.</param>
            <param name="typeBatchIndex">Index of the type batch within the batch.</param>
            <returns>Number of constraints in the type batch.</returns>
            <remarks>This handles whether the type batch is in the fallback batch or not. Active fallback batches are not guaranteed to have contiguous constraints, so the <see cref="F:BepuPhysics.Constraints.TypeBatch.ConstraintCount"/> value is an upper bound and there may be gaps.</remarks>
        </member>
        <member name="M:BepuPhysics.Solver.CountConstraints">
            <summary>
            Gets the total number of constraints across all sets, batches, and types. Requires enumerating
            all type batches; this can be expensive.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.Register``1">
            <summary>
            Registers a constraint type with the solver, creating a type processor for the type internally and allowing constraints of that type to be added to the solver.
            </summary>
            <typeparam name="TDescription">Type of the constraint to register with the solver.</typeparam>
            <exception cref="T:System.ArgumentException">Fired when another constraint type of the same id has already been registered.</exception>
            <remarks><see cref="M:BepuPhysics.DefaultTypes.RegisterDefaults(BepuPhysics.Solver,BepuPhysics.CollisionDetection.NarrowPhase)"/> is called during simuation creation and registers all the built in types. Calling <see cref="M:BepuPhysics.Solver.Register``1"/> manually is only necessary if custom types are used.</remarks>
        </member>
        <member name="M:BepuPhysics.Solver.ConstraintExists(BepuPhysics.ConstraintHandle)">
            <summary>
            Gets whether the given constraint handle refers to a constraint in the solver.
            </summary>
            <param name="constraintHandle">Constraint handle to check for existence in the solver.</param>
            <returns>True if the constraint handle exists in the solver, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.GetConstraintReference(BepuPhysics.ConstraintHandle)">
            <summary>
            Gets a direct reference to the constraint associated with a handle.
            The reference is temporary; any constraint removals that affect the referenced type batch may invalidate the index.
            </summary>
            <param name="handle">Handle index of the constraint.</param>
            <returns>Temporary direct reference to the type batch and index in the type batch associated with the constraint handle.
            May be invalidated by constraint removals.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.FindCandidateBatch(BepuPhysics.CollisionDetection.CollidablePair)">
            <summary>
            Attempts to locate a spot for a new constraint. Does not perform allocation for the constraint. If no batch exists, returns the index just beyond the end of the existing list of batches.
            </summary>
            <returns>Index of the batch that the constraint would fit in.</returns>
            <remarks>This is used by the narrowphase's multithreaded constraint adders to locate a spot for a new constraint without requiring a lock. Only after a candidate is located
            do those systems attempt an actual claim, limiting the duration of locks and increasing potential parallelism.</remarks>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescriptionWithoutWaking``1(BepuPhysics.ConstraintReference@,``0@)">
            <summary>
            Applies a description to a constraint slot without waking up the associated island.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintReference">Reference of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescriptionWithoutWaking``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Applies a description to a constraint slot without waking up the associated island.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintHandle">Handle of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescription``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Applies a description to a constraint slot, waking up the connected bodies if necessary.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintHandle">Handle of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(System.Span{BepuPhysics.BodyHandle},``0@)">
            <summary>
            Allocates a constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandles">Body handles used by the constraint.</param>
            <param name="description">Description of the constraint to add.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a one-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandle">Body connected to the constraint.</param>
            <param name="description">Description of the constraint to add.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a two-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <param name="description">Description of the constraint to add.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a three-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <param name="bodyHandleC">Third body of the constraint.</param>
            <param name="description">Description of the constraint to add.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a four-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <param name="bodyHandleC">Third body of the constraint.</param>
            <param name="bodyHandleD">Fourth body of the constraint.</param>
            <param name="description">Description of the constraint to add.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.RemoveFromBatch(System.Int32,System.Int32,System.Int32)">
            <summary>
            Removes a constraint from a batch, performing any necessary batch cleanup, but does not return the constraint's handle to the pool.
            </summary>
            <param name="batchIndex">Index of the batch to remove from.</param>
            <param name="typeId">Type id of the constraint to remove.</param>
            <param name="indexInTypeBatch">Index of the constraint to remove within its type batch.</param>
        </member>
        <member name="T:BepuPhysics.Solver.RemoveConstraintReferencesFromBodiesEnumerator">
            <summary>
            Enumerates the bodies attached to an active constraint and removes the constraint's handle from all of the connected body constraint reference lists.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.Remove(BepuPhysics.ConstraintHandle)">
            <summary>
            Removes the constraint associated with the given handle. Note that this may invalidate any outstanding direct constraint references
            by reordering the constraints within the TypeBatch subject to removal.
            </summary>
            <param name="handle">Handle of the constraint to remove from the solver.</param>
        </member>
        <member name="M:BepuPhysics.Solver.GetDescription``1(BepuPhysics.ConstraintReference,``0@)">
            <summary>
            Gets the constraint description associated with a constraint reference.
            </summary>
            <typeparam name="TConstraintDescription">Type of the constraint description to retrieve.</typeparam>
            <param name="constraintReference">Reference to the constraint to retrieve.</param>
            <param name="description">Retrieved description of the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Solver.GetDescription``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Gets the constraint description associated with a constraint handle.
            </summary>
            <typeparam name="TConstraintDescription">Type of the constraint description to retrieve.</typeparam>
            <param name="handle">Handle of the constraint to retrieve.</param>
            <param name="description">Retrieved description of the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Solver.UpdateForBodyMemoryMove(System.Int32,System.Int32)">
            <summary>
            Changes the body references of all constraints associated with a body in response to its movement into a new slot.
            Constraints associated with the body now at its old slot, if any, are left untouched.
            </summary>
            <param name="originalBodyIndex">Memory index that the moved body used to inhabit.</param>
            <param name="newBodyLocation">Memory index that the moved body now inhabits.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ScaleAccumulatedImpulses(BepuPhysics.ConstraintSet@,System.Single)">
            <summary>
            Scales the accumulated impulses associated with a constraint set by a given scale.
            </summary>
            <param name="set">Set to scale.</param>
            <param name="scale">Scale to apply to accumulated impulses.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ScaleActiveAccumulatedImpulses(System.Single)">
            <summary>
            Scales all accumulated impulses in the active set.
            </summary>
            <param name="scale">Scale to apply to accumulated impulses.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ScaleAccumulatedImpulses(System.Single)">
            <summary>
            Scales all accumulated impulses in all constraint sets.
            </summary>
            <param name="scale">Scale to apply to accumulated impulses.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateAccumulatedImpulses``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Enumerates the accumulated impulses associated with a constraint.
            </summary>
            <param name="constraintHandle">Constraint to enumerate.</param>
            <param name="enumerator">Enumerator to use.</param>
        </member>
        <member name="M:BepuPhysics.Solver.GetAccumulatedImpulseMagnitudeSquared(BepuPhysics.ConstraintHandle)">
            <summary>
            Gathers the squared magnitude of the accumulated impulse for a given constraint.
            </summary>
            <param name="constraintHandle">Constraint to look up the accumulated impulses of.</param>
            <returns>Squared magnitude of the accumulated impulses associated with the given constraint.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.GetAccumulatedImpulseMagnitude(BepuPhysics.ConstraintHandle)">
            <summary>
            Gathers the magnitude of the accumulated impulse for a given constraint.
            </summary>
            <param name="constraintHandle">Constraint to look up the accumulated impulses of.</param>
            <returns>Magnitude of the accumulated impulses associated with the given constraint.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedBodyReferences``2(BepuPhysics.Constraints.TypeBatch@,System.Int32,``0@)">
            <summary>
            Enumerates body references in the constraint. Reports data according to the TReportType.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator called for each body index in the constraint.</typeparam>
            <typeparam name="TReportType">Type of information to report to the enumerator.</typeparam>
            <param name="typeBatch">Type batch containing the constraint to enumerate.</param>
            <param name="indexInTypeBatch">Index of the constraint to enumerate in the type batch.</param>
            <param name="enumerator">Enumerator to call for each connected body reference.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedRawBodyReferences``1(BepuPhysics.Constraints.TypeBatch@,System.Int32,``0@)">
            <summary>
            Enumerates the set of body references associated with a constraint in order of their references within the constraint.
            This will report the raw body reference (body index if awake, handle if asleep) and any encoded metadata, like whether the body is kinematic.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to call on each connected body reference.</typeparam>
            <param name="typeBatch">Type batch containing the constraint to enumerate.</param>
            <param name="indexInTypeBatch">Index of the constraint to enumerate in the type batch.</param>
            <param name="enumerator">Enumerator to call for each connected body reference.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedRawBodyReferences``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Enumerates the set of body references associated with a constraint in order of their references within the constraint.
            This will report the raw body reference (body index if awake, handle if asleep) and any encoded metadata, like whether the body is kinematic.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to call on each connected body reference.</typeparam>
            <param name="constraintHandle">Constraint to enumerate.</param>
            <param name="enumerator">Enumerator to call for each connected body reference.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedBodyReferences``1(BepuPhysics.Constraints.TypeBatch@,System.Int32,``0@)">
            <summary>
            Enumerates the set of body references associated with an active constraint in order of their references within the constraint.
            This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to call on each connected body reference.</typeparam>
            <param name="typeBatch">Type batch containing the constraint to enumerate.</param>
            <param name="indexInTypeBatch">Index of the constraint to enumerate in the type batch.</param>
            <param name="enumerator">Enumerator to call for each connected body reference.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedBodyReferences``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Enumerates the set of body references associated with an active constraint in order of their references within the constraint.
            This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to call on each connected body reference.</typeparam>
            <param name="constraintHandle">Constraint to enumerate.</param>
            <param name="enumerator">Enumerator to call for each connected body reference.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedDynamicBodies``1(BepuPhysics.Constraints.TypeBatch@,System.Int32,``0@)">
            <summary>
            Enumerates the set of dynamic body references associated with a constraint in order of their references within the constraint.
            This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata.
            Kinematic references are skipped.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to call on each connected dynamic body reference.</typeparam>
            <param name="typeBatch">Type batch containing the constraint to enumerate.</param>
            <param name="indexInTypeBatch">Index of the constraint to enumerate in the type batch.</param>
            <param name="enumerator">Enumerator to call for each connected dynamic body reference.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedDynamicBodies``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Enumerates the set of dynamic body references associated with a constraint in order of their references within the constraint.
            This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata.
            Kinematic references are skipped.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to call on each connected dynamic body reference.</typeparam>
            <param name="constraintHandle">Constraint to enumerate.</param>
            <param name="enumerator">Enumerator to call for each connected dynamic body reference.</param>
        </member>
        <member name="M:BepuPhysics.Solver.Clear">
            <summary>
            Removes all objects from the solver. This is meant as a fast path to empty a simulation's constraints. It makes no attempt to retain synchronization with other systems
            which may depend on the existence of constraints, like the per-body constraint lists.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.EnsureSolverCapacities(System.Int32,System.Int32)">
            <summary>
            Adjusts the size of the the solvers non-typebatch data structures. An allocation will grow if the given capacity exceeds the currently allocated capacity.
            </summary>
            <param name="bodyHandleCapacity">Size of the span of body handles to allocate space for. Applies to batch referenced handle sets.</param>
            <param name="constraintHandleCapacity">Number of constraint handles to allocate space for. Applies to the handle->constraint mapping table.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ResizeSolverCapacities(System.Int32,System.Int32)">
            <summary>
            Adjusts the size of the the solvers non-typebatch data structures. An allocation is allowed to shrink if it fits both all existing entries and the given capacity.
            An allocation will grow if the given capacity exceeds the currently allocated capacity.
            </summary>
            <param name="bodyHandleCapacity">Size of the span of body handles to allocate space for. Applies to batch referenced handle sets.</param>
            <param name="constraintHandleCapacity">Number of constraint handles to allocate space for. Applies to the handle->constraint mapping table.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnsureTypeBatchCapacities">
            <summary>
            Ensures all existing active type batches meet or exceed the current solver-defined minimum capacities. Type batches with capacities smaller than the minimums will be enlarged.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.ResizeTypeBatchCapacities">
            <summary>
            Applies the current solver-defined minimum capacities to existing type batches. Type batches with capacities larger than the minimums and counts less than the minimums may be shrunk.
            Type batches with capacities smaller than the minimums will be enlarged.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.Dispose">
            <summary>
            Returns all pool-retrieved resources to the pool.
            </summary>
            <remarks>
            The solver cannot be 'rehydrated' for reuse after a disposal. If you want to return bulk data to the pool while leaving the solver in a usable state, consider using Clear instead.
            </remarks>
        </member>
        <member name="F:BepuPhysics.Solver.WorkBlock.StartBundle">
            <summary>
            Index of the first bundle in the block.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.WorkBlock.End">
            <summary>
            Exlusive end index of the bundle. Index of the last bundle in the block is End - 1.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.SubstepMultithreadingContext.SyncIndex">
            <summary>
            Monotonically increasing index of executed stages during a frame.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.SubstepMultithreadingContext.CompletedWorkBlockCount">
            <summary>
            Counter of work completed for the current stage.
            </summary>
        </member>
        <member name="T:BepuPhysics.Solver`1">
            <summary>
            Handles integration-aware substepped solving.
            </summary>
            <typeparam name="TIntegrationCallbacks">Type of integration callbacks being used during the substepped solve.</typeparam>
        </member>
        <member name="P:BepuPhysics.Solver`1.PoseIntegrator">
            <summary>
            Pose integrator used by the simulation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver`1.coarseBatchIntegrationResponsibilities">
            <summary>
            Caches a single bool for whether type batches within batches have constraints with any integration responsibilities.
            Type batches with no integration responsibilities can use a codepath with no integration checks at all.
            </summary>
        </member>
        <member name="T:BepuPhysics.StaticDescription">
            <summary>
            Describes the properties of a static object. When added to a simulation, static objects can collide but have no velocity and will not move in response to forces.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticDescription.Pose">
            <summary>
            Position and orientation of the static.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticDescription.Shape">
            <summary>
            Shape of the static.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticDescription.Continuity">
            <summary>
            Continuous collision detection settings for the static.
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(BepuPhysics.RigidPose,BepuPhysics.Collidables.TypedIndex,BepuPhysics.Collidables.ContinuousDetection)">
            <summary>
            Builds a new static description.
            </summary>
            <param name="pose">Pose of the static collidable.</param>
            <param name="shape">Shape of the static.</param>
            <param name="continuity">Continuous collision detection settings for the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(BepuPhysics.RigidPose,BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Builds a new static description with <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete"/> continuity.
            </summary>
            <param name="pose">Pose of the static collidable.</param>
            <param name="shape">Shape of the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(System.Numerics.Vector3,System.Numerics.Quaternion,BepuPhysics.Collidables.TypedIndex,BepuPhysics.Collidables.ContinuousDetection)">
            <summary>
            Builds a new static description.
            </summary>
            <param name="position">Position of the static.</param>
            <param name="orientation">Orientation of the static.</param>
            <param name="shape">Shape of the static.</param>
            <param name="continuity">Continuous collision detection settings for the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(System.Numerics.Vector3,System.Numerics.Quaternion,BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Builds a new static description with <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete"/> continuity.
            </summary>
            <param name="position">Position of the static.</param>
            <param name="orientation">Orientation of the static.</param>
            <param name="shape">Shape of the static.</param>
        </member>
        <member name="T:BepuPhysics.StaticReference">
            <summary>
            Convenience structure for directly referring to a static's properties.
            </summary>
            <remarks>Note that this type makes no attempt to protect against unsafe modification of static properties.</remarks>
        </member>
        <member name="F:BepuPhysics.StaticReference.Handle">
            <summary>
            Handle of the static that this reference refers to.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticReference.Statics">
            <summary>
            The collection containing the static.
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticReference.#ctor(BepuPhysics.StaticHandle,BepuPhysics.Statics)">
            <summary>
            Constructs a new static reference.
            </summary>
            <param name="handle">Handle of the static to refer to.</param>
            <param name="statics">Collection containing the static.</param>
        </member>
        <member name="P:BepuPhysics.StaticReference.Exists">
            <summary>
            Gets whether the static reference exists within the static set. True if the handle maps to a valid memory location that agrees that the handle points to it, false otherwise.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Index">
            <summary>
            Gets a the static's index in the statics collection.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Static">
            <summary>
            Gets a reference to the entirety of the static's memory.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Pose">
            <summary>
            Gets a reference to the static's pose.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Continuity">
            <summary>
            Gets a reference to the static's collision continuity settings.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Shape">
            <summary>
            Gets the shape used by the static. To set the shape, use <see cref="M:BepuPhysics.StaticReference.SetShape(BepuPhysics.Collidables.TypedIndex)"/> or <see cref="M:BepuPhysics.StaticReference.ApplyDescription(BepuPhysics.StaticDescription@)"/>.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.CollidableReference">
            <summary>
            <para>Gets a CollidableReference for this static. CollidableReferences uniquely identify a collidable object in a simulation by including both the dynamic/kinematic/static state of the object and its handle.</para>
            <para>Despite an unfortunate naming collision, CollidableReferences are distinct from a direct reference to a static's collidable data, which you can get from the Collidable property.</para>
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticReference.GetDescription(BepuPhysics.StaticDescription@)">
            <summary>
            Gets a description of the static.
            </summary>
            <param name="description">Description of the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticReference.GetDescription">
            <summary>
            Gets a description of the static.
            </summary>
            <returns>Description of the static.</returns>
        </member>
        <member name="M:BepuPhysics.StaticReference.ApplyDescription(BepuPhysics.StaticDescription@)">
            <summary>
            Sets a static's properties according to a description.
            </summary>
            <param name="description">Description of the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticReference.SetShape(BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a static.
            </summary>
            <param name="newShape">Index of the new shape to use for the static.</param>
        </member>
        <member name="P:BepuPhysics.StaticReference.BoundingBox">
            <summary>
            Gets a copy of the static's bounding box.
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticReference.GetBoundsReferencesFromBroadPhase(System.Numerics.Vector3*@,System.Numerics.Vector3*@)">
            <summary>
            Gets direct pointers to the static's bounding box minimum and maximum in the broad phase. Outputs null if the static has no shape.
            </summary>
            <param name="min">Pointer to the bounding box minimum in the broad phase.</param>
            <param name="max">Pointer to the bounding box maximum in the broad phase.</param>
        </member>
        <member name="M:BepuPhysics.StaticReference.UpdateBounds">
            <summary>
            Updates the static's bounds in the broad phase for its current state. Does not include velocity expansion. Does nothing if the static has no shape.
            </summary>
            <remarks>Can be useful if you made modifications to the static's state that you want reflected in the broad phase before the next timestep.
            For example, if you want to perform ray casts against the broad phase after moving objects around directly, their bounds must be updated or else the broad phase bounds will be out of date and the ray will likely miss.</remarks>
        </member>
        <member name="T:BepuPhysics.IStaticChangeAwakeningFilter">
            <summary>
            Defines a type that determines which bodies should be awoken in the bounding box of a static when the static's state changes.
            </summary>
            <remarks>We cannot find bodies depending on a static through constraints, since statics do not maintain constraint lists.
            When a static is added, removed, has SetShape or has ApplyDescription called on it, 
            it looks up bodies in its bounding box that could possibly be affected by change and considers waking them up.
            This filter can be used to ignore some bodies.</remarks>
        </member>
        <member name="P:BepuPhysics.IStaticChangeAwakeningFilter.AllowAwakening">
            <summary>
            Gets whether to allow awakening for any body. If true, candidates will have the ShouldAwaken function called for them. 
            If false, ShouldAwaken will not be called, and no bodies will be awoken.
            </summary>
        </member>
        <member name="M:BepuPhysics.IStaticChangeAwakeningFilter.ShouldAwaken(BepuPhysics.BodyReference)">
            <summary>
            Determines whether a body should be forced awake by the state change of a static.
            </summary>
            <param name="body">Sleeping body under consideration for awakening.</param>
            <returns>True if the body should be forced awake, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.StaticsShouldntAwakenKinematics">
            <summary>
            Default awakening filter that only wakes up dynamic bodies. Kinematic bodies do not respond to any kind of dynamic simulation, so they won't respond to the change in statics.
            </summary>
        </member>
        <member name="T:BepuPhysics.Static">
            <summary>
            Stores data for a static collidable in the simulation. Statics can be posed and collide, but have no velocity and no dynamic behavior.
            </summary>
            <remarks>Unlike bodies, statics have a very simple access pattern. Most data is referenced together and there are no extreme high frequency data accesses like there are in the solver.
            Everything can be conveniently stored within a single location contiguously.</remarks>
        </member>
        <member name="F:BepuPhysics.Static.Pose">
            <summary>
            Pose of the static collidable.
            </summary>
        </member>
        <member name="F:BepuPhysics.Static.Continuity">
            <summary>
            Continuous collision detection settings for this collidable. Includes the collision detection mode to use and tuning variables associated with those modes.
            </summary>
            <remarks>Note that statics cannot move, so there is no difference between <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete"/> and <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Passive"/> for them.
            Enabling <see cref="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous"/> will still require that pairs associated with the static use swept continuous collision detection.</remarks>
        </member>
        <member name="F:BepuPhysics.Static.Shape">
            <summary>
            Index of the shape used by the static. While this can be changed, any transition from shapeless->shapeful or shapeful->shapeless must be reported to the broad phase. 
            If you need to perform such a transition, consider using <see cref="M:BepuPhysics.Statics.SetShape(BepuPhysics.StaticHandle,BepuPhysics.Collidables.TypedIndex)"/> or Statics.ApplyDescription; those functions update the relevant state.
            </summary>
        </member>
        <member name="F:BepuPhysics.Static.BroadPhaseIndex">
            <summary>
            Index of the collidable in the broad phase. Used to look up the target location for bounding box scatters. Under normal circumstances, this should not be set externally.
            </summary>
        </member>
        <member name="T:BepuPhysics.Statics">
            <summary>
            Collection of allocated statics.
            </summary>
        </member>
        <member name="F:BepuPhysics.Statics.HandleToIndex">
            <summary>
            Remaps a static handle integer value to the actual array index of the static.
            </summary>
        </member>
        <member name="F:BepuPhysics.Statics.IndexToHandle">
            <summary>
            Remaps a static index to its handle.
            </summary>
        </member>
        <member name="F:BepuPhysics.Statics.StaticsBuffer">
            <summary>
            The set of collidables owned by each static. Speculative margins, continuity settings, and shape indices can be changed directly.
            Shape indices cannot transition between pointing at a shape and pointing at nothing or vice versa without notifying the broad phase of the collidable addition or removal.
            Consider using <see cref="M:BepuPhysics.Statics.SetShape(BepuPhysics.StaticHandle,BepuPhysics.Collidables.TypedIndex)"/> or <see cref="M:BepuPhysics.Statics.ApplyDescription(BepuPhysics.StaticHandle,BepuPhysics.StaticDescription@)"/> to handle the bookkeeping changes automatically if changing the shape.
            </summary>
        </member>
        <member name="P:BepuPhysics.Statics.Item(BepuPhysics.StaticHandle)">
            <summary>
            Gets a reference to the memory backing a static collidable. The <see cref="T:BepuPhysics.StaticReference"/> type is a helper that exposes common operations for statics.
            </summary>
            <param name="handle">Handle of the static to retrieve a reference for.</param>
            <returns>Reference to the memory backing a static collidable.</returns>
            <remarks>Equivalent to <see cref="M:BepuPhysics.Statics.GetStaticReference(BepuPhysics.StaticHandle)"/>.</remarks>
        </member>
        <member name="M:BepuPhysics.Statics.GetDirectReference(BepuPhysics.StaticHandle)">
            <summary>
            Gets a direct reference to the memory backing a static.
            </summary>
            <param name="handle">Handle of the static to get a reference of.</param>
            <returns>Direct reference to the memory backing a static.</returns>
            <remarks>This is distinct from the <see cref="P:BepuPhysics.Statics.Item(BepuPhysics.StaticHandle)"/> indexer in that this returns the direct memory reference. <see cref="T:BepuPhysics.StaticReference"/> includes a layer of indirection that can expose more features.</remarks>
        </member>
        <member name="P:BepuPhysics.Statics.Item(System.Int32)">
            <summary>
            Gets a reference to the raw memory backing a static collidable.
            </summary>
            <param name="index">Index of the static to retrieve a memory reference for.</param>
            <returns>Direct reference to the memory backing a static collidable.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.StaticExists(BepuPhysics.StaticHandle)">
            <summary>
            Checks whether a static handle is currently registered with the statics set.
            </summary>
            <param name="handle">Handle to check for.</param>
            <returns>True if the handle exists in the collection, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.RemoveAt``1(System.Int32,``0@)">
            <summary>
            Removes a static from the set by index. Any sleeping bodies with bounding boxes overlapping the removed static's bounding box and passing the given filter will be forced awake.
            </summary>
            <param name="index">Index of the static to remove.</param>
            <param name="filter">Filter to apply to sleeping bodies near the removed static to see if they should be awoken.</param>
            <typeparam name="TAwakeningFilter">Type of the filter to apply to sleeping bodies.</typeparam>
        </member>
        <member name="M:BepuPhysics.Statics.RemoveAt(System.Int32)">
            <summary>
            Removes a static from the set by index. Any sleeping dynamic bodies with bounding boxes overlapping the removed static's bounding box will be forced active.
            </summary>
            <param name="index">Index of the static to remove.</param>
        </member>
        <member name="M:BepuPhysics.Statics.Remove``1(BepuPhysics.StaticHandle,``0@)">
            <summary>
            Removes a static from the set. Any sleeping bodies with bounding boxes overlapping the removed static's bounding box and passing the given filter will be forced active.
            </summary>
            <param name="handle">Handle of the static to remove.</param>
            <param name="filter">Filter to apply to sleeping bodies near the removed static to see if they should be awoken.</param>
            <typeparam name="TAwakeningFilter">Type of the filter to apply to sleeping bodies.</typeparam>
        </member>
        <member name="M:BepuPhysics.Statics.Remove(BepuPhysics.StaticHandle)">
            <summary>
            Removes a static from the set. Any sleeping dynamic bodies with bounding boxes overlapping the removed static's bounding box will be forced active.
            </summary>
            <param name="handle">Handle of the static to remove.</param>
        </member>
        <member name="M:BepuPhysics.Statics.UpdateBounds(BepuPhysics.StaticHandle)">
            <summary>
            Updates the bounds held within the broad phase for the static's current state.
            </summary>
        </member>
        <member name="M:BepuPhysics.Statics.Add``1(BepuPhysics.StaticDescription@,``0@)">
            <summary>
            Adds a new static body to the simulation. All sleeping bodies whose bounding boxes overlap the new static and pass the given filter are forced active.
            </summary>
            <param name="description">Description of the static to add.</param>
            <param name="filter">Filter to apply to sleeping bodies near the new static to see if they should be awoken.</param>
            <typeparam name="TAwakeningFilter">Type of the filter to apply to sleeping bodies.</typeparam>
            <returns>Handle of the new static.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.Add(BepuPhysics.StaticDescription@)">
            <summary>
            Adds a new static body to the simulation. All sleeping dynamic bodies whose bounding boxes overlap the new static are forced active.
            </summary>
            <param name="description">Description of the static to add.</param>
            <returns>Handle of the new static.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.SetShape``1(BepuPhysics.StaticHandle,BepuPhysics.Collidables.TypedIndex,``0@)">
            <summary>
            Changes the shape of a static and updates its bounds in the broad phase. All sleeping bodies with bounding boxes overlapping the old or new static collidable and pass the given filter are forced active.
            </summary>
            <param name="handle">Handle of the static to change the shape of.</param>
            <param name="newShape">Index of the new shape to use for the static.</param>
            <param name="filter">Filter to apply to sleeping bodies near the static to see if they should be awoken.</param>
            <typeparam name="TAwakeningFilter">Type of the filter to apply to sleeping bodies.</typeparam>
        </member>
        <member name="M:BepuPhysics.Statics.SetShape(BepuPhysics.StaticHandle,BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a static and updates its bounds in the broad phase. All sleeping dyanmic bodies with bounding boxes overlapping the old or new static collidable are forced active.
            </summary>
            <param name="handle">Handle of the static to change the shape of.</param>
            <param name="newShape">Index of the new shape to use for the static.</param>
        </member>
        <member name="M:BepuPhysics.Statics.ApplyDescription``1(BepuPhysics.StaticHandle,BepuPhysics.StaticDescription@,``0@)">
            <summary>
            Applies a new description to an existing static object. All sleeping bodies with bounding boxes overlapping the old or new static collidable and pass the given filter are forced active.
            Updates the bounds of the static in the broad phase.
            </summary>
            <param name="handle">Handle of the static to apply the description to.</param>
            <param name="description">Description to apply to the static.</param>
            <param name="filter">Filter to apply to sleeping bodies near the static to see if they should be awoken.</param>
            <typeparam name="TAwakeningFilter">Type of the filter to apply to sleeping bodies.</typeparam>
        </member>
        <member name="M:BepuPhysics.Statics.ApplyDescription(BepuPhysics.StaticHandle,BepuPhysics.StaticDescription@)">
            <summary>
            Applies a new description to an existing static object. All sleeping bodies with bounding boxes overlapping the old or new static collidable and pass the given filter are forced active.
            Updates the bounds of the static in the broad phase.
            </summary>
            <param name="handle">Handle of the static to apply the description to.</param>
            <param name="description">Description to apply to the static.</param>
        </member>
        <member name="M:BepuPhysics.Statics.GetDescription(BepuPhysics.StaticHandle,BepuPhysics.StaticDescription@)">
            <summary>
            Gets the current description of the static referred to by a given handle.
            </summary>
            <param name="handle">Handle of the static to look up the description of.</param>
            <param name="description">Gathered description of the handle-referenced static.</param>
        </member>
        <member name="M:BepuPhysics.Statics.GetDescription(BepuPhysics.StaticHandle)">
            <summary>
            Gets the current description of the static referred to by a given handle.
            </summary>
            <param name="handle">Handle of the static to look up the description of.</param>
            <returns>Gathered description of the handle-referenced static.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.GetStaticReference(BepuPhysics.StaticHandle)">
            <summary>
            Gets a reference to a static by its handle.
            </summary>
            <param name="handle">Handle of the static to grab a reference of.</param>
            <returns>Reference to the desired static.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.Clear">
            <summary>
            Clears all bodies from the set without returning any memory to the pool.
            </summary>
        </member>
        <member name="M:BepuPhysics.Statics.Resize(System.Int32)">
            <summary>
            Resizes the allocated spans for static data. Note that this is conservative; it will never orphan existing objects.
            </summary>
            <param name="capacity">Target static data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Statics.EnsureCapacity(System.Int32)">
            <summary>
            Increases the size of buffers if needed to hold the target capacity.
            </summary>
            <param name="capacity">Target data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Statics.Dispose">
            <summary>
            Returns all static resources to the pool used to create them.
            </summary>
            <remarks>The object can be reused if it is reinitialized by using EnsureCapacity or Resize.</remarks>
        </member>
        <member name="T:BepuPhysics.Trees.Leaf">
            <summary>
            Pointer to a leaf's tree location.
            </summary>
            <remarks>The identity of a leaf is implicit in its position within the leaf array.</remarks>
        </member>
        <member name="P:BepuPhysics.Trees.Leaf.NodeIndex">
            <summary>
            Gets the index of the node that the leaf is directly held by.
            </summary>
        </member>
        <member name="P:BepuPhysics.Trees.Leaf.ChildIndex">
            <summary>
            Gets which child within the owning node the leaf is in.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.Node">
            <summary>
            2-wide tree node.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.Metanode">
            <summary>
            Metadata associated with a 2-child tree node.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Metanode.LocalCostChange">
            <summary>
            Cached change in cost of the tree starting at this node since the previous frame.
            The local cost change is unioned with the refine flags. They're never used simultaneously.
            This will be overwritten right after use, so don't expect anything meaningful here outside of refinement scheduling's scope.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.TreeRay">
            <summary>
            Ray representation designed for quicker intersection against axis aligned bounding boxes.
            </summary>
        </member>
        <member name="P:BepuPhysics.Trees.RaySource.RayCount">
            <summary>
            Gets the number of rays in the batch.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.RaySource.GetRay(System.Int32,BepuPhysics.Trees.RayData*@,System.Single*@)">
            <summary>
            Gets pointers to the data for a ray.
            </summary>
            <param name="rayIndex">Index of the ray to grab.</param>
            <param name="ray">Pointer to the ray's origin and direction. Note that changing the ray's origin and direction mid-traversal will not change the path of the traversal, 
            but it will be visible by any future leafs impacted by this ray.</param>
            <param name="maximumT">Pointer to the maximum length of the ray in units of the ray's length.
            Decreasing this value will prevent the traversal from visiting more distant nodes later in the traversal.</param>
        </member>
        <member name="M:BepuPhysics.Trees.RaySource.GetRay(System.Int32)">
            <summary>
            Gets a reference to the data for a ray.
            </summary>
            <param name="rayIndex">Index of the ray to grab.</param>
            <returns>Returns a reference to the ray in the ray source.</returns>
        </member>
        <member name="T:BepuPhysics.Trees.RayBatcher">
            <summary>
            Reusable structure for testing large numbers of rays against trees.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.#ctor(BepuUtilities.Memory.BufferPool,System.Int32,System.Int32)">
            <summary>
            Constructs a ray batcher and initializes its backing resources.
            </summary>
            <param name="pool">Pool to pull resources from.</param>
            <param name="rayCapacity">Maximum number of rays to execute in each traversal.
            This should typically be chosen as the highest value which avoids spilling data out of L2 cache.</param>
            <param name="treeDepthForPreallocation">Tree depth to preallocate ray stack space for. If a traversal finds nodes deeper than this, a dynamic resize will be triggered.</param>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.Dispose">
            <summary>
            Disposes all the resources backing the ray batcher.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.RayBatcher.TreeRayWide">
            <summary>
            Ray representation designed for quicker intersection against axis aligned bounding boxes.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.TestRays``1(BepuPhysics.Trees.Tree@,``0@)">
            <summary>
            Tests any batched rays against the given tree.
            </summary>
            <param name="tree">Tree to test the accumulated rays against.</param>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.Add(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,System.Int32)">
            <summary>
            Adds a ray to the batcher. Returns true if the batcher has reached maximum ray capacity and needs to be reset in order to continue adding rays.
            </summary>
            <param name="origin">Origin of the ray to test against the tree.</param>
            <param name="direction">Direction of the ray to test against the tree.</param>
            <param name="maximumT">Maximum distance that the ray will travel in units of the ray's length.</param>
            <param name="id">Identifier value for the ray. Leaf tests will have access to the id.</param>
            <returns>True if the batcher is full and requires a call to ResetRays before adding any more rays, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.ResetRays">
            <summary>
            Resets the accumulated ray count to zero.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.Nodes">
            <summary>
            Buffer of nodes in the tree.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.Metanodes">
            <summary>
            Buffer of metanodes in the tree. Metanodes contain metadata that aren't read during most query operations but are useful for bookkeeping.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.Leaves">
            <summary>
            Buffer of leaves in the tree.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.NodeCount">
            <summary>
            Number of nodes in the tree.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.LeafCount">
            <summary>
            Number of leaves in the tree.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.GetBoundsPointers(System.Int32,System.Numerics.Vector3*@,System.Numerics.Vector3*@)">
            <summary>
            Gets bounds pointerse for a leaf in the tree.
            </summary>
            <param name="leafIndex">Index of the leaf in the tree.</param>
            <param name="minPointer">Pointer to the minimum bounds vector in the tree.</param>
            <param name="maxPointer">Pointer to the maximum bounds vector in the tree.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.UpdateBounds(System.Int32,System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Applies updated bounds to the given leaf index in the tree, refitting the tree to match.
            </summary>
            <param name="leafIndex">Index of the leaf in the tree to update.</param>
            <param name="min">New minimum bounds for the leaf.</param>
            <param name="max">New maximum bounds for the leaf.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.#ctor(BepuUtilities.Memory.BufferPool,System.Int32)">
            <summary>
            Constructs an empty tree.
            </summary>
            <param name="pool">Buffer pool to use to allocate resources in the tree.</param>
            <param name="initialLeafCapacity">Initial number of leaves to allocate room for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.#ctor(System.Span{System.Byte},BepuUtilities.Memory.BufferPool)">
            <summary>
            Loads a tree from a byte buffer created by the Serialize function.
            </summary>
            <param name="data">Data to load into the tree.</param>
            <param name="pool">Pool to use to create the tree.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.GetSerializedByteCount">
            <summary>
            Gets the number of bytes required to store the tree.
            </summary>
            <returns>Number of bytes required to store the tree.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Serialize(System.Span{System.Byte})">
            <summary>
            Writes a tree into a byte buffer.
            </summary>
            <param name="bytes">Buffer to hold the tree's data.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Resize(BepuUtilities.Memory.BufferPool,System.Int32)">
            <summary>
            Resizes the buffers backing the tree's nodes and leaves. Will not shrink the buffers below the size needed by the currently resident nodes and leaves.
            </summary>
            <param name="pool">Pool from which to take and return resources.</param>
            <param name="targetLeafSlotCount">The desired number of available leaf slots.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Clear">
            <summary>
            Resets the tree to a fresh post-construction state, clearing out leaves and nodes but leaving the backing resources intact.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Disposes the tree's backing resources, returning them to the Pool currently associated with the tree.
            </summary>
            <param name="pool">Pool to return resources to.</param>
            <remarks>Disposed trees can be reused if EnsureCapacity or Resize is used to rehydrate them.</remarks>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Equals(BepuPhysics.Trees.Tree@,BepuPhysics.Trees.Tree@)">
            <summary>
            Tests if two tree references point to the same data.
            </summary>
            <param name="a">First tree to compare.</param>
            <param name="b">Second tree to compare.</param>
            <returns>True if the two trees have the same nodes and node count, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MergeLeafNodes(BepuUtilities.BoundingBox@,System.Int32,System.Int32,BepuUtilities.BoundingBox@)">
            <summary>
            Merges a new leaf node with an existing leaf node, producing a new internal node referencing both leaves, and then returns the index of the leaf node.
            </summary>
            <param name="newLeafBounds">Bounding box of the leaf being added.</param>
            <param name="parentIndex">Index of the parent node that the existing leaf belongs to.</param>
            <param name="indexInParent">Index of the child wtihin the parent node that the existing leaf belongs to.</param>
            <param name="merged">Bounding box holding both the new and existing leaves.</param>
            <returns>Index of the leaf </returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Add(BepuUtilities.BoundingBox,BepuUtilities.Memory.BufferPool)">
            <summary>
            Adds a leaf to the tree with the given bounding box and returns the index of the added leaf.
            </summary>
            <param name="bounds">Extents of the leaf bounds.</param>
            <param name="pool">Resource pool to use if resizing is required.</param>
            <returns>Index of the leaf allocated in the tree's leaf array.</returns>
        </member>
        <member name="T:BepuPhysics.Trees.Tree.BinnedBuildWorkerContext">
            <summary>
            Stores resources required by a worker to dispatch and manage multithreaded work.
            </summary>
            <remarks>
            Some of the resources cached here are technically redundant with the storage used for workers and ends up involving an extra bin scan on a multithreaded test,
            but the cost associated with doing so is... low. The complexity cost of trying to use the memory allocated for workers is not low.
            </remarks>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinnedBuildWorkerContext.BinBoundingBoxes">
            <summary>
            Bins associated with this worker for the duration of a node. This allocation will persist across the build.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinnedBuildWorkerContext.BinCentroidBoundingBoxes">
            <summary>
            Centroid bound bins associated with this worker for the duration of a node. This allocation will persist across the build.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinnedBuildWorkerContext.BinBoundingBoxesScan">
            <summary>
            Bins associated with this worker for use in the SAH scan. This allocation will persist across the build.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinnedBuildWorkerContext.BinCentroidBoundingBoxesScan">
            <summary>
            Centroid bound bins associated with this worker for use in the SAH scan. This allocation will persist across the build.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinnedBuildWorkerContext.BinLeafCounts">
            <summary>
            Bin leaf counts associated with this worker for the duration of a node. This allocation will persist across the build.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.MultithreadBinnedBuildContext.OriginalSubtreeCount">
            <summary>
            The number of subtrees present at the root of the build.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.MultithreadBinnedBuildContext.TopLevelTargetTaskCount">
            <summary>
            The target number of tasks that would be used for the root node. Later nodes will tend to target smaller numbers of tasks on the assumption that other parallel nodes will provide enough work to fill in the gaps.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.CentroidPrepassTaskContext.PrepassWorkers">
            <summary>
            Stores per-worker prepass bounds accumulated over multiple tasks. If there are less tasks than workers, then only the lower contiguous region of these bounds are used.
            This allocation is ephemeral; it is allocated from the current worker when needed. 
            Note that the allocation occurs on the loop dispatching thread: the workers that help with the loop do not have to allocate anything themselves.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.CentroidPrepassTaskContext.Subtrees">
            <summary>
            Buffer containing all subtrees in the node.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinSubtreesTaskContext.BinSubtreesWorkers">
            <summary>
            Bins associated with any workers that end up contributing to this worker's dispatch of a binning loop. If there are less tasks than workers, then only the lower contiguous region of these bounds are used.
            This allocation is ephemeral; it is allocated from the current worker when needed. 
            Note that the allocation occurs on the loop dispatching thread: the workers that help with the loop do not have to allocate anything themselves.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinSubtreesTaskContext.WorkerHelpedWithBinning">
            <summary>
            Whether a given worker contributed to the subtree binning process. If this worker did not contribute, there's no reason to merge its bins.
            This allocation is ephemeral; it is allocated from the current worker when needed. 
            Note that the allocation occurs on the loop dispatching thread: the workers that help with the loop do not have to allocate anything themselves.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinSubtreesTaskContext.Subtrees">
            <summary>
            Buffer containing all subtrees in this node.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.BinSubtreesTaskContext.BinIndices">
            <summary>
            Stores the bin indices of all subtrees in the node.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.Tree.DoWriteBinIndices">
            <summary>
            Marks a <see cref="M:BepuPhysics.Trees.Tree.BinSubtrees``1(System.Numerics.Vector4,System.Boolean,System.Boolean,System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32,System.Numerics.Vector4,System.Numerics.Vector4,BepuUtilities.Memory.Buffer{BepuPhysics.Trees.NodeChild},BepuUtilities.Memory.Buffer{BepuUtilities.BoundingBox4},BepuUtilities.Memory.Buffer{BepuUtilities.BoundingBox4},BepuUtilities.Memory.Buffer{System.Int32},BepuUtilities.Memory.Buffer{System.Byte})"/> call as requiring the bin indices to be written to the binIndices buffer.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.Tree.DoNotWriteBinIndices">
            <summary>
            Marks a <see cref="M:BepuPhysics.Trees.Tree.BinSubtrees``1(System.Numerics.Vector4,System.Boolean,System.Boolean,System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32,System.Numerics.Vector4,System.Numerics.Vector4,BepuUtilities.Memory.Buffer{BepuPhysics.Trees.NodeChild},BepuUtilities.Memory.Buffer{BepuUtilities.BoundingBox4},BepuUtilities.Memory.Buffer{BepuUtilities.BoundingBox4},BepuUtilities.Memory.Buffer{System.Int32},BepuUtilities.Memory.Buffer{System.Byte})"/> call as not allowing the bin indices to be written to the binIndices buffer.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.PartitionTaskContext.Subtrees">
            <summary>
            Buffer containing all subtrees in this node.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.PartitionTaskContext.SubtreesNext">
            <summary>
            Buffer that will contain the partitioned subtrees pulled from <see cref="F:BepuPhysics.Trees.Tree.PartitionTaskContext.Subtrees"/>.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Tree.PartitionTaskContext.BinIndices">
            <summary>
            Buffer containing bin indices for all subtrees in the node (encoded with one byte per subtree).
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.BinnedBuilderInternal(BepuUtilities.Memory.Buffer{BepuPhysics.Trees.NodeChild},BepuUtilities.Memory.Buffer{BepuPhysics.Trees.NodeChild},BepuUtilities.Memory.Buffer{BepuPhysics.Trees.Node},BepuUtilities.Memory.Buffer{BepuPhysics.Trees.Metanode},BepuUtilities.Memory.Buffer{BepuPhysics.Trees.Leaf},BepuUtilities.Memory.Buffer{System.Byte},BepuUtilities.IThreadDispatcher,BepuUtilities.TestLinkedTaskStack.LinkedTaskStack*,System.Int32,BepuUtilities.Memory.BufferPool,System.Int32,System.Int32,System.Single,System.Int32)">
            <summary>
            Runs a binned build across the input <see cref="T:BepuPhysics.Trees.NodeChild"/> buffer.
            </summary>
            <param name="subtrees">Subtrees (either leaves or nodes) to run the builder over. The builder may make in-place modifications to the input buffer; the input buffer should not be assumed to be in a valid state after the builder runs.</param>
            <param name="subtreesPong">A parallel buffer to subtrees which is used as a scratch buffer during execution. If a default initialized buffer is provided, a slower sequential in-place fallback will be used.</param>
            <param name="nodes">Buffer holding the nodes created by the build process.<para/>
            Nodes are created in a depth first ordering with respect to the input buffer.</param>
            <param name="metanodes">Buffer holding the metanodes created by the build process.<para/>
            Metanodes, like nodes, are created in a depth first ordering with respect to the input buffer.
            Metanodes are in the same order and in the same slots; they simply contain data about nodes that most traversals don't need to know about.</param>
            <param name="leaves">Buffer holding the leaf references created by the build process.<para/>
            The indices written by the build process are those defined in the inputs; any <see cref="F:BepuPhysics.Trees.NodeChild.Index"/> that is negative is encoded according to <see cref="M:BepuPhysics.Trees.Tree.Encode(System.Int32)"/> and points into the leaf buffer.</param>
            <param name="binIndices">Buffer to be used for caching bin indices during execution. If subtreesPong is defined, binIndices must also be defined, and vice versa.</param>
            <param name="dispatcher">Thread dispatcher used to accelerate the build process.</param>
            <param name="taskStackPointer">Task stack used to accelerate the build process. Can be null; one will be created if not provided.</param>
            <param name="workerCount">Number of workers to be used in the builder.</param>
            <param name="pool">Buffer pool used to preallocate temporary resources for building.</param>
            <param name="minimumBinCount">Minimum number of bins the builder should use per node.</param>
            <param name="maximumBinCount">Maximum number of bins the builder should use per node. Must be no higher than 255.</param>
            <param name="leafToBinMultiplier">Multiplier to apply to the subtree count within a node to decide the bin count. Resulting value will then be clamped by the minimum/maximum bin counts.</param>
            <param name="microsweepThreshold">Threshold at or under which the binned builder resorts to local counting sort sweeps.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.BinnedBuilder(BepuUtilities.Memory.Buffer{BepuPhysics.Trees.NodeChild},BepuUtilities.Memory.Buffer{BepuPhysics.Trees.Node},BepuUtilities.Memory.Buffer{BepuPhysics.Trees.Metanode},BepuUtilities.Memory.Buffer{BepuPhysics.Trees.Leaf},BepuUtilities.Memory.BufferPool,System.Int32,System.Int32,System.Int32,System.Single,System.Int32)">
            <summary>
            Runs a binned build across the subtrees buffer.
            </summary>
            <param name="subtrees">Subtrees (either leaves or nodes) to run the builder over. The builder may make in-place modifications to the input buffer; the input buffer should not be assumed to be in a valid state after the builder runs.</param>
            <param name="nodes">Buffer holding the nodes created by the build process.<para/>
            Nodes are created in a depth first ordering with respect to the input buffer.</param>
            <param name="metanodes">Buffer holding the metanodes created by the build process.<para/>
            Metanodes, like nodes, are created in a depth first ordering with respect to the input buffer.
            Metanodes are in the same order and in the same slots; they simply contain data about nodes that most traversals don't need to know about.</param>
            <param name="leaves">Buffer holding the leaf references created by the build process.<para/>
            The indices written by the build process are those defined in the inputs; any <see cref="F:BepuPhysics.Trees.NodeChild.Index"/> that is negative is encoded according to <see cref="M:BepuPhysics.Trees.Tree.Encode(System.Int32)"/> and points into the leaf buffer.</param>
            <param name="pool">Buffer pool used to preallocate a pingpong buffer if the number of subtrees exceeds maximumSubtreeStackAllocationCount. If null, stack allocation or a slower in-place partitioning will be used.</param>
            <param name="maximumSubtreeStackAllocationCount">Maximum number of subtrees to try putting on the stack for the binned builder's pong buffers.<para/>
            Subtree counts larger than this threshold will either resort to a buffer pool allocation (if available) or slower in-place partition operations.</param>
            <param name="minimumBinCount">Minimum number of bins the builder should use per node.</param>
            <param name="maximumBinCount">Maximum number of bins the builder should use per node.</param>
            <param name="leafToBinMultiplier">Multiplier to apply to the subtree count within a node to decide the bin count. Resulting value will then be clamped by the minimum/maximum bin counts.</param>
            <param name="microsweepThreshold">Threshold at or under which the binned builder resorts to local counting sort sweeps.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.TrySwapNodesThreadSafe(System.Int32@,System.Int32@)">
            <summary>
            Attempts to swap two nodes. Aborts without changing memory if the swap is contested by another thread.
            </summary>
            <remarks>Uses Node.RefineFlag as a lock-keeping mechanism. All refine flags should be cleared to 0 before a multithreaded processing stage that performs swaps.</remarks>
            <param name="aIndex">First node of the swap pair.</param>
            <param name="bIndex">Second node of the swap pair.</param>
            <returns>True if the nodes were swapped, false if the swap was contested.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.IncrementalCacheOptimizeThreadSafe(System.Int32)">
            <summary>
            Moves the children if the specified node into the correct relative position in memory.
            Takes care to avoid contested moves in multithreaded contexts. May not successfully
            complete all desired moves if contested.
            </summary>
            <param name="nodeIndex">Node whose children should be optimized.</param>
            <returns>True if no other threads contested the optimization or if the node is already optimized, otherwise false.
            Will return true even if not all nodes are optimized if the reason was a target index outside of the node list bounds.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.CacheOptimize(System.Int32)">
            <summary>
            Begins a cache optimization at the given node and proceeds all the way to the bottom of the tree.
            Requires that the targeted node is already at the global optimum position.
            </summary>
            <param name="nodeIndex">Node to begin the optimization process at.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedIntertreeTest`1.PrepareJobs(BepuPhysics.Trees.Tree@,BepuPhysics.Trees.Tree@,`0[],System.Int32)">
            <summary>
            Prepares the jobs associated with a self test. Must be called before a dispatch over PairTest.
            </summary>
            <param name="overlapHandlers">Callbacks used to handle individual overlaps detected by the self test.</param>
            <param name="threadCount">Number of threads to prepare jobs for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedIntertreeTest`1.CompleteTest">
            <summary>
            Cleans up after a multithreaded self test.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedIntertreeTest`1.PairTest(System.Int32)">
            <summary>
            Executes a single worker of the multithreaded self test.
            </summary>
            <param name="workerIndex">Index of the worker executing this set of tests.</param>
        </member>
        <member name="T:BepuPhysics.Trees.Tree.RefitAndRefineMultithreadedContext">
            <summary>
            Caches input and output for the multithreaded execution of a tree's refit and refinement operations.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.RefitForNodeBoundsChange(System.Int32)">
            <summary>
            Refits the bounding box of every parent of the node recursively to the root.
            </summary>
            <param name="nodeIndex">Node to propagate a node change for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Refit">
            <summary>
            Updates the bounding boxes of all internal nodes in the tree.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Refit2">
            <summary>
            Updates the bounding boxes of all internal nodes in the tree.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.RemoveAt(System.Int32)">
            <summary>
            Removes a leaf at an index. If the index is not at the end of the leaf list, the last leaf is swapped into the removed location.
            </summary>
            <param name="leafIndex">Index of the leaf to remove.</param>
            <returns>Former index of the leaf that was moved into the removed leaf's slot, if any.
            If leafIndex pointed at the last slot in the list, then this returns -1 since no leaf was moved.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedSelfTest`1.PrepareJobs(BepuPhysics.Trees.Tree@,`0[],System.Int32)">
            <summary>
            Prepares the jobs associated with a self test. Must be called before a dispatch over PairTest.
            </summary>
            <param name="tree">Tree to test against itself.</param>
            <param name="overlapHandlers">Callbacks used to handle individual overlaps detected by the self test.</param>
            <param name="threadCount">Number of threads to prepare jobs for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedSelfTest`1.CompleteSelfTest">
            <summary>
            Cleans up after a multithreaded self test.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedSelfTest`1.PairTest(System.Int32)">
            <summary>
            Executes a single worker of the multithreaded self test.
            </summary>
            <param name="workerIndex">Index of the worker executing this set of tests.</param>
        </member>
    </members>
</doc>
