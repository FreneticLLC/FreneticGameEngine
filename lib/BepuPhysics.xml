<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BepuPhysics</name>
    </assembly>
    <members>
        <member name="T:BepuPhysics.BatchCompressor">
            <summary>
            Handles the movement of constraints from higher indexed batches into lower indexed batches to avoid accumulating a bunch of unnecessary ConstraintBatches.
            </summary>
        </member>
        <member name="P:BepuPhysics.BatchCompressor.TargetCandidateFraction">
            <summary>
            Gets or sets the desired number of candidates to analyze as a fraction of the total number of constraints.
            </summary>
        </member>
        <member name="P:BepuPhysics.BatchCompressor.MaximumCompressionFraction">
            <summary>
            Gets or sets the maximum number of constraint moves that can occur in a single execution of Compress as a fraction of the total number of constraints.
            </summary>       
        </member>
        <member name="F:BepuPhysics.BatchCompressor.nextBatchIndex">
            <summary>
            Index of the constraint batch to optimize.
            </summary>
        </member>
        <member name="M:BepuPhysics.BatchCompressor.Compress(BepuUtilities.Memory.BufferPool,BepuUtilities.IThreadDispatcher,System.Boolean)">
            <summary>
            Incrementally finds and applies a set of compressions to apply to the constraints in the solver's batches.
            Constraints in higher index batches try to move to lower index batches whenever possible.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyMemoryLocation.SetIndex">
            <summary>
            Index of the set owning the body reference. If the island index is 0, the body is active.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyMemoryLocation.Index">
            <summary>
            Index of the body within its owning set. If the body is active (and so the Island index is -1), this is an index into the Bodies data arrays. 
            If it is nonnegative, it is an index into the inactive island 
            </summary>
        </member>
        <member name="T:BepuPhysics.Bodies">
            <summary>
            Collection of all allocated bodies.
            </summary>
        </member>
        <member name="F:BepuPhysics.Bodies.HandleToLocation">
            <summary>
            Remaps a body handle integer value to the actual array index of the body.
            The backing array index may change in response to cache optimization.
            </summary>
        </member>
        <member name="F:BepuPhysics.Bodies.Sets">
            <summary>
            The set of existing bodies. The slot at index 0 contains all active bodies. Later slots, if allocated, contain the bodies associated with inactive islands.
            Note that this buffer does not necessarily contain contiguous elements. When a set is removed, a gap remains.
            </summary>
        </member>
        <member name="P:BepuPhysics.Bodies.ActiveSet">
            <summary>
            Gets a reference to the active set, stored in the index 0 of the Sets buffer.
            </summary>
            <returns>Reference to the active body set.</returns>
        </member>
        <member name="F:BepuPhysics.Bodies.Inertias">
            <summary>
            The world transformed inertias of active bodies as of the last update. Note that this is not automatically updated for direct orientation changes or for body memory moves.
            It is only updated once during the frame. It should be treated as ephemeral information.
            </summary>
        </member>
        <member name="P:BepuPhysics.Bodies.MinimumConstraintCapacityPerBody">
            <summary>
            Gets or sets the minimum constraint capacity for each body. Future resizes or allocations will obey this minimum, but changing this does not immediately resize existing lists.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.#ctor(BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.Shapes,BepuPhysics.CollisionDetection.BroadPhase,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a new bodies collection. Initialize must be called for the instance to be ready for use.
            </summary>
            <param name="pool">Pool for the collection to pull persistent allocations from.</param>
            <param name="shapes">Shapes referenced by the collection's bodies.</param>
            <param name="broadPhase">Broad phase containing the body collidables.</param>
            <param name="initialBodyCapacity">Initial number of bodies to allocate space for in the active set.</param>
            <param name="initialIslandCapacity">Initial number of islands to allocate space for in the Sets buffer.</param>
            <param name="initialConstraintCapacityPerBody">Expected number of constraint references per body to allocate space for.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.Initialize(BepuPhysics.Solver,BepuPhysics.IslandAwakener,BepuPhysics.IslandSleeper)">
            <summary>
            Initializes the bodies set. Used to complete bidirectional dependencies.
            </summary>
            <param name="solver">Solver responsible for the constraints connected to the collection's bodies.</param>
            <param name="awakener">Island awakener to use when bodies undergo transitions requiring that they exist in the active set.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.UpdateBounds(BepuPhysics.BodyHandle)">
            <summary>
            Updates the bounds held within the broad phase for the body's current state. Does not expand the bounding box by velocity. If there is no shape associated with the body, this does nothing.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.Add(BepuPhysics.BodyDescription@)">
            <summary>
            Adds a new active body to the simulation.
            </summary>
            <param name="description">Description of the body to add.</param>
            <returns>Handle of the created body.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.RemoveAt(System.Int32)">
            <summary>
            Removes an active body by its index. Any constraints connected to this body will be removed. Assumes that the input location is valid.
            </summary>
            <param name="activeBodyIndex">Index of the active body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.Remove(BepuPhysics.BodyHandle)">
            <summary>
            Removes a body from the set by its handle. If the body is inactive, all bodies in its island will be forced active.
            </summary>
            <param name="handle">Handle of the body to remove.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.AddConstraint(System.Int32,BepuPhysics.ConstraintHandle,System.Int32)">
            <summary>
            Adds a constraint to an active body's constraint list.
            </summary>
            <param name="bodyIndex">Index of the body to add the constraint to.</param>
            <param name="constraintHandle">Handle of the constraint to add.</param>
            <param name="indexInConstraint">Index of the body in the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.RemoveConstraintReference(System.Int32,BepuPhysics.ConstraintHandle)">
            <summary>
            Removes a constraint from an active body's constraint list.
            </summary>
            <param name="bodyIndex">Index of the active body.</param>
            <param name="constraintHandle">Handle of the constraint to remove.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.IsKinematic(BepuPhysics.BodyInertia@)">
            <summary>
            Gets whether the inertia matches that of a kinematic body (that is, all inverse mass and inertia components are zero).
            </summary>
            <param name="inertia">Body inertia to analyze.</param>
            <returns>True if all components of inverse mass and inertia are zero, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.HasLockedInertia(BepuUtilities.Symmetric3x3@)">
            <summary>
            Gets whether the angular inertia matches that of a kinematic body (that is, all inverse inertia tensor components are zero).
            </summary>
            <param name="inertia">Body inertia to analyze.</param>
            <returns>True if all components of inverse mass and inertia are zero, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.SetLocalInertia(BepuPhysics.BodyHandle,BepuPhysics.BodyInertia@)">
            <summary>
            Changes the local mass and inertia tensor associated with a body. Properly handles the transition between kinematic and dynamic.
            If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed.
            Wakes up the body.
            </summary>
            <param name="handle">Handle of the body whose inertia should change.</param>
            <param name="localInertia">New local inertia for the body.</param>
            <remarks>
            This function is only necessary when the inertia change could potentially result in a transition between dynamic and kinematic states.
            If it is guaranteed to be dynamic before and after the change, the inertia can be directly modified without issue.
            </remarks>
        </member>
        <member name="M:BepuPhysics.Bodies.SetShape(BepuPhysics.BodyHandle,BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a body. Properly handles the transition between shapeless and shapeful. If the body is inactive, it will be forced awake.
            Updates the bounds of the body in the broad phase.
            </summary>
            <param name="handle">Handle of the body to change the shape of.</param>
            <param name="newShape">Index of the new shape to use for the body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ApplyDescription(BepuPhysics.BodyHandle,BepuPhysics.BodyDescription@)">
            <summary>
            Applies a description to a body. Properly handles any transitions between dynamic and kinematic and between shapeless and shapeful.
            If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed. Wakes up the body.
            Updates the bounds of the body in the broad phase.
            </summary>
            <param name="handle">Handle of the body to receive the description.</param>
            <param name="description">Description to apply to the body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GetDescription(BepuPhysics.BodyHandle,BepuPhysics.BodyDescription@)">
            <summary>
            Gets the description of a body by handle.
            </summary>
            <param name="handle">Handle of the body to look up.</param>
            <param name="description">Description of the body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GetBodyReference(BepuPhysics.BodyHandle)">
            <summary>
            Gets a reference to a body by its handle.
            </summary>
            <param name="handle">Handle of the body to grab a reference of.</param>
            <returns>Reference to the desired body.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.BodyExists(BepuPhysics.BodyHandle)">
            <summary>
            Checks whether a body handle is currently registered with the bodies set.
            </summary>
            <param name="bodyHandle">Handle to check for.</param>
            <returns>True if the handle exists in the collection, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherInertia(System.Numerics.Vector{System.Int32}@,System.Int32,BepuPhysics.BodyInertias@)">
            <summary>
            Gathers inertia for one body bundle into an AOSOA bundle.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of bodies in the bundle.</param>
            <param name="inertiaA">Gathered inertia of body A.</param>
            <param name="inertiaB">Gathered inertia of body B.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherInertia(BepuPhysics.Constraints.TwoBodyReferences@,System.Int32,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@)">
            <summary>
            Gathers inertia for two body bundles into AOSOA bundles.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of bodies in the bundle.</param>
            <param name="inertiaA">Gathered inertia of body A.</param>
            <param name="inertiaB">Gathered inertia of body B.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherInertia(BepuPhysics.Constraints.ThreeBodyReferences@,System.Int32,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@)">
            <summary>
            Gathers inertia for three body bundles into AOSOA bundles.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of bodies in the bundle.</param>
            <param name="inertiaA">Gathered inertia of body A.</param>
            <param name="inertiaB">Gathered inertia of body B.</param>
            <param name="inertiaC">Gathered inertia of body C.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherInertia(BepuPhysics.Constraints.FourBodyReferences@,System.Int32,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@)">
            <summary>
            Gathers inertia for four body bundles into AOSOA bundles.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of bodies in the bundle.</param>
            <param name="inertiaA">Gathered inertia of body A.</param>
            <param name="inertiaB">Gathered inertia of body B.</param>
            <param name="inertiaC">Gathered inertia of body C.</param>
            <param name="inertiaD">Gathered inertia of body D.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherOrientation(BepuPhysics.Constraints.TwoBodyReferences@,System.Int32,BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Gathers orientations for two body bundles into AOSOA bundles.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="orientationA">Gathered orientation of body A.</param>
            <param name="orientationB">Gathered orientation of body B.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherOrientation(System.Numerics.Vector{System.Int32}@,System.Int32,BepuUtilities.QuaternionWide@)">
            <summary>
            Gathers orientations for one body bundles into AOSOA bundles.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="orientation">Gathered orientation of bodies in the bundle.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherPose(System.Numerics.Vector{System.Int32}@,System.Int32,BepuUtilities.Vector3Wide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Gathers pose information for a body bundle into an AOSOA bundle.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="position">Gathered absolute position of the body.</param>
            <param name="orientation">Gathered orientation of the body.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherPose(BepuPhysics.Constraints.TwoBodyReferences@,System.Int32,BepuUtilities.Vector3Wide@,BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Gathers orientations and relative positions for a two body bundle into an AOSOA bundle.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="offsetB">Gathered offsets from body A to body B.</param>
            <param name="orientationA">Gathered orientation of body A.</param>
            <param name="orientationB">Gathered orientation of body B.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherOffsets(BepuPhysics.Constraints.TwoBodyReferences@,System.Int32,BepuUtilities.Vector3Wide@)">
            <summary>
            Gathers relative positions for a two body bundle into an AOSOA bundle.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="ab">Gathered offset from body A to of body B.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherOffsets(BepuPhysics.Constraints.ThreeBodyReferences@,System.Int32,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Gathers relative positions for a three body bundle into an AOSOA bundle.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="ab">Gathered offset from body A to of body B.</param>
            <param name="ac">Gathered offset from body A to of body C.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherOffsets(BepuPhysics.Constraints.FourBodyReferences@,System.Int32,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Gathers relative positions for a four body bundle into an AOSOA bundle.
            </summary>
            <param name="references">Active body indices being gathered.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="ab">Gathered offset from body A to of body B.</param>
            <param name="ac">Gathered offset from body A to of body C.</param>
            <param name="ad">Gathered offset from body A to of body D.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherVelocities(BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,System.Numerics.Vector{System.Int32}@,System.Int32,BepuPhysics.BodyVelocities@)">
            <summary>
            Gathers velocities for one body bundle and stores it into a velocity bundle.
            </summary>
            <param name="references">Active set indices of the bodies to gather velocity data for.</param>
            <param name="count">Number of bodies in the bundle.</param>
            <param name="velocities">Gathered velocities.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherVelocities(BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,BepuPhysics.Constraints.TwoBodyReferences@,System.Int32,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@)">
            <summary>
            Gathers velocities for two body bundles and stores it into velocity bundles.
            </summary>
            <param name="references">Active set indices of the bodies to gather velocity data for.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="velocitiesA">Gathered velocities of A bodies.</param>
            <param name="velocitiesB">Gathered velocities of B bodies.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherVelocities(BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,BepuPhysics.Constraints.ThreeBodyReferences@,System.Int32,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@)">
            <summary>
            Gathers velocities for three body bundles and stores it into velocity bundles.
            </summary>
            <param name="references">Active set indices of the bodies to gather velocity data for.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="velocitiesA">Gathered velocities of A bodies.</param>
            <param name="velocitiesB">Gathered velocities of B bodies.</param>
            <param name="velocitiesC">Gathered velocities of C bodies.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.GatherVelocities(BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,BepuPhysics.Constraints.FourBodyReferences@,System.Int32,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@)">
            <summary>
            Gathers velocities for four body bundles and stores it into velocity bundles.
            </summary>
            <param name="references">Active set indices of the bodies to gather velocity data for.</param>
            <param name="count">Number of body pairs in the bundle.</param>
            <param name="velocitiesA">Gathered velocities of A bodies.</param>
            <param name="velocitiesB">Gathered velocities of B bodies.</param>
            <param name="velocitiesC">Gathered velocities of C bodies.</param>
            <param name="velocitiesD">Gathered velocities of D bodies.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ScatterVelocities(BepuPhysics.BodyVelocities@,BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,System.Numerics.Vector{System.Int32}@,System.Int32)">
            <summary>
            Scatters velocities for one body bundle into the active body set.
            </summary>
            <param name="sourceVelocities">Velocities of body bundle A to scatter.</param>
            <param name="references">Active set indices of the bodies to scatter velocity data to.</param>
            <param name="count">Number of body pairs in the bundle.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ScatterVelocities(BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,BepuPhysics.Constraints.TwoBodyReferences@,System.Int32)">
            <summary>
            Scatters velocities for two body bundles into the active body set.
            </summary>
            <param name="sourceVelocitiesA">Velocities of body bundle A to scatter.</param>
            <param name="sourceVelocitiesA">Velocities of body bundle B to scatter.</param>
            <param name="references">Active set indices of the bodies to scatter velocity data to.</param>
            <param name="count">Number of body pairs in the bundle.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ScatterVelocities(BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,BepuPhysics.Constraints.ThreeBodyReferences@,System.Int32)">
            <summary>
            Scatters velocities for three body bundles into the active body set.
            </summary>
            <param name="sourceVelocitiesA">Velocities of body bundle A to scatter.</param>
            <param name="sourceVelocitiesB">Velocities of body bundle B to scatter.</param>
            <param name="sourceVelocitiesC">Velocities of body bundle A to scatter.</param>
            <param name="references">Active set indices of the bodies to scatter velocity data to.</param>
            <param name="count">Number of body pairs in the bundle.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ScatterVelocities(BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@,BepuUtilities.Memory.Buffer{BepuPhysics.BodyVelocity}@,BepuPhysics.Constraints.FourBodyReferences@,System.Int32)">
            <summary>
            Scatters velocities for four body bundles into the active body set.
            </summary>
            <param name="sourceVelocitiesA">Velocities of body bundle A to scatter.</param>
            <param name="sourceVelocitiesB">Velocities of body bundle B to scatter.</param>
            <param name="sourceVelocitiesC">Velocities of body bundle A to scatter.</param>
            <param name="sourceVelocitiesD">Velocities of body bundle B to scatter.</param>
            <param name="references">Active set indices of the bodies to scatter velocity data to.</param>
            <param name="count">Number of body pairs in the bundle.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.EnumerateConnectedBodyIndices``1(System.Int32,``0@)">
            <summary>
            Enumerates all the bodies connected to a given active body.
            Bodies which are connected by more than one constraint will be reported multiple times.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to execute on each connected body.</typeparam>
            <param name="activeBodyIndex">Index of the active body to enumerate the connections of. This body will not appear in the set of enumerated bodies, even if it is connected to itself somehow.</param>
            <param name="enumerator">Enumerator instance to run on each connected body.</param>
            <param name="solver">Solver from which to pull constraint body references.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.EnumerateConnectedBodies``1(BepuPhysics.BodyHandle,``0@)">
            <summary>
            Enumerates all the bodies connected to a given body.
            Bodies which are connected by more than one constraint will be reported multiple times.
            </summary>
            <typeparam name="TEnumerator">Type of the enumerator to execute on each connected body.</typeparam>
            <param name="bodyHandle">Handle of the body to enumerate the connections of. This body will not appear in the set of enumerated bodies, even if it is connected to itself somehow.</param>
            <param name="enumerator">Enumerator instance to run on each connected body.</param>
            <param name="solver">Solver from which to pull constraint body references.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.Clear">
            <summary>
            Clears all bodies from all sets without releasing any memory that wouldn't be released by a sequence of regular removals.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.ResizeInertias(System.Int32)">
            <summary>
            Reallocates the inertias buffer for the target capacity. Will not shrink below the size of the current active set.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.EnsureInertiasCapacity(System.Int32)">
            <summary>
            Guarantees that the inertias capacity is sufficient for the given capacity.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.Resize(System.Int32)">
            <summary>
            Resizes the allocated spans for active body data. Note that this is conservative; it will never orphan existing objects.
            </summary>
            <param name="capacity">Target body data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.ResizeConstraintListCapacities">
            <summary>
            Resizes all active body constraint lists to meet the MinimumConstraintCapacityPerBody. Inactive bodies are untouched.
            Resizes are guaranteed to never shrink a list below the current count.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.EnsureCapacity(System.Int32)">
            <summary>
            Increases the size of active body buffers if needed to hold the target capacity.
            </summary>
            <param name="capacity">Target data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Bodies.EnsureConstraintListCapacities">
            <summary>
            Ensures all active body constraint lists can hold at least MinimumConstraintCapacityPerBody constraints. Inactive bodies are untouched.
            </summary>
        </member>
        <member name="M:BepuPhysics.Bodies.Dispose">
            <summary>
            Returns all body resources to the pool used to create them.
            </summary>
            <remarks>The object can be reused if it is reinitialized by using EnsureCapacity or Resize.</remarks>
        </member>
        <member name="F:BepuPhysics.BodyActivityDescription.SleepThreshold">
            <summary>
            Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivityDescription.MinimumTimestepCountUnderThreshold">
            <summary>
            The number of time steps that the body must be under the sleep threshold before the body becomes a sleep candidate.
            Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyActivityDescription.#ctor(System.Single,System.Byte)">
            <summary>
            Creates a body activity description.
            </summary>
            <param name="sleepThreshold">Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).</param>
            <param name="minimumTimestepCountUnderThreshold">The number of time steps that the body must be under the sleep threshold before the body becomes a sleep candidate.
            Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.</param>
        </member>
        <member name="M:BepuPhysics.BodyDescription.GetDefaultSpeculativeMargin``1(``0@)">
            <summary>
            Computes a decent default speculative margin for a shape based on its minimum and maximum radii.
            </summary>
            <typeparam name="TShape">Type of the shape to compute a speculative margin for.</typeparam>
            <param name="shape">Shape to compute a speculative margin for.</param>
            <returns>Speculative margin for the given shape.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.GetDefaultActivity``1(``0@)">
            <summary>
            Computes a decent default activity description for a shape.
            </summary>
            <typeparam name="TShape">Type of the shape to create an activity description for.</typeparam>
            <param name="shape">Shape to create an activity description for.</param>
            <returns>Default activity description for the given shape.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateDynamic(BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,BepuPhysics.BodyInertia@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a dynamic body description.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="inertia">Local inertia of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateDynamic(BepuPhysics.RigidPose@,BepuPhysics.BodyInertia@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a dynamic body description with zero initial velocity.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="inertia">Local inertia of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateDynamic(System.Numerics.Vector3@,BepuPhysics.BodyVelocity@,BepuPhysics.BodyInertia@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a dynamic body description with identity orientation.
            </summary>
            <param name="position">Position of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="inertia">Local inertia of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateDynamic(System.Numerics.Vector3@,BepuPhysics.BodyInertia@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a dynamic body description with zero initial velocity and identity orientation.
            </summary>
            <param name="position">Position of the body.</param>
            <param name="inertia">Local inertia of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexDynamic``1(BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,System.Single,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a dynamic body description with collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="mass">Mass of the body. The inertia tensor will be calculated based on this mass and the shape.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexDynamic``1(System.Numerics.Vector3@,BepuPhysics.BodyVelocity@,System.Single,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a dynamic body description with identity orientation and collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="position">Position of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="mass">Mass of the body. The inertia tensor will be calculated based on this mass and the shape.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexDynamic``1(BepuPhysics.RigidPose@,System.Single,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a dynamic body description with zero initial velocity and collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="mass">Mass of the body. The inertia tensor will be calculated based on this mass and the shape.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexDynamic``1(System.Numerics.Vector3@,System.Single,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a dynamic body description with zero initial velocity, identity orientation, and collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="position">Position of the body.</param>
            <param name="mass">Mass of the body. The inertia tensor will be calculated based on this mass and the shape.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateKinematic(BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a kinematic body description.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateKinematic(BepuPhysics.RigidPose@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a kinematic body description with zero initial velocity.
            </summary>
            <param name="pose">Pose of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateKinematic(System.Numerics.Vector3@,BepuPhysics.BodyVelocity@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a kinematic body description with identity orientation.
            </summary>
            <param name="position">Position of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateKinematic(System.Numerics.Vector3@,BepuPhysics.Collidables.CollidableDescription@,BepuPhysics.BodyActivityDescription@)">
            <summary>
            Creates a kinematic body description with identity orientation and zero initial velocity.
            </summary>
            <param name="position">Position of the body.</param>
            <param name="collidable">Collidable to associate with the body.</param>
            <param name="activity">Activity settings for the body.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexKinematic``1(BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a kinematic body description with collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexKinematic``1(System.Numerics.Vector3@,BepuPhysics.BodyVelocity@,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a kinematic body description with identity orientation and collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="position">Position of the body.</param>
            <param name="velocity">Initial velocity of the body.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexKinematic``1(BepuPhysics.RigidPose@,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a kinematic body description with zero initial velocity and collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="pose">Pose of the body.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="M:BepuPhysics.BodyDescription.CreateConvexKinematic``1(System.Numerics.Vector3@,BepuPhysics.Collidables.Shapes,``0@)">
            <summary>
            Creates a kinematic body description with zero initial velocity, identity orientation, and collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set.
            </summary>
            <typeparam name="TConvexShape">Type of the shape to create a body for.</typeparam>
            <param name="position">Position of the body.</param>
            <param name="shapes">Shape collection to add the shape to.</param>
            <param name="shape">Shape to add to the shape set and to create the body from.</param>
            <returns>Constructed description for the body.</returns>
        </member>
        <member name="T:BepuPhysics.BodyLayoutOptimizer">
            <summary>
            Incrementally changes the layout of a set of bodies to minimize the cache misses associated with the solver and other systems that rely on connection following.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyLayoutOptimizer.OptimizationFraction">
            <summary>
            Gets or sets the fraction of all bodies to update each frame.
            </summary>
        </member>
        <member name="T:BepuPhysics.RigidPose">
            <summary>
            Represents a rigid transformation.
            </summary>
        </member>
        <member name="M:BepuPhysics.RigidPose.Transform(System.Numerics.Vector3@,BepuPhysics.RigidPose@,System.Numerics.Vector3@)">
            <summary>
            Transforms a vector by the rigid pose: v * pose.Orientation + pose.Position.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="pose">Pose to transform the vector with.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.TransformByInverse(System.Numerics.Vector3@,BepuPhysics.RigidPose@,System.Numerics.Vector3@)">
            <summary>
            Transforms a vector by the inverse of a rigid pose: (v - pose.Position) * pose.Orientation^-1.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="pose">Pose to invert and transform the vector with.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.Invert(BepuPhysics.RigidPose@,BepuPhysics.RigidPose@)">
            <summary>
            Inverts the rigid transformation of the pose.
            </summary>
            <param name="pose">Pose to invert.</param>
            <param name="inverse">Inverse of the pose.</param>
        </member>
        <member name="M:BepuPhysics.RigidPose.MultiplyWithoutOverlap(BepuPhysics.RigidPose@,BepuPhysics.RigidPose@,BepuPhysics.RigidPose@)">
            <summary>
            Concatenates one rigid transform with another. The resulting transform is equivalent to performing transform a followed by transform b.
            </summary>
            <param name="a">First transform to concatenate.</param>
            <param name="b">Second transform to concatenate.</param>
            <param name="result">Result of the concatenation.</param>
        </member>
        <member name="F:BepuPhysics.BodyActivity.SleepThreshold">
            <summary>
            Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).
            Setting this to a negative value guarantees the body cannot go to sleep without user action.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivity.MinimumTimestepsUnderThreshold">
            <summary>
            The number of time steps that the body must be under the sleep threshold before the body becomes a sleeping candidate.
            Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivity.TimestepsUnderThresholdCount">
            <summary>
            If the body is awake, this is the number of time steps that the body has had a velocity below the sleep threshold.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyActivity.SleepCandidate">
            <summary>
            True if this body is a candidate for being slept. If all the bodies that it is connected to by constraints are also candidates, this body may go to sleep.
            </summary>
        </member>
        <member name="T:BepuPhysics.BodyReference">
            <summary>
            Convenience structure for directly referring to a body's properties.
            </summary>
            <remarks>Note that this type makes no attempt to protect against unsafe modification of body properties, nor does modifying its properties try to wake up bodies if they are asleep.</remarks>
        </member>
        <member name="F:BepuPhysics.BodyReference.Handle">
            <summary>
            Handle of the body that this reference refers to.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyReference.Bodies">
            <summary>
            The bodies collection containing the body.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.#ctor(BepuPhysics.BodyHandle,BepuPhysics.Bodies)">
            <summary>
            Constructs a new body reference.
            </summary>
            <param name="handle">Handle of the body to refer to.</param>
            <param name="bodies">Collection containing the body.</param>
        </member>
        <member name="P:BepuPhysics.BodyReference.Exists">
            <summary>
            Gets whether the body reference exists within the body set. True if the handle maps to a valid memory location that agrees that the handle points to it, false otherwise.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.MemoryLocation">
            <summary>
            Gets a reference to the body's memory location stored in the handle to location mapping.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Awake">
            <summary>
            Gets or sets whether the body is in the active set. Setting this to true will attempt to wake the body; setting it to false will force the body and any constraint-connected bodies asleep.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Velocity">
            <summary>
            Gets a reference to the body's velocity.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Pose">
            <summary>
            Gets a reference to the body's pose.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Collidable">
            <summary>
            Gets a reference to the body's collidable.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.LocalInertia">
            <summary>
            Gets a reference to the body's local inertia.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Activity">
            <summary>
            Gets a reference to the body's activity state.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Constraints">
            <summary>
            Gets a reference to the list of the body's connected constraints.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.Kinematic">
            <summary>
            Gets whether the body is kinematic, meaning its inverse inertia and mass are all zero.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodyReference.HasLockedInertia">
            <summary>
            Gets whether the body has locked inertia, meaning its inverse inertia tensor is zero.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.BecomeKinematic">
            <summary>
            If the body is dynamic, turns the body kinematic by setting all inverse inertia and mass values to zero and activates it.
            Any constraints connected to the body that now only contain kinematic references are removed.
            If the body is kinematic, does nothing.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.SetLocalInertia(BepuPhysics.BodyInertia@)">
            <summary>
            Sets the body's local inertia to the provided inertia. Wakes up the body and correctly handles any transition between dynamic and kinematic states.
            If the body moves from dynamic to kinematic, any constraints connected to the body that now only contain kinematic references are removed.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.ComputeInverseInertia(BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes the world space inverse inertia tensor for the body based on the LocalInertia and Pose.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.GetDescription(BepuPhysics.BodyDescription@)">
            <summary>
            Gets a description of the body.
            </summary>
            <param name="description">Description of the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyDescription(BepuPhysics.BodyDescription@)">
            <summary>
            Sets a body's properties according to a description. Properly handles any transitions between dynamic and kinematic and between shapeless and shapeful.
            If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed. Wakes up the body and updates its bounds in the broad phase.
            </summary>
            <param name="description">Description of the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.SetShape(BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a body. Properly handles the transition between shapeless and shapeful. If the body is inactive, it will be forced awake. Updates the bounds of the body in the broad phase.
            </summary>
            <param name="newShape">Index of the new shape to use for the body.</param>
        </member>
        <member name="P:BepuPhysics.BodyReference.BoundingBox">
            <summary>
            Gets a copy of the body's bounding box. If the body has no shape, the bounding box has a min at float.MaxValue and a max at float.MinValue.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodyReference.GetBoundsReferencesFromBroadPhase(System.Numerics.Vector3*@,System.Numerics.Vector3*@)">
            <summary>
            Gets direct pointers to the body's bounding box minimum and maximum in the broad phase. Outputs null if the body has no shape.
            </summary>
            <param name="min">Pointer to the bounding box minimum in the broad phase. Null if the body has no shape.</param>
            <param name="max">Pointer to the bounding box maximum in the broad phase. Null if the body has no shape.</param>
            <returns>True if the body has a shape and bounds, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.BodyReference.UpdateBounds">
            <summary>
            Updates the body's bounds in the broad phase for its current state. Does not include velocity expansion. Does nothing if the body has no shape.
            </summary>
            <remarks>Can be useful if you made modifications to the body's state that you want reflected in the broad phase before the next timestep.
            For example, if you want to perform ray casts against the broad phase after moving objects around directly, their bounds must be updated or else the broad phase bounds will be out of date and the ray will likely miss.</remarks>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyImpulse(System.Numerics.Vector3@,System.Numerics.Vector3@,BepuPhysics.BodyInertia@,BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@)">
            <summary>
            Applies an impulse to a body by index. Does not wake the body up.
            </summary>
            <param name="pose">Pose of the body to apply impulse to.</param>
            <param name="velocity">Velocity of the body to apply impulse to.</param>
            <param name="localInertia">Local inertia of the body to apply impulse to.</param>
            <param name="impulse">Impulse to apply to the body.</param>
            <param name="impulseOffset">World space offset from the center of the body to apply the impulse at.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyImpulse(BepuPhysics.BodySet@,System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Applies an impulse to a body by index. Does not wake the body up.
            </summary>
            <param name="set">Body set containing the body to apply an impulse to.</param>
            <param name="index">Index of the body in the body set.</param>
            <param name="impulse">Impulse to apply to the body.</param>
            <param name="impulseOffset">World space offset from the center of the body to apply the impulse at.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyAngularImpulse(System.Numerics.Vector3@,BepuUtilities.Symmetric3x3@,System.Numerics.Vector3@)">
            <summary>
            Applies an angular impulse to an angular velocity. Does not wake the body up.
            </summary>
            <param name="angularImpulse">Impulse to apply to the velocity.</param>
            <param name="inverseInertiaTensor">Inverse inertia tensor to transform the impulse with.</param>
            <param name="angularVelocity">Angular velocity to be modified.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyLinearImpulse(System.Numerics.Vector3@,System.Single,System.Numerics.Vector3@)">
            <summary>
            Applies an impulse to a linear velocity. Does not wake the body up.
            </summary>
            <param name="impulse">Impulse to apply to the velocity.</param>
            <param name="inverseMass">Inverse mass to transform the impulse with.</param>
            <param name="linearVelocity">Linear velocity to be modified.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyImpulse(System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Applies an impulse to a body at the given world space position. Does not modify activity states.
            </summary>
            <param name="impulse">Impulse to apply to the body.</param>
            <param name="impulseOffset">World space offset to apply the impulse at.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyLinearImpulse(System.Numerics.Vector3@)">
            <summary>
            Applies an impulse to a linear velocity. Does not wake the body up.
            </summary>
            <param name="impulse">Impulse to apply to the velocity.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.GetVelocityForOffset(System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the velocity of an offset point attached to the body.
            </summary>
            <param name="offset">Offset from the body's center to </param>
            <param name="velocity">Effective velocity of the point if it were attached to the body.</param>
        </member>
        <member name="M:BepuPhysics.BodyReference.ApplyAngularImpulse(System.Numerics.Vector3@)">
            <summary>
            Applies an angular impulse to an angular velocity. Does not wake the body up.
            </summary>
            <param name="angularImpulse">Impulse to apply to the velocity.</param>
        </member>
        <member name="T:BepuPhysics.BodySet">
            <summary>
            Stores a group of bodies- either the set of active bodies, or the bodies involved in an inactive simulation island.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.IndexToHandle">
            <summary>
            Remaps a body index to its handle.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.Collidables">
            <summary>
            The collidables owned by each body in the set. Speculative margins, continuity settings, and shape indices can be changed directly.
            Shape indices cannot transition between pointing at a shape and pointing at nothing or vice versa without notifying the broad phase of the collidable addition or removal.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.Activity">
            <summary>
            Activity states of bodies in the set.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodySet.Constraints">
            <summary>
            List of constraints associated with each body in the set.
            </summary>
        </member>
        <member name="P:BepuPhysics.BodySet.Allocated">
            <summary>
            Gets whether this instance is backed by allocated memory.
            </summary>
        </member>
        <member name="M:BepuPhysics.BodySet.Swap(System.Int32,System.Int32,BepuUtilities.Memory.Buffer{BepuPhysics.BodyMemoryLocation}@)">
            <summary>
            Swaps the memory of two bodies. Indexed by memory slot, not by handle index.
            </summary>
            <param name="slotA">Memory slot of the first body to swap.</param>
            <param name="slotB">Memory slot of the second body to swap.</param>
        </member>
        <member name="M:BepuPhysics.BodySet.DisposeBuffers(BepuUtilities.Memory.BufferPool)">
            <summary>
            Disposes the buffers, but nothing inside of the buffers. Per-body constraint lists stored in the set will not be returned.
            </summary>
            <param name="pool">Pool to return the set's top level buffers to.</param>
        </member>
        <member name="M:BepuPhysics.BodySet.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Disposes the body set's buffers and any resources within them.
            </summary>
            <param name="pool">Pool to return resources to.</param>
        </member>
        <member name="M:BepuPhysics.BoundingBoxHelpers.ExpandLocalBoundingBoxes(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,System.Single,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Expands the bounding box surrounding a shape A in the local space of some other collidable B.
            </summary>
        </member>
        <member name="M:BepuPhysics.BoundingBoxHelpers.GetLocalBoundingBoxForSweep(BepuPhysics.Collidables.TypedIndex,BepuPhysics.Collidables.Shapes,BepuPhysics.RigidPose@,System.Numerics.Quaternion@,BepuPhysics.BodyVelocity@,System.Numerics.Vector3@,System.Numerics.Quaternion@,BepuPhysics.BodyVelocity@,System.Single,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the bounding box of a child shape A in the local space of some other collidable B with a sweep direction representing the net linear motion.
            </summary>
        </member>
        <member name="M:BepuPhysics.BoundingBoxHelpers.GetLocalBoundingBoxForSweep``1(``0@,System.Numerics.Quaternion@,BepuPhysics.BodyVelocity@,System.Numerics.Vector3@,System.Numerics.Quaternion@,BepuPhysics.BodyVelocity@,System.Single,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the bounding box of shape A in the local space of some other collidable B with a sweep direction representing the net linear motion.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollidableProperty`1">
            <summary>
            Convenience collection that stores extra properties about bodies and statics, indexed by the body or static handle.
            </summary>
            <typeparam name="T">Type of the data to store.</typeparam>
            <remarks>This is built for use cases relying on random access like the narrow phase. For maximum performance with sequential access, an index-aligned structure would be better.</remarks>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.#ctor(BepuUtilities.Memory.BufferPool)">
            <summary>
            Constructs a new collection to store handle-aligned body properties. Assumes the Initialize function will be called later to provide the Bodies collection.
            </summary>
            <param name="pool">Pool from which to pull internal resources. If null, uses the later Initialize-provided Bodies pool.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.#ctor(BepuPhysics.Simulation,BepuUtilities.Memory.BufferPool)">
            <summary>
            Constructs a new collection to store handle-aligned body and static properties.
            </summary>
            <param name="simulation">Simulation to track.</param>
            <param name="pool">Pool from which to pull internal resources. If null, uses the Simulation pool.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Initialize(BepuPhysics.Simulation)">
            <summary>
            Initializes the property collection if the Bodies/Statics-less constructor was used.
            </summary>
            <param name="bodies">Bodies collection to track.</param>
            <param name="statics">Statics collection to track.</param>
        </member>
        <member name="P:BepuPhysics.CollidableProperty`1.Item(BepuPhysics.BodyHandle)">
            <summary>
            Gets a reference to the properties associated with a body's handle.
            </summary>
            <param name="bodyHandle">Body handle to retrieve the properties for.</param>
            <returns>Reference to properties associated with a body handle.</returns>
        </member>
        <member name="P:BepuPhysics.CollidableProperty`1.Item(BepuPhysics.StaticHandle)">
            <summary>
            Gets a reference to the properties associated with a static's handle.
            </summary>
            <param name="staticHandle">Static handle to retrieve the properties for.</param>
            <returns>Reference to properties associated with a static handle.</returns>
        </member>
        <member name="P:BepuPhysics.CollidableProperty`1.Item(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Gets a reference to the properties associated with a collidable.
            </summary>
            <param name="staticHandle">Collidable to retrieve the properties for.</param>
            <returns>Reference to properties associated with a collidable.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Allocate(BepuPhysics.BodyHandle)">
            <summary>
            Ensures there is space for a given body handle and returns a reference to the used memory.
            </summary>
            <param name="bodyHandle">Body handle to allocate for.</param>
            <returns>Reference to the data for the given body.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Allocate(BepuPhysics.StaticHandle)">
            <summary>
            Ensures there is space for a given static handle and returns a reference to the used memory.
            </summary>
            <param name="handle">Static handle to allocate for.</param>
            <returns>Reference to the data for the given static.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Allocate(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Ensures there is space for a given collidable reference and returns a reference to the used memory.
            </summary>
            <param name="handle">Collidable reference to allocate for.</param>
            <returns>Reference to the data for the given collidable.</returns>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.EnsureBodyCapacity(System.Int32)">
            <summary>
            Ensures that the internal structures have at least the given capacity for bodies.
            </summary>
            <param name="capacity">Capacity to ensure.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.EnsureStaticCapacity(System.Int32)">
            <summary>
            Ensures that the internal structures have at least the given capacity for statics.
            </summary>
            <param name="capacity">Capacity to ensure.</param>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.CompactBodies">
            <summary>
            Compacts the memory used by the collection for bodies to a safe minimum based on the Bodies collection.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.CompactStatics">
            <summary>
            Compacts the memory used by the collection for statics to a safe minimum based on the Statics collection.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollidableProperty`1.Dispose">
            <summary>
            Returns all held resources.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.BigCompound">
            <summary>
            Compound shape containing a bunch of shapes accessible through a tree acceleration structure. Useful for compounds with lots of children.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.BigCompound.Tree">
            <summary>
            Acceleration structure for the compound children.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.BigCompound.Children">
            <summary>
            Buffer of children within this compound.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.BigCompound.#ctor(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild},BepuPhysics.Collidables.Shapes,BepuUtilities.Memory.BufferPool)">
            <summary>
            Creates a compound shape with an acceleration structure.
            </summary>
            <param name="children">Set of children in the compound.</param>
            <param name="shapes">Shapes set in which child shapes are allocated.</param>
            <param name="pool">Pool to use to allocate acceleration structures.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.BigCompound.Id">
            <summary>
            Type id of compound shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.Box">
            <summary>
            Collision shape representing a solid cuboid.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.HalfWidth">
            <summary>
            Half of the box's width along its local X axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.HalfHeight">
            <summary>
            Half of the box's height along its local Y axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.HalfLength">
            <summary>
            Half of the box's length along its local Z axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Box.Width">
            <summary>
            Gets or sets the width of the box along its local X axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Box.Height">
            <summary>
            Gets or sets the height of the box along its local Y axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Box.Length">
            <summary>
            Gets or sets the length of the box along its local Z axis.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Box.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a Box shape.
            </summary>
            <param name="width">Width of the box along the local X axis.</param>
            <param name="height">Height of the box along the local Y axis.</param>
            <param name="length">Length of the box along the local Z axis.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Box.Id">
            <summary>
            Type id of box shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.Capsule">
            <summary>
            Collision shape representing a sphere-expanded line segment.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Capsule.Radius">
            <summary>
            Spherical expansion applied to the internal line segment.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Capsule.HalfLength">
            <summary>
            Half of the length of the internal line segment. Oriented along the local Y axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Capsule.Length">
            <summary>
            Gets or sets the length of the capsule's internal line segment along the local Y axis.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Capsule.#ctor(System.Single,System.Single)">
            <summary>
            Creates a capsule shape.
            </summary>
            <param name="radius">Radius of the capsule.</param>
            <param name="length">Length of the capsule's internal line segment along the local Y axis.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Capsule.Id">
            <summary>
            Type id of capsule shapes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionMode.Discrete">
            <summary>
            <para>No dedicated continuous detection is performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box will not be expanded by velocity beyond the speculative margin.</para>
            <para>This is the cheapest mode, but it may miss collisions. Note that if a Discrete mode collidable is moving quickly, the fact that its bounding box is not expanded
            may cause it to miss a collision even with a non-Discrete collidable.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionMode.Passive">
            <summary>
            <para>No dedicated continuous detection is performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box will be expanded by velocity beyond the speculative margin if necessary.</para>
            <para>This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes 
            that should avoid missing collisions.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionMode.Continuous">
            <summary>
            <para>Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision.</para>
            <para>This mode can capture angular motion with very few ghost collisions. It can, however, miss secondary collisions that would have occurred due to the primary impact's velocity change.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionSettings.Mode">
            <summary>
            The continuous collision detection mode.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionSettings.MinimumSweepTimestep">
            <summary>
            If using ContinuousDetectionMode.Continuous, MinimumSweepTimestep is the minimum progress that the sweep test will make when searching for the first time of impact.
            Collisions lasting less than MinimumProgress may be missed by the sweep test. Using larger values can significantly increase the performance of sweep tests.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ContinuousDetectionSettings.SweepConvergenceThreshold">
            <summary>
            If using ContinuousDetectionMode.Continuous, sweep tests will terminate if the time of impact region has been refined to be smaller than SweepConvergenceThreshold.
            Values closer to zero will converge more closely to the true time of impact, but for speculative contact generation larger values usually work fine.
            Larger values allow the sweep to terminate much earlier and can significantly improve sweep performance.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ContinuousDetectionSettings.Discrete">
            <summary>
            <para>No dedicated continuous detection will be performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box will not be expanded by velocity beyond the speculative margin.</para>
            <para>This is the cheapest mode, but it may miss collisions. Note that if a Discrete mode collidable is moving quickly, the fact that its bounding box is not expanded
            may cause it to miss a collision even with a non-Discrete collidable.</para>
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ContinuousDetectionSettings.Passive">
            <summary>
            <para>No dedicated continuous detection is performed. Default speculative contact generation will occur within the speculative margin.</para>
            <para>The collidable's bounding box will be expanded by velocity beyond the speculative margin if necessary.</para>
            <para>This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes 
            that should avoid missing collisions.</para>
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ContinuousDetectionSettings.Continuous(System.Single,System.Single)">
            <summary>
            <para>Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision.</para>
            <para>This mode can capture angular motion with very few ghost collisions. It can, however, miss secondary collisions that would have occurred due to the primary impact's velocity change.</para>
            </summary>
            <param name="minimumSweepTimestep">Minimum progress that the sweep test will make when searching for the first time of impact.
            Collisions lasting less than MinimumProgress may be missed by the sweep test. Using larger values can significantly increase the performance of sweep tests.</param>
            <param name="sweepConvergenceThreshold">Threshold against which the time of impact region is compared for sweep termination. 
            If the region has been refined to be smaller than SweepConvergenceThreshold, the sweep will terminate.
            Values closer to zero will converge more closely to the true time of impact, but for speculative contact generation larger values usually work fine.
            Larger values allow the sweep to terminate much earlier and can significantly improve sweep performance.</param>
            <returns>Settings reflecting a continuous detection mode.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.Collidable">
            <summary>
            Description of a collidable instance living in the broad phase and able to generate collision pairs.
            Collidables with a ShapeIndex that points to nothing (a default constructed TypedIndex) do not actually refer to any existing Collidable.
            This can be used for a body which needs no collidable representation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.Continuity">
            <summary>
            Continuous collision detection settings for this collidable. Includes the collision detection mode to use and tuning variables associated with those modes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.Shape">
            <summary>
            Index of the shape used by the body. While this can be changed, any transition from shapeless->shapeful or shapeful->shapeless must be reported to the broad phase. 
            If you need to perform such a transition, consider using Bodies.ChangeShape or Bodies.ApplyDescription; those functions update the relevant state.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.SpeculativeMargin">
            <summary>
            Size of the margin around the surface of the shape in which contacts can be generated. These contacts will have negative depth and only contribute if the frame's velocities
            would push the shapes of a pair into overlap. This should be positive to avoid jittering. It can also be used as a form of continuous collision detection, but excessively 
            high values combined with fast motion may result in visible 'ghost collision' artifacts. 
            <para>For continuous collision detection with less chance of ghost collisions, use the dedicated continuous collision detection modes.</para>
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Collidable.BroadPhaseIndex">
            <summary>
            Index of the collidable in the broad phase. Used to look up the target location for bounding box scatters. Under normal circumstances, this should not be set externally.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex,System.Single,BepuPhysics.Collidables.ContinuousDetectionSettings@)">
            <summary>
            Constructs a new collidable description.
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <param name="speculativeMargin">Radius of the margin in which to allow speculative contact generation.</param>
            <param name="continuity">Continuous collision detection settings for the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableDescription.#ctor(BepuPhysics.Collidables.TypedIndex,System.Single)">
            <summary>
            Constructs a new collidable description with default discrete continuity.
            </summary>
            <param name="shape">Shape used by the collidable.</param>
            <param name="speculativeMargin">Radius of the margin in which to allow speculative contact generation.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableMobility.Dynamic">
            <summary>
            Marks a collidable as owned by a dynamic body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableMobility.Kinematic">
            <summary>
            Marks a collidable as owned by a kinematic body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CollidableMobility.Static">
            <summary>
            Marks the collidable as an independent immobile collidable.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.Mobility">
            <summary>
            Gets the mobility state of the owner of this collidable.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.BodyHandle">
            <summary>
            Gets the body handle of the owner of the collidable referred to by this instance.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.StaticHandle">
            <summary>
            Gets the static handle of the owner of the collidable referred to by this instance.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.CollidableReference.RawHandleValue">
            <summary>
            Gets the integer value of the handle of the owner of the collidable referred to by this instance.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableReference.#ctor(BepuPhysics.Collidables.CollidableMobility,System.Int32)">
            <summary>
            Creates a collidable reference.
            </summary>
            <param name="mobility">Mobility type of the owner of the collidable.</param>
            <param name="handle">Handle of the owner of the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableReference.#ctor(BepuPhysics.Collidables.CollidableMobility,BepuPhysics.BodyHandle)">
            <summary>
            Creates a collidable reference for a body.
            </summary>
            <param name="mobility">Mobility type of the owner of the collidable.</param>
            <param name="handle">Handle of the owner of the collidable.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CollidableReference.#ctor(BepuPhysics.StaticHandle)">
            <summary>
            Creates a collidable reference for a static.
            </summary>
            <param name="mobility">Mobility type of the owner of the collidable.</param>
            <param name="handle">Handle of the owner of the collidable.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.Compound">
            <summary>
            Minimalist compound shape containing a list of child shapes. Does not make use of any internal acceleration structure; should be used only with small groups of shapes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Compound.Children">
            <summary>
            Buffer of children within this compound.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.#ctor(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild})">
            <summary>
            Creates a compound shape with no acceleration structure.
            </summary>
            <param name="children">Set of children in the compound.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.ValidateChildIndex(BepuPhysics.Collidables.TypedIndex,BepuPhysics.Collidables.Shapes)">
            <summary>
            Checks if a shape index.
            </summary>
            <param name="shapeIndex">Shape index to analyze.</param>
            <param name="shapeBatches">Shape collection into which the index indexes.</param>
            <returns>True if the index is valid, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Compound.ValidateChildIndices(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,BepuPhysics.Collidables.Shapes)">
            <summary>
            Checks if a set of children shape indices are all valid.
            </summary>
            <param name="children">Children to examine.</param>
            <param name="shapeBatches">Shape collection into which the children index.</param>
            <returns>True if all child indices are valid, false otherwise.</returns>
        </member>
        <member name="F:BepuPhysics.Collidables.Compound.Id">
            <summary>
            Type id of list based compound shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.CompoundBuilder">
            <summary>
            Reusable convenience type for incrementally building compound shapes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CompoundBuilder.Child.Weight">
            <summary>
            Weight associated with this child. Acts as the child's mass when interpreted as a dynamic compound.
            When interpreted as kinematic with recentering, it is used as a local pose weight to compute the center of rotation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.CompoundBuilder.Child.Inertia">
            <summary>
            Inertia tensor associated with the child. If inertia is all zeroes, it is interpreted as infinite.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Add``1(``0@,BepuPhysics.RigidPose@,System.Single)">
            <summary>
            Adds a new shape to the accumulator, creating a new shape in the shapes set. The mass used to compute the inertia tensor will be based on the given weight.
            </summary>
            <typeparam name="TShape">Type of the shape to add to the accumulator and the shapes set.</typeparam>
            <param name="shape">Shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass and scales the inertia tensor. 
            Otherwise, it is used for recentering.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.AddForKinematic``1(``0@,BepuPhysics.RigidPose@,System.Single)">
            <summary>
            Adds a new shape to the accumulator, creating a new shape in the shapes set. Inertia is assumed to be infinite.
            </summary>
            <typeparam name="TShape">Type of the shape to add to the accumulator and the shapes set.</typeparam>
            <param name="shape">Shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass. Otherwise, it is used for recentering.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Add(BepuPhysics.Collidables.TypedIndex,BepuPhysics.RigidPose@,BepuUtilities.Symmetric3x3@,System.Single)">
            <summary>
            Adds a new shape to the accumulator.
            </summary>
            <param name="shape">Index of the shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass. Otherwise, it is used for recentering.</param>
            <param name="inverseInertia">Inverse inertia tensor of the shape being added. This is assumed to already be scaled as desired by the weight.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.AddForKinematic(BepuPhysics.Collidables.TypedIndex,BepuPhysics.RigidPose@,System.Single)">
            <summary>
            Adds a new shape to the accumulator, assuming it has infinite inertia.
            </summary>
            <param name="shape">Index of the shape to add.</param>
            <param name="localPose">Pose of the shape in the compound's local space.</param>
            <param name="weight">Weight of the shape used for computing the center of rotation.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildDynamicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,BepuPhysics.BodyInertia@,System.Numerics.Vector3@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a dynamic compound.
            Computes a center of mass and recenters child shapes relative to it. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
            <param name="inertia">Combined inertia of the compound.</param>
            <param name="center">Computed center of rotation based on the poses and weights of accumulated children.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildDynamicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,BepuPhysics.BodyInertia@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a dynamic compound. Does not recenter the children. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
            <param name="inertia">Combined inertia of the compound.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildKinematicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@,System.Numerics.Vector3@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a kinematic compound.
            Computes a center of mass and recenters child shapes relative to it. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
            <param name="inertia">Combined inertia of the compound.</param>
            <param name="center">Computed center of rotation based on the poses and weights of accumulated children.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.BuildKinematicCompound(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.CompoundChild}@)">
            <summary>
            Builds a buffer of compound children from the accumulated set for a kinematic compound. Does not recenter children. Does not reset the accumulator.
            </summary>
            <param name="children">List of children created from the accumulated set.</param>
            <param name="inertia">Combined inertia of the compound.</param>
            <param name="center">Computed center of rotation based on the poses and weights of accumulated children.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Reset">
            <summary>
            Empties out the accumulated children.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.CompoundBuilder.Dispose">
            <summary>
            Returns internal resources to the pool, rendering the builder unusable.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullBoundingPlanes.Normal">
            <summary>
            Normal of the bounding plane.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullBoundingPlanes.Offset">
            <summary>
            Offset from the origin to a point on the plane along the normal. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.Points">
            <summary>
            Bundled points of the convex hull.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.BoundingPlanes">
            <summary>
            Bundled bounding planes of the convex hull. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.FaceVertexIndices">
            <summary>
            Combined set of vertices used by each face. Use FaceToVertexIndicesStart to index into this for a particular face. Indices stored in counterclockwise winding in right handed space, clockwise in left handed space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.FaceToVertexIndicesStart">
            <summary>
            Start indices of faces in the FaceVertexIndices.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHull.#ctor(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,System.Numerics.Vector3@)">
            <summary>
            Creates a convex hull from a point set.
            </summary>
            <param name="points">Points to compute the convex hull of.</param>
            <param name="pool">Pool in which to allocate the convex hull and any temporary resources needed to compute the hull.</param>
            <param name="center">Computed center of the convex hull before the hull was recentered.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHull.ComputeInertia(System.Single,BepuPhysics.BodyInertia@)">
            <summary>
            Computes the inertia of the convex hull.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <param name="inertia">Inertia of the convex hull.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.ConvexHull.Id">
            <summary>
            Type id of convex hull shapes.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullWide.EstimateEpsilonScale(System.Numerics.Vector{System.Int32}@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Provides an estimate of the scale of a shape. 
            </summary>
            <param name="terminatedLanes">Mask of lanes which are inactive.</param>
            <param name="epsilonScale">Approximate scale of the shape for use in epsilons.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.HullFace">
            <summary>
            Stores references to the points composing one of a convex hull's faces.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.HullFace.VertexCount">
            <summary>
            Gets the number of vertices in the face.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.HullFace.Item(System.Int32)">
            <summary>
            Gets the index of the vertex associated with the given face vertex index in the source point set.
            </summary>
            <param name="index">Index into the face's vertex list.</param>
            <returns>Index of the vertex associated with the given face vertex index in the source point set.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.HullData">
            <summary>
            Raw data representing a convex hull.
            </summary>
            <remarks>This is not yet transformed into a runtime format. It requires additional processing to be used in a ConvexHull shape; see ConvexHullHelper.ProcessHull.</remarks>
        </member>
        <member name="F:BepuPhysics.Collidables.HullData.OriginalVertexMapping">
            <summary>
            Mapping of points on the convex hull back to the original point set.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullData.FaceVertexIndices">
            <summary>
            List of indices composing the faces of the hull. Individual faces indexed by the FaceIndices.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.HullData.FaceStartIndices">
            <summary>
            Starting index in the FaceVertexIndices for each face.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ConvexHullHelper">
            <summary>
            Helper methods to create and process convex hulls from point clouds.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.ComputeHull(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.HullData@)">
            <summary>
            Computes the convex hull of a set of points.
            </summary>
            <param name="points">Point set to compute the convex hull of.</param>
            <param name="pool">Buffer pool to pull memory from when creating the hull.</param>
            <param name="hullData">Convex hull of the input point set.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateShape(System.Span{System.Numerics.Vector3},BepuPhysics.Collidables.HullData,BepuUtilities.Memory.BufferPool,System.Numerics.Vector3@,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Processes hull data into a runtime usable convex hull shape. Recenters the convex hull's points around its center of mass.
            </summary>
            <param name="points">Point array into which the hull data indexes.</param>
            <param name="hullData">Raw input data to process.</param>
            <param name="pool">Pool used to allocate resources for the hullShape.</param>
            <param name="hullShape">Convex hull shape created from the input data.</param>
            <param name="center">Computed center of mass of the convex hull before its points were recentered onto the origin.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateShape(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,BepuPhysics.Collidables.HullData@,System.Numerics.Vector3@,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Creates a convex hull shape out of an input point set. Recenters the convex hull's points around its center of mass.
            </summary>
            <param name="points">Points to use to create the hull.</param>
            <param name="pool">Buffer pool used for temporary allocations and the output data structures.</param>
            <param name="hullData">Intermediate hull data that got processed into the convex hull.</param>
            <param name="center">Computed center of mass of the convex hull before its points were recentered onto the origin.</param>
            <param name="convexHull">Convex hull shape of the input point set.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ConvexHullHelper.CreateShape(System.Span{System.Numerics.Vector3},BepuUtilities.Memory.BufferPool,System.Numerics.Vector3@,BepuPhysics.Collidables.ConvexHull@)">
            <summary>
            Creates a convex hull shape out of an input point set. Recenters the convex hull's points around its center of mass.
            </summary>
            <param name="points">Points to use to create the hull.</param>
            <param name="pool">Buffer pool used for temporary allocations and the output data structures.</param>
            <param name="center">Computed center of mass of the convex hull before its points were recentered onto the origin.</param>
            <param name="convexHull">Convex hull shape of the input point set.</param>
        </member>
        <member name="T:BepuPhysics.Collidables.Cylinder">
            <summary>
            Collision shape representing a cylinder.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Cylinder.Radius">
            <summary>
            Radius of the cylinder.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Cylinder.HalfLength">
            <summary>
            Half length of the cylinder along its local Y axis.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Cylinder.Length">
            <summary>
            Gets or sets the length of the cylinder along its local Y axis.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Cylinder.#ctor(System.Single,System.Single)">
            <summary>
            Creates a cylinder shape.
            </summary>
            <param name="radius">Radius of the cylinder.</param>
            <param name="length">Length of the cylinder along its local Y axis.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Cylinder.Id">
            <summary>
            Type id of cylinder shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.IShape">
            <summary>
            Defines a type usable as a shape by collidables.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ICompoundShape">
            <summary>
            Defines a compound shape type that has children of potentially different types.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.IHomogeneousCompoundShape`2">
            <summary>
            Defines a compound shape type that has children of only one type.
            </summary>
            <typeparam name="TChildShape">Type of the child shapes.</typeparam>
            <typeparam name="TChildShapeWide">Type of the child shapes, formatted in AOSOA layout.</typeparam>
        </member>
        <member name="P:BepuPhysics.Collidables.IShapeWide`1.AllowOffsetMemoryAccess">
            <summary>
            Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.IShapeWide`1.InternalAllocationSize">
            <summary>
            Gets the number of bytes required for allocations within the wide shape.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.Initialize(BepuUtilities.Memory.RawBuffer@)">
            <summary>
            For types with a nonzero internal allocation size, provides memory to the shape for internal allocations.
            Memory should be assumed to be stack allocated.
            </summary>
            <param name="memory">Memory to use for internal allocations in the wide shape.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.WriteFirst(`0@)">
            <summary>
            Places the specified AOS-formatted shape into the first lane of the wide 'this' reference.
            </summary>
            <remarks>Note that we are effectively using the TShapeWide as a stride.
            The base address is offset by the user of this function, so the implementation only ever considers the first slot.</remarks>
            <param name="source">AOS-formatted shape to gather from.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.IShapeWide`1.WriteSlot(System.Int32,`0@)">
            <summary>
            Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference.
            </summary>
            <param name="index">Index of the slot to put the data into.</param>
            <param name="source">Source of the data to insert.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.IShapeWide`1.MinimumWideRayCount">
            <summary>
            Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.Mesh">
            <summary>
            Shape designed to contain a whole bunch of triangles. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Mesh.Tree">
            <summary>
            Acceleration structure of the mesh.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Mesh.Triangles">
            <summary>
            Buffer of triangles composing the mesh. Triangles will only collide with tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.Mesh.Scale">
            <summary>
            Gets or sets the scale of the mesh.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.#ctor(BepuUtilities.Memory.Buffer{BepuPhysics.Collidables.Triangle},System.Numerics.Vector3@,BepuUtilities.Memory.BufferPool)">
            <summary>
            Creates a mesh shape.
            </summary>
            <param name="triangles">Triangles to use in the mesh.</param>
            <param name="scale">Scale to apply to all vertices at runtime.
            Note that the scale is not baked into the triangles or acceleration structure; the same set of triangles and acceleration structure can be used across multiple Mesh instances with different scales.</param>
            <param name="pool">Pool used to allocate acceleration structures.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.#ctor(System.Span{System.Byte},BepuUtilities.Memory.BufferPool)">
            <summary>
            Loads a mesh from data stored in a byte buffer previously stored by the Serialize function.
            </summary>
            <param name="data">Data to load the mesh from.</param>
            <param name="pool">Pool to create the mesh with.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.GetSerializedByteCount">
            <summary>
            Gets the number of bytes it would take to store the given mesh in a byte buffer.
            </summary>
            <param name="mesh">Mesh to measure.</param>
            <returns>Number of bytes it would take to store the mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.Serialize(System.Span{System.Byte})">
            <summary>
            Writes a mesh's data to a byte buffer.
            </summary>
            <param name="mesh">Mesh to write into the byte buffer.</param>
            <param name="data">Byte buffer to store the mesh in.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RayData@,System.Single@,``0@)">
            <summary>
            Casts a ray against the mesh. Executes a callback for every test candidate and every hit.
            </summary>
            <typeparam name="TRayHitHandler">Type of the callback to execute for every test candidate and hit.</typeparam>
            <param name="pose">Pose of the mesh during the ray test.</param>
            <param name="ray">Ray to test against the mesh.</param>
            <param name="maximumT">Maximum length of the ray in units of the ray direction length.</param>
            <param name="hitHandler">Callback to execute for every hit.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.RayTest``1(BepuPhysics.RigidPose@,BepuPhysics.Trees.RaySource@,``0@)">
            <summary>
            Casts a bunch of rays against the mesh at the same time, executing a callback for every test candidate and every hit.
            </summary>
            <typeparam name="TRayHitHandler">Type of the callback to execute for every ray test candidate and every hit.</typeparam>
            <param name="pose">Pose of the mesh during the ray test.</param>
            <param name="rays">Set of rays to cast against the mesh.</param>
            <param name="hitHandler">Callbacks to execute.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.Recenter(System.Numerics.Vector3@)">
            <summary>
            Subtracts the newCenter from all points in the mesh hull.
            </summary>
            <param name="newCenter">New center that all points will be made relative to.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedInertia(System.Single,BepuPhysics.BodyInertia@,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of the mesh around its volumetric center and recenters the points of the mesh around it.
            Assumes the mesh is closed and should be treated as solid.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <param name="inertia">Inertia tensor of the closed mesh.</param>
            <param name="center">Center of the closed mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedInertia(System.Single,BepuPhysics.BodyInertia@)">
            <summary>
            Computes the inertia of the mesh.
            Assumes the mesh is closed and should be treated as solid.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <param name="inertia">Inertia of the closed mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedCenterOfMass(System.Single@,System.Numerics.Vector3@)">
            <summary>
            Computes the volume and center of mass of the mesh. Assumes the mesh is closed and should be treated as solid.
            </summary>
            <param name="volume">Volume of the closed mesh.</param>
            <param name="center">Center of mass of the closed mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeClosedCenterOfMass">
            <summary>
            Computes the center of mass of the mesh.
            Assumes the mesh is closed and should be treated as solid.
            </summary>
            <returns>Center of mass of the closed mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeOpenInertia(System.Single,BepuPhysics.BodyInertia@,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of the mesh around its volumetric center and recenters the points of the mesh around it.
            Assumes the mesh is open and should be treated as a triangle soup.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <param name="inertia">Inertia tensor of the closed mesh.</param>
            <param name="center">Center of the open mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeOpenInertia(System.Single,BepuPhysics.BodyInertia@)">
            <summary>
            Computes the inertia of the mesh.
            Assumes the mesh is open and should be treated as a triangle soup.
            </summary>
            <param name="mass">Mass to scale the inertia tensor with.</param>
            <param name="inertia">Inertia of the open mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.ComputeOpenCenterOfMass">
            <summary>
            Computes the center of mass of the mesh.
            Assumes the mesh is open and should be treated as a triangle soup.
            </summary>
            <returns>Center of mass of the open mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Mesh.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Returns the mesh's resources to a buffer pool.
            </summary>
            <param name="bufferPool">Pool to return the mesh's resources to.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Mesh.Id">
            <summary>
            Type id of mesh shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.ITriangleSource">
            <summary>
            Defines a type capable of providing a sequence of triangles.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ITriangleSource.GetNextTriangle(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Gets the next triangle in the sequence, if any.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <returns>True if there was another triangle, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.Collidables.MeshInertiaHelper">
            <summary>
            Provides helpers for computing the inertia of objects with triangular surfaces.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTetrahedronVolume(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the signed volume of a tetrahedron where the fourth vertex is at the origin.
            Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates.
            </summary>
            <param name="a">First vertex of the tetrahedron.</param>
            <param name="b">Second vertex of the tetrahedron.</param>
            <param name="c">Third vertex of the tetrahedron.</param>
            <returns>Volume of the tetrahedron.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTetrahedronContribution(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Integrates the inertia contribution of a tetrahedron with vertices at a, b, c, and (0,0,0) assuming a density of 1.
            </summary>
            <param name="a">First vertex of the tetrahedron.</param>
            <param name="b">Second vertex of the tetrahedron.</param>
            <param name="c">Third vertex of the tetrahedron.</param>
            <param name="volume">Volume of the tetrahedron.</param>
            <param name="inertiaTensor">Inertia tensor of this tetrahedron assuming a density of 1.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeClosedInertia``1(``0@,System.Single,System.Single@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes the inertia of a closed mesh.
            Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="volume">Volume of the mesh.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeClosedInertia``1(``0@,System.Single,System.Single@,BepuUtilities.Symmetric3x3@,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of a closed mesh.
            Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="volume">Volume of the mesh.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
            <param name="center">Center of mass of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeClosedCenterOfMass``1(``0@,System.Single@,System.Numerics.Vector3@)">
            <summary>
            Computes the center of mass of a closed mesh.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="volume">Volume of the mesh.</param>
            <param name="center">Center of mass of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTriangleContribution(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,BepuUtilities.Symmetric3x3@)">
            <summary>
            Integrates the inertia contribution from a single triangle.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <param name="mass">Mass of the triangle.</param>
            <param name="inertiaTensor">Inertia tensor of the triangle.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTriangleArea(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes the area of a triangle.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <returns>Area of the triangle.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeTriangleContribution(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Integrates the inertia contribution from a single triangle assuming a density of 1.
            </summary>
            <param name="a">First vertex in the triangle.</param>
            <param name="b">Second vertex in the triangle.</param>
            <param name="c">Third vertex in the triangle.</param>
            <param name="area">Area of the triangle.</param>
            <param name="inertiaTensor">Inertia tensor of the triangle assuming that the density is 1.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeOpenInertia``1(``0@,System.Single,BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes the inertia of an open mesh, treating it as a triangle soup.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeOpenInertia``1(``0@,System.Single,BepuUtilities.Symmetric3x3@,System.Numerics.Vector3@)">
            <summary>
            Computes the inertia of an open mesh, treating it as a triangle soup.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <param name="mass">Mass of the mesh to scale the inertia tensor with.</param>
            <param name="inertia">Inertia tensor of the mesh.</param>
            <param name="center">Center of mass of the mesh.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.ComputeOpenCenterOfMass``1(``0@)">
            <summary>
            Computes the center of mass of an open mesh, treating it as a triangle soup.
            </summary>
            <typeparam name="TTriangleSource">Type of the triangle source.</typeparam>
            <param name="triangleSource">Source from which to retrieve a sequence of triangles.</param>
            <returns>Center of mass of the mesh.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.MeshInertiaHelper.GetInertiaOffset(System.Single,System.Numerics.Vector3@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes an offset for an inertia tensor based on an offset frame of reference.
            </summary>
            <param name="mass">Mass associated with the inertia tensor being moved.</param>
            <param name="offset">Offset from the current inertia frame of reference to the new frame of reference.</param>
            <param name="inertiaOffset">Modification to add to the inertia tensor to move it into the new reference frame.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.Capacity">
            <summary>
            Gets the number of shapes that the batch can currently hold without resizing.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.TypeId">
            <summary>
            Gets the type id of the shape type in this batch.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.Compound">
            <summary>
            Gets whether this shape batch's contained type potentially contains children that require other shape batches.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch.ShapeDataSize">
            <summary>
            Gets the size of the shape type stored in this batch in bytes.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.GetShapeData(System.Int32,System.Void*@,System.Int32@)">
            <summary>
            Gets a raw untyped pointer to a shape's data.
            </summary>
            <param name="shapeIndex">Index of the shape to look up.</param>
            <param name="shapePointer">Pointer to the indexed shape data.</param>
            <param name="shapeSize">Size of the shape data in bytes.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.Clear">
            <summary>
            Frees all shape slots without returning any resources to the pool.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.EnsureCapacity(System.Int32)">
            <summary>
            Increases the size of the type batch if necessary to hold the target capacity.
            </summary>
            <param name="shapeCapacity">Target capacity.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.Resize(System.Int32)">
            <summary>
            Changes the size of the type batch if the target capacity is different than the current capacity. Note that shrinking allocations is conservative; resizing will
            never allow an existing shape to point to unallocated memory.
            </summary>
            <param name="shapeCapacity">Target capacity.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.Dispose">
            <summary>
            Returns all backing resources to the pool, leaving the batch in an unusable state.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.ShapeBatch.ResizeIdPool(System.Int32)">
            <summary>
            Shrinks or expands the allocation of the batch's id pool. Note that shrinking allocations is conservative; resizing will never allow any pending ids to be lost.
            </summary>
            <param name="targetIdCapacity">Number of slots to allocate space for in the id pool.</param>
        </member>
        <member name="P:BepuPhysics.Collidables.ShapeBatch`1.Item(System.Int32)">
            <summary>
            Gets a reference to the shape associated with an index.
            </summary>
            <param name="shapeIndex">Index of the shape reference to retrieve.</param>
            <returns>Reference to the shape at the given index.</returns>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.UpdateBounds(BepuPhysics.RigidPose@,BepuPhysics.Collidables.TypedIndex@,BepuUtilities.BoundingBox@)">
            <summary>
            Computes a bounding box for a single shape.
            </summary>
            <param name="pose">Pose to calculate the bounding box of.</param>
            <param name="shapeIndex">Index of the shape.</param>
            <param name="bounds">Bounding box of the specified shape with the specified pose.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.RecursivelyRemoveAndDispose(BepuPhysics.Collidables.TypedIndex,BepuUtilities.Memory.BufferPool)">
            <summary>
            Removes a shape and any existing children from the shapes collection and returns their resources to the given pool.
            </summary>
            <param name="shapeIndex">Index of the shape to remove.</param>
            <param name="pool">Pool to return all shape resources to.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.RemoveAndDispose(BepuPhysics.Collidables.TypedIndex,BepuUtilities.Memory.BufferPool)">
            <summary>
            Removes a shape from the shapes collection and returns its resources to the given pool. Does not remove or dispose any children.
            </summary>
            <param name="shapeIndex">Index of the shape to remove.</param>
            <param name="pool">Pool to return all shape resources to.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.Remove(BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Removes a shape without removing its children or disposing any resources.
            </summary>
            <param name="shapeIndex">Index of the shape to remove.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.Clear">
            <summary>
            Clears all shapes from existing batches. Does not release any memory.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.EnsureBatchCapacities(System.Int32)">
            <summary>
            Ensures a minimum capacity for all existing shape batches.
            </summary>
            <param name="shapeCapacity">Capacity to ensure for all existing shape batches.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.ResizeBatches(System.Int32)">
            <summary>
            Resizes all existing batches for a target capacity. Note that this is conservative; it will never orphan an existing shape.
            </summary>
            <param name="shapeCapacity">Capacity to target for all existing shape batches.</param>
        </member>
        <member name="M:BepuPhysics.Collidables.Shapes.Dispose">
            <summary>
            Releases all memory from existing batches. Leaves shapes set in an unusable state.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Sphere.Radius">
            <summary>
            Radius of the sphere.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Sphere.#ctor(System.Single)">
            <summary>
            Creates a sphere shape.
            </summary>
            <param name="radius">Radius of the sphere.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Sphere.Id">
            <summary>
            Type id of sphere shapes.
            </summary>
        </member>
        <member name="T:BepuPhysics.Collidables.Triangle">
            <summary>
            Collision shape representing an individual triangle. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.A">
            <summary>
            First vertex of the triangle in local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.B">
            <summary>
            Second vertex of the triangle in local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.C">
            <summary>
            Third vertex of the triangle in local space.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.Triangle.#ctor(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Creates a triangle shape.
            </summary>
            <param name="a">First vertex of the triangle in local space.</param>
            <param name="b">Second vertex of the triangle in local space.</param>
            <param name="c">Third vertex of the triangle in local space.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.Triangle.Id">
            <summary>
            Type id of triangle shapes.
            </summary>
        </member>
        <member name="M:BepuPhysics.Collidables.TriangleWide.EstimateEpsilonScale(System.Numerics.Vector{System.Single}@)">
            <summary>
            Provides an estimate of the scale of a shape. 
            </summary>
            <param name="epsilonScale">Approximate scale of the shape for use in epsilons.</param>
        </member>
        <member name="F:BepuPhysics.Collidables.TypedIndex.Packed">
            <summary>
            Bit packed representation of the typed index.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.TypedIndex.Type">
            <summary>
            Gets the type index of the object.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.TypedIndex.Index">
            <summary>
            Gets the index of the object.
            </summary>
        </member>
        <member name="P:BepuPhysics.Collidables.TypedIndex.Exists">
            <summary>
            Gets whether this index actually refers to anything. The Type and Index should only be used if this is true.
            </summary>
        </member>
        <member name="P:BepuPhysics.BoundsContinuation.BodyIndex">
            <summary>
            Gets the index of the body associated with this continuation.
            </summary>
        </member>
        <member name="P:BepuPhysics.BoundsContinuation.CompoundChild">
            <summary>
            Gets whether this continuation is associated with a compound's child.
            </summary>
        </member>
        <member name="M:BepuPhysics.BoundsContinuation.CreateContinuation(System.Int32)">
            <summary>
            Creates a bounding box calculation continuation for a given noncompound body.
            </summary>
            <param name="bodyIndex">Index of the body to set the bounding box of.</param>
        </member>
        <member name="M:BepuPhysics.BoundsContinuation.CreateCompoundChildContinuation(System.Int32)">
            <summary>
            Creates a bounding box calculation continuation for a given compound body.
            </summary>
            <param name="compoundBodyIndex">Index of the compound body to set the bounding box of.</param>
        </member>
        <member name="F:BepuPhysics.BoundingBoxBatcher.CollidablesPerFlush">
            <summary>
            The number of bodies to accumulate per type before executing an AABB update. The more bodies per batch, the less virtual overhead and execution divergence.
            However, this should be kept low enough such that the data that has to be gathered by the bounding box update is still usually in L1.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.UpdateBounds(System.Int32,BepuPhysics.Trees.Tree@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Applies updated bounds to the given leaf index in the given tree, refitting the tree to match.
            </summary>
            <param name="broadPhaseIndex">Index of the leaf in the tree to update.</param>
            <param name="tree">Tree containing the leaf to update.</param>
            <param name="min">New minimum bounds for the leaf.</param>
            <param name="max">New maximum bounds for the leaf.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.UpdateActiveBounds(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Applies updated bounds to the given active leaf index, refitting the tree to match.
            </summary>
            <param name="broadPhaseIndex">Index of the leaf to update.</param>
            <param name="min">New minimum bounds for the leaf.</param>
            <param name="max">New maximum bounds for the leaf.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.UpdateStaticBounds(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Applies updated bounds to the given active leaf index, refitting the tree to match.
            </summary>
            <param name="broadPhaseIndex">Index of the leaf to update.</param>
            <param name="min">New minimum bounds for the leaf.</param>
            <param name="max">New maximum bounds for the leaf.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Clear">
            <summary>
            Clears out the broad phase's structures without releasing any resources.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.EnsureCapacity(System.Int32,System.Int32)">
            <summary>
            Ensures that the broad phase structures can hold at least the given number of leaves.
            </summary>
            <param name="activeCapacity">Number of leaves to allocate space for in the active tree.</param>
            <param name="staticCapacity">Number of leaves to allocate space for in the static tree.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Resize(System.Int32,System.Int32)">
            <summary>
            Resizes the broad phase structures to hold the given number of leaves. Note that this is conservative; it will never orphan any existing leaves.
            </summary>
            <param name="activeCapacity">Number of leaves to allocate space for in the active tree.</param>
            <param name="staticCapacity">Number of leaves to allocate space for in the static tree.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Dispose">
            <summary>
            Releases memory used by the broad phase. Leaves the broad phase unusable.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.RayCast``1(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,``0@,System.Int32)">
            <summary>
            Finds any intersections between a ray and leaf bounding boxes.
            </summary>
            <typeparam name="TRayTester">Type of the callback to execute on ray-leaf bounding box intersections.</typeparam>
            <param name="origin">Origin of the ray to cast.</param>
            <param name="direction">Direction of the ray to cast.</param>
            <param name="maximumT">Maximum length of the ray traversal in units of the direction's length.</param>
            <param name="rayTester">Callback to execute on ray-leaf bounding box intersections.</param>
            <param name="id">User specified id of the ray.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Sweep``1(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,``0@)">
            <summary>
            Finds any intersections between a swept bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TSweepTester">Type of the callback to execute on sweep-leaf bounding box intersections.</typeparam>
            <param name="min">Minimum bounds of the box to sweep.</param>
            <param name="max">Maximum bounds of the box to sweep.</param>
            <param name="direction">Direction along which to sweep the bounding box.</param>
            <param name="maximumT">Maximum length of the sweep in units of the direction's length.</param>
            <param name="sweepTester">Callback to execute on sweep-leaf bounding box intersections.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.Sweep``1(BepuUtilities.BoundingBox@,System.Numerics.Vector3@,System.Single,``0@)">
            <summary>
            Finds any intersections between a swept bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TSweepTester">Type of the callback to execute on sweep-leaf bounding box intersections.</typeparam>
            <param name="boundingBox">Bounding box to sweep.</param>
            <param name="direction">Direction along which to sweep the bounding box.</param>
            <param name="maximumT">Maximum length of the sweep in units of the direction's length.</param>
            <param name="sweepTester">Callback to execute on sweep-leaf bounding box intersections.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.GetOverlaps``1(System.Numerics.Vector3@,System.Numerics.Vector3@,``0@)">
            <summary>
            Finds any overlaps between a bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TOverlapEnumerator">Type of the enumerator to call for overlaps.</typeparam>
            <param name="min">Minimum bounds of the query box.</param>
            <param name="max">Maximum bounds of the query box.</param>
            <param name="overlapEnumerator">Enumerator to call for overlaps.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhase.GetOverlaps``1(BepuUtilities.BoundingBox@,``0@)">
            <summary>
            Finds any overlaps between a bounding box and leaf bounding boxes.
            </summary>
            <typeparam name="TOverlapEnumerator">Type of the enumerator to call for overlaps.</typeparam>
            <param name="boundingBox">Query box bounds.</param>
            <param name="overlapEnumerator">Enumerator to call for overlaps.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.IBroadPhaseSweepTester">
            <summary>
            Defines a type that can act as a callback for broad phase sweep tests.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionBatcher`1.Dt">
            <summary>
            Timestep duration used by pairs which rely on velocity to compute local bounding boxes for pruning.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionContinuationType">
            <summary>
            Describes the flow control to apply to a convex-convex pair report.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.Direct">
            <summary>
            Marks a pair as requiring no further processing before being reported to the user supplied continuations.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.NonconvexReduction">
            <summary>
            Marks a pair as part of a set of a higher (potentially multi-manifold) pair, potentially requiring contact reduction.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.MeshReduction">
            <summary>
            Marks a pair as a part of a set of mesh-convex collisions, potentially requiring mesh boundary smoothing.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionContinuationType.CompoundMeshReduction">
            <summary>
            Marks a pair as a part of a set of mesh-convex collisions spawned by a mesh-compound pair, potentially requiring mesh boundary smoothing.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionCallbacks.OnChildPairCompleted(System.Int32,System.Int32,System.Int32,BepuPhysics.CollisionDetection.ConvexContactManifold@)">
            <summary>
            Provides control over subtask generated results before they are reported to the parent task.
            </summary>
            <param name="pairId">Id of the parent pair that spawned this child pair.</param>
            <param name="childA">Index of the child belonging to collidable A in the subpair under consideration.</param>
            <param name="childB">Index of the child belonging to collidable B in the subpair under consideration.</param>
            <param name="manifold">Manifold of the child pair to configure.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ICollisionCallbacks.AllowCollisionTesting(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether further collision testing should be performed for a given subtask.
            </summary>
            <param name="pairId">Id of the parent pair.</param>
            <param name="childA">Index of the child belonging to collidable A in the subpair under consideration.</param>
            <param name="childB">Index of the child belonging to collidable B in the subpair under consideration.</param>
            <returns>True if testing should proceed, false otherwise.</returns>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.BatchSize">
            <summary>
            Gets the number of tasks to batch together before executing this task.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.ShapeTypeIndexA">
            <summary>
            Gets the first shape type index associated with the task. Shape pairs provided to the task for execution should be in the order defined by these type two indices.
            If a collision task isn't a top level shape pair task, this should be -1.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.ShapeTypeIndexB">
            <summary>
            Gets the second shape type index associated with the task. Shape pairs provided to the task for execution should be in the order defined by these type two indices.
            If a collision task isn't a top level shape pair task, this should be -1.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.SubtaskGenerator">
            <summary>
            Gets whether the task is capable of generating subtasks. Note that subtask generators cannot generate subtasks that are themselves subtask generators.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTask.PairType">
            <summary>
            Gets the pair type that the ExecuteBatch call requires.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.CollisionTask.ExecuteBatch``1(BepuPhysics.CollisionDetection.UntypedList@,BepuPhysics.CollisionDetection.CollisionBatcher{``0}@)">
            <summary>
            Executes the task on the given input.
            </summary>
            <typeparam name="TCallbacks">Type of the callbacks used to handle results of collision tasks.</typeparam>
            <param name="batcher">Batcher responsible for the invocation.</param>
            <param name="batch">Batch of pairs to test.</param>
            <param name="continuations">Continuations to invoke upon completion of a top level pair.</param>
            <param name="filters">Filters to use to influence execution of the collision tasks.</param>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.StandardPair">
            <summary>
            General pair for two shapes with full pose and flip mask, but no bounds related data.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.FliplessPair">
            <summary>
            Pair specialized for convex pairs between two shapes of the same type.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.SpherePair">
            <summary>
            Pair specialized for two spheres, requiring no flip mask or orientations.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.SphereIncludingPair">
            <summary>
            Pair specialized for convex pairs that involve one sphere which requires no orientation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTaskPairType.BoundsTestedPair">
            <summary>
            Pair that requires computing local bounding boxes, and so requires extra information like velocity.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTasks.IPairTester`3.BatchSize">
            <summary>
            Gets the nubmer of pairs which would ideally be gathered together before executing a wide test.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPair`1">
            <summary>
            Defines a type that holds scalar data for the collision batcher.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPair`1.PairType">
            <summary>
            Gets the enumeration type associated with this pair type.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTasks.CollisionPair.FlipMask">
            <summary>
            Stores whether the types involved in pair require that the resulting contact manifold be flipped to be consistent with the user-requested pair order.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollisionTasks.SphereIncludingPair.FlipMask">
            <summary>
            Stores whether the types involved in pair require that the resulting contact manifold be flipped to be consistent with the user-requested pair order.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.CollisionTasks.BoundsTestedPair">
            <summary>
            Pair of objects awaiting collision processing that involves velocities for bounds calculation.
            </summary>
            <typeparam name="TA">Type of the first shape in the pair.</typeparam>
            <typeparam name="TB">Type of the second shape in the pair.</typeparam>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.IPairCacheEntry.CacheTypeId">
            <summary>
            Gets the cache's type id. 
            Note that this is not the same as a constraint type id or other type ids; it only refers to the type of the caches for storage within the PairCache's structures.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ConstraintRemover">
            <summary>
            Accumulates constraints to remove from multiple threads, and efficiently removes them all as a batch.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConstraintRemover.CreateFlushJobs(System.Boolean)">
            <summary>
            Processes enqueued constraint removals and prepares removal jobs.
            </summary>
            <param name="deterministic">True if the constraint remover should maintain determinism at an added cost, false otherwise.</param>
            <returns>The number of removal jobs created. To complete the jobs, execute RemoveConstraintsFromTypeBatch for every index from 0 to the returned job count.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConstraintRemover.ReturnConstraintHandles">
            <summary>
            Returns the handles associated with all removed constraints to the solver's handle pool.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConstraintRemover.MarkAffectedConstraintsAsRemovedFromSolver">
            <summary>
            For uses of the ConstraintRemover that fully remove a constraint from the simulation (rather than simply moving it somewhere else),
            the handle->constraint mapping must be updated. This has to wait until after the multithreaded operations actually complete to avoid corrupting parallel operations.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ContactConstraintAccessor">
            <summary>
            Provides indirection for reading from and updating constraints in the narrow phase.
            </summary>
            <remarks>This, like many other similar constructions in the engine, could conceptually be replaced by static function pointers and a few supplementary data fields.
            We probably will do exactly that at some point.</remarks>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactData``1(BepuPhysics.ConstraintHandle,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintHandle">Handle of the contact constraint to extract.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactData``1(BepuPhysics.ConstraintLocation@,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintLocation">Location of the constraint in the solver.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactPrestepAndImpulses``1(BepuPhysics.ConstraintHandle,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintHandle">Handle of the contact constraint to extract.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ContactConstraintAccessor.ExtractContactPrestepAndImpulses``1(BepuPhysics.ConstraintLocation@,BepuPhysics.Solver,``0@)">
            <summary>
            Extracts references to data from a contact constraint of the accessor's type.
            </summary>
            <typeparam name="TExtractor">Type of the extractor to handle the extracted references.</typeparam>
            <param name="constraintLocation">Location of the constraint in the solver.</param>
            <param name="solver">Solver in which the constraint lives.</param>
            <param name="extractor">Extractor to handle the extracted references.</param>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.NonconvexContact">
            <summary>
            Information about a single contact in a nonconvex collidable pair.
            Nonconvex pairs can have different surface bases at each contact point, since the contact surface is not guaranteed to be a plane.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.Offset">
            <summary>
            Offset from the position of collidable A to the contact position. 
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.Depth">
            <summary>
            Penetration depth between the two collidables at this contact. Negative values represent separation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.Normal">
            <summary>
            Surface basis of the contact. If transformed into a rotation matrix, X and Z represent tangent directions and Y represents the contact normal. Points from collidable B to collidable A.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContact.FeatureId">
            <summary>
            Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the
            same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ConvexContact">
            <summary>
            Information about a single contact in a convex collidable pair. Convex collidable pairs share one surface basis across the manifold, since the contact surface is guaranteed to be a plane.
            </summary>    
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContact.Offset">
            <summary>
            Offset from the position of collidable A to the contact position. 
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContact.Depth">
            <summary>
            Penetration depth between the two collidables at this contact. Negative values represent separation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContact.FeatureId">
            <summary>
            Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the
            same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.IContactManifold`1.Count">
            <summary>
            Gets the number of contacts in the manifold.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.IContactManifold`1.Convex">
            <summary>
            Gets whether the contact manifold was created by a pair of convex objects or not. True if convex, false if nonconvex.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetFeatureId(System.Int32)">
            <summary>
            Retrieves the feature id associated with a requested contact.
            </summary>
            <param name="contactIndex">Index of the contact to grab the feature id of.</param>
            <returns>Feature id of the requested contact.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetContact(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,System.Int32@)">
            <summary>
            Retrieves a copy of a contact's data.
            </summary>
            <param name="contactIndex">Index of the contact to copy data from.</param>
            <param name="offset">Offset from the first collidable's position to the contact position.</param>
            <param name="normal">Normal of the contact surface at the requested contact. Points from collidable B to collidable A.</param>
            <param name="depth">Penetration depth at the requested contact.</param>
            <param name="featureId">Feature id of the requested contact.
            Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetDepth(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's depth.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's depth.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetNormal(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's normal. Points from collidable B to collidable A. For convex manifolds that share a normal, all contact indices will simply return a reference to the manifold-wide normal.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's normal (or the manifold-wide normal in a convex manifold).</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetOffset(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's offset.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's offset.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.IContactManifold`1.GetFeatureId(`0@,System.Int32)">
            <summary>
            Pulls a reference to a contact's feature id.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's feature id.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.NonconvexContactManifold">
            <summary>
            Contains the data associated with a nonconvex contact manifold.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContactManifold.OffsetB">
            <summary>
            Offset from collidable A to collidable B.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexContactManifold.MaximumContactCount">
            <summary>
            The maximum number of contacts that can exist within a nonconvex manifold.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetContact(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,System.Int32@)">
            <summary>
            Retrieves a copy of a contact's data.
            </summary>
            <param name="contactIndex">Index of the contact to copy data from.</param>
            <param name="offset">Offset from the first collidable's position to the contact position.</param>
            <param name="normal">Normal of the contact surface at the requested contact. Points from collidable B to collidable A.</param>
            <param name="depth">Penetration depth at the requested contact.</param>
            <param name="featureId">Feature id of the requested contact.
            Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetFeatureId(System.Int32)">
            <summary>
            Retrieves the feature id associated with a requested contact.
            </summary>
            <param name="contactIndex">Index of the contact to grab the feature id of.</param>
            <returns>Feature id of the requested contact.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetDepth(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's depth.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's depth.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetNormal(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's normal. Points from collidable B to collidable A.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's normal.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetOffset(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's offset.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's offset.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NonconvexContactManifold.GetFeatureId(BepuPhysics.CollisionDetection.NonconvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's feature id.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's feature id.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.ConvexContactManifold">
            <summary>
            Contains the data associated with a convex contact manifold.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContactManifold.OffsetB">
            <summary>
            Offset from collidable A to collidable B.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.ConvexContactManifold.Normal">
            <summary>
            Surface normal shared by all contacts. Points from collidable B to collidable A.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetFeatureId(System.Int32)">
            <summary>
            Retrieves the feature id associated with a requested contact.
            </summary>
            <param name="contactIndex">Index of the contact to grab the feature id of.</param>
            <returns>Feature id of the requested contact.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetContact(System.Int32,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single@,System.Int32@)">
            <summary>
            Retrieves a copy of a contact's data.
            </summary>
            <param name="contactIndex">Index of the contact to copy data from.</param>
            <param name="offset">Offset from the first collidable's position to the contact position.</param>
            <param name="normal">Normal of the contact surface at the requested contact. Points from collidable B to collidable A.</param>
            <param name="depth">Penetration depth at the requested contact.</param>
            <param name="featureId">Feature id of the requested contact.
            Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetDepth(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's depth.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's depth.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetNormal(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact manifold's normal. Points from collidable B to collidable A. Convex manifolds share a single normal across all contacts.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to the contact manifold's normal.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetOffset(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's offset.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's offset.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ConvexContactManifold.GetFeatureId(BepuPhysics.CollisionDetection.ConvexContactManifold@,System.Int32)">
            <summary>
            Pulls a reference to a contact's feature id.
            </summary>
            <param name="manifold">Manifold to pull a reference from.</param>
            <param name="contactIndex">Contact to pull data from.</param>
            <returns>Reference to a contact's feature id.</returns>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CCDContinuationIndex.Index">
            <summary>
            Gets the index of the continuation.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CCDContinuationIndex.Type">
            <summary>
            Gets the type index of the continuation.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.CCDContinuationIndex.Exists">
            <summary>
            Gets whether this index actually refers to anything. The Type and Index should only be used if this is true.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairMaterialProperties.FrictionCoefficient">
            <summary>
            Coefficient of friction to apply for the constraint. Maximum friction force will be equal to the normal force times the friction coefficient.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairMaterialProperties.MaximumRecoveryVelocity">
            <summary>
            Maximum relative velocity along the contact normal at which the collision constraint will recover from penetration. Clamps the velocity goal created from the spring settings.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairMaterialProperties.SpringSettings">
            <summary>
            Defines the constraint's penetration recovery spring properties.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.Initialize(BepuPhysics.Simulation)">
            <summary>
            Performs any required initialization logic after the Simulation instance has been constructed.
            </summary>
            <param name="simulation">Simulation that owns these callbacks.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.AllowContactGeneration(System.Int32,BepuPhysics.Collidables.CollidableReference,BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Chooses whether to allow contact generation to proceed for two overlapping collidables.
            </summary>
            <param name="workerIndex">Index of the worker that identified the overlap.</param>
            <param name="a">Reference to the first collidable in the pair.</param>
            <param name="b">Reference to the second collidable in the pair.</param>
            <returns>True if collision detection should proceed, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.ConfigureContactManifold``1(System.Int32,BepuPhysics.CollisionDetection.CollidablePair,``0@,BepuPhysics.CollisionDetection.PairMaterialProperties@)">
            <summary>
            Provides a notification that a manifold has been created for a pair. Offers an opportunity to change the manifold's details. 
            </summary>
            <param name="workerIndex">Index of the worker thread that created this manifold.</param>
            <param name="pair">Pair of collidables that the manifold was detected between.</param>
            <param name="manifold">Set of contacts detected between the collidables.</param>
            <param name="pairMaterial">Material properties of the manifold.</param>
            <returns>True if a constraint should be created for the manifold, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.AllowContactGeneration(System.Int32,BepuPhysics.CollisionDetection.CollidablePair,System.Int32,System.Int32)">
            <summary>
            Chooses whether to allow contact generation to proceed for the children of two overlapping collidables in a compound-including pair.
            </summary>
            <param name="pair">Parent pair of the two child collidables.</param>
            <param name="childIndexA">Index of the child of collidable A in the pair. If collidable A is not compound, then this is always 0.</param>
            <param name="childIndexB">Index of the child of collidable B in the pair. If collidable B is not compound, then this is always 0.</param>
            <returns>True if collision detection should proceed, false otherwise.</returns>
            <remarks>This is called for each sub-overlap in a collidable pair involving compound collidables. If neither collidable in a pair is compound, this will not be called.
            For compound-including pairs, if the earlier call to AllowContactGeneration returns false for owning pair, this will not be called. Note that it is possible
            for this function to be called twice for the same subpair if the pair has continuous collision detection enabled; 
            the CCD sweep test that runs before the contact generation test also asks before performing child pair tests.</remarks>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.ConfigureContactManifold(System.Int32,BepuPhysics.CollisionDetection.CollidablePair,System.Int32,System.Int32,BepuPhysics.CollisionDetection.ConvexContactManifold@)">
            <summary>
            Provides a notification that a manifold has been created between the children of two collidables in a compound-including pair.
            Offers an opportunity to change the manifold's details. 
            </summary>
            <param name="workerIndex">Index of the worker thread that created this manifold.</param>
            <param name="pair">Pair of collidables that the manifold was detected between.</param>
            <param name="childIndexA">Index of the child of collidable A in the pair. If collidable A is not compound, then this is always 0.</param>
            <param name="childIndexB">Index of the child of collidable B in the pair. If collidable B is not compound, then this is always 0.</param>
            <param name="manifold">Set of contacts detected between the collidables.</param>
            <returns>True if this manifold should be considered for constraint generation, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.Dispose">
            <summary>
            Releases any resources held by the callbacks. Called by the owning narrow phase when it is being disposed.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.ISupportFinder`2.HasMargin">
            <summary>
            Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.ISupportFinder`2.GetMargin(`1@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Margin associated with the shape according to this support finder.
            </summary>
            <param name="shape">Shape to find the margin of.</param>
            <param name="margin">Margin of the shape.</param>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.FaceCollisionFlag">
            <summary>
            Flag used to mark a contact as being generated by the face of a triangle in its feature id.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.MinimumDotForFaceCollision">
            <summary>
            Minimum dot product between a triangle face and the contact normal for a collision to be considered a triangle face contact.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.TestTriangle.Blocked">
            <summary>
            True if the manifold associated with this triangle has been blocked due to its detected infringement on another triangle, false otherwise.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.TestTriangle.ForceDeletionOnBlock">
            <summary>
            True if the triangle did not act as a blocker for any other manifold and so can be removed if it is blocked, false otherwise.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.MeshReduction.TestTriangle.CorrectedNormal">
            <summary>
            Normal of a triangle detected as being infringed by the manifold associated with this triangle in mesh space.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.TryGetContactConstraintAccessor(System.Int32,BepuPhysics.CollisionDetection.ContactConstraintAccessor@)">
            <summary>
            Looks up the contact constraint accessor for the given constraint type id if it exists.
            </summary>
            <param name="constraintTypeId">Constraint type id to look up a constraint accessor for.</param>
            <param name="accessor">Accessor for the given type id.</param>
            <returns>True if the constraint type id refers to a registered accessor, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.TryExtractSolverContactData``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Tries to extract contact prestep, impulse, and body reference data from the given handle. If it's not a contact constraint, returns false.
            </summary>
            <typeparam name="TExtractor">Type of the extractor used to collect contact data from the solver.</typeparam>
            <param name="constraintHandle">Constraint to try to extract data from.</param>
            <param name="extractor">Extractor used to collect contact data from the solver.</param>
            <returns>True if the constraint was a contact type, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.TryExtractSolverContactPrestepAndImpulses``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Tries to extract prestep and impulse contact data from the given handle. If it's not a contact constraint, returns false.
            </summary>
            <typeparam name="TExtractor">Type of the extractor used to collect contact data from the solver.</typeparam>
            <param name="constraintHandle">Constraint to try to extract data from.</param>
            <param name="extractor">Extractor used to collect contact data from the solver.</param>
            <returns>True if the constraint was a contact type, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase.IsContactConstraintType(System.Int32)">
            <summary>
            Gets whether a constraint type id maps to a contact constraint.
            </summary>
            <param name="constraintTypeId">Id of the constraint to check.</param>
            <returns>True if the type id refers to a contact constraint. False otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.NarrowPhase`1">
            <summary>
            Turns broad phase overlaps into contact manifolds and uses them to manage constraints in the solver.
            </summary>
            <typeparam name="TCallbacks">Type of the callbacks to use.</typeparam>
            <summary>
            When notified of a new constraint, immediately adds it to the solver.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NarrowPhase`1.ConstraintGeneratorType.Discrete">
            <summary>
            Pair which will directly produce constraints.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NarrowPhase`1.ConstraintGeneratorType.Continuous">
            <summary>
            Pair which samples a swept location for contacts and needs to be rewound to compute proper speculative depths in a post process.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase`1.PendingConstraintAddCache.FlushSequentially(BepuPhysics.Simulation,BepuPhysics.CollisionDetection.PairCache)">
            <summary>
            Flushes pending constraints into the simulation without any form of synchronization. Adds occur in the order of manifold generation.
            If the contact manifold generation is deterministic, then the result of this add will be deterministic.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.NarrowPhase`1.PendingConstraintAddCache.FlushWithSpeculativeBatches(BepuPhysics.Simulation,BepuPhysics.CollisionDetection.PairCache@)">
            <summary>
            Flushes pending constraints into the simulation without any form of synchronization. Adds occur in the order of manifold generation.
            If the contact manifold generation is deterministic, then the result of this add will be deterministic.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.TwoBodyHandles">
            <summary>
            Associated with a pair of two collidables that each are controlled by bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.EmptyCollisionCache">
            <summary>
            Special type for collision pairs that do not need to store any supplementary information.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.AwakenerPhaseOne">
            <summary>
            Phase one job in the awakener. JobIndex used to identify sub-job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.SortContactConstraintType">
            <summary>
            Sorts the constraints of a single type across all workers. Used by deterministic preflushes to schedule adds.
            Accesses no buffer pools; memory is allocated and returned on main thread.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.SpeculativeConstraintBatchSearch">
            <summary>
            Identifies a first guess at the constraint batch to which every new constraint should be added to. 
            Accesses no buffer pools; memory is allocated and returned on main thread.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.DeterministicConstraintAdd">
            <summary>
            Adds constraints to the solver and constraint graph in an order determined by the previous sorts and with the help of the speculatively computed batch targets. Locally sequential.
            Accesses main thread buffer pool when type batches are created or resized.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.NondeterministicConstraintAdd">
            <summary>
            Adds constraints to the solver and constraint graph in an order determined by the collision detection phase. If the collision detection phase is nondeterministic due to threading, then 
            this will result in nondeterministic adds to the solver.
            Accesses main thread buffer pool when type batches are created or resized.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.AwakenerPhaseTwo">
            <summary>
            Phase two job in the awakener. JobIndex used to identify sub-job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJobType.CheckFreshness">
            <summary>
            Check the freshness bytes in a region to remove stale pairs.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.Start">
            <summary>
            Start region of a CheckFreshness or SpeculativeConstraintBatchSearch job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.End">
            <summary>
            End region of a CheckFreshness or SpeculativeConstraintBatchSearch job.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.TypeIndex">
            <summary>
            Narrow phase constraint type index targeted by a SpeculativeConstraintBatchSearch or SortContactConstraintType.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.WorkerIndex">
            <summary>
            Index of the worker in which a range of constraints starts. 
            Used by SpeculativeConstraintBatchSearch.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.WorkerCount">
            <summary>
            Number of worker threads containing constraints to read in the SortContactConstraintType and NondeterministicConstraintAdd tasks.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PreflushJob.JobIndex">
            <summary>
            Index of the job. Used by AwakenerPhaseOne and AwakenerPhaseTwo tasks.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexReductionChild.OffsetA">
            <summary>
            Offset from the origin of the first shape's parent to the child's location in world space. If there is no parent, this is the zero vector.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.NonconvexReductionChild.OffsetB">
            <summary>
            Offset from the origin of the second shape's parent to the child's location in world space. If there is no parent, this is the zero vector.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollidablePairPointers.ConstraintCache">
            <summary>
            A narrowphase-specific type and index into the pair cache's constraint data set. Collision pairs which have no associated constraint, either 
            because no contacts were generated or because the constraint was filtered, will have a nonexistent ConstraintCache.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.CollidablePairPointers.CollisionDetectionCache">
            <summary>
            A narrowphase-specific type and index into a batch of custom data for the pair. Many types do not use any supplementary data, but some make use of temporal coherence
            to accelerate contact generation.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairCache.PairFreshness">
            <summary>
            Per-pair 'freshness' flags set when a pair is added or updated by the narrow phase execution. Only initialized for the duration of the narrowphase's execution.
            </summary>
            <remarks>
            This stores one byte per pair. While it could be compressed to 1 bit, that requires manually ensuring thread safety. By using bytes, we rely on the 
            atomic setting behavior for data types no larger than the native pointer size. Further, smaller sizes actually pay a higher price in terms of increased false sharing.
            Choice of data type is a balancing act between the memory bandwidth of the post analysis and the frequency of false sharing.
            </remarks>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.PairCache.PrepareFlushJobs(BepuUtilities.Collections.QuickList{BepuPhysics.CollisionDetection.NarrowPhaseFlushJob}@)">
            <summary>
            Flush all deferred changes from the last narrow phase execution.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.PairCache.CompleteConstraintAdd``1(BepuPhysics.CollisionDetection.NarrowPhase,BepuPhysics.Solver,``0@,BepuPhysics.CollisionDetection.PairCacheIndex,BepuPhysics.ConstraintHandle,BepuPhysics.CollisionDetection.CollidablePair@)">
            <summary>
            Completes the addition of a constraint by filling in the narrowphase's pointer to the constraint and by distributing accumulated impulses.
            </summary>
            <typeparam name="TContactImpulses">Count-specialized type containing cached accumulated impulses.</typeparam>
            <param name="narrowPhase">Narrow phase that triggered the constraint add.</param>
            <param name="solver">Solver containing the constraint to set the impulses of.</param>
            <param name="impulses">Warm starting impulses to apply to the contact constraint.</param>
            <param name="constraintCacheIndex">Index of the constraint cache to update.</param>
            <param name="constraintHandle">Constraint handle associated with the constraint cache being updated.</param>
            <param name="pair">Collidable pair associated with the new constraint.</param>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.PairCache.ConstraintHandleToPair">
            <summary>
            Mapping from constraint handle back to collision detection pair cache locations.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.PairCacheIndex">
            <summary>
            Packed indirection to data associated with a pair cache entry.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.PairCacheIndex.Exists">
            <summary>
            Gets whether this index actually refers to anything. The Type and Index should only be used if this is true.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.PairCacheIndex.Active">
            <summary>
            Gets whether this index refers to an active cache entry. If false, the entry exists in an inactive set.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.PairCacheIndex.Cache">
            <summary>
            Gets the index of the cache that owns the entry.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.PairCacheIndex.Type">
            <summary>
            Gets the type index of the object.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.PairCacheIndex.Index">
            <summary>
            Gets the index of the object within the type specific list.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1">
            <summary>
            Helps test the broad phase's active and static trees with a custom leaf tester.
            </summary>
            <typeparam name="TRayTester">Type used to test rays against leaves.</typeparam>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.#ctor(BepuUtilities.Memory.BufferPool,BepuPhysics.CollisionDetection.BroadPhase,`0,System.Int32)">
            <summary>
            Constructs a ray batcher for the broad phase and initializes its backing resources.
            </summary>
            <param name="pool">Pool to pull resources from.</param>
            <param name="rayTester">Ray tester used to test leaves found by the broad phase tree traversals.</param>
            <param name="batcherRayCapacity">Maximum number of rays to execute in each traversal.
            This should typically be chosen as the highest value which avoids spilling data out of L2 cache.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.Add(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,System.Int32)">
            <summary>
            Adds a ray to the batcher to test against the broad phase trees.
            If the underlying ray batcher hits its maximum capacity, all the accumulated rays will be tested against the broad phase trees and the accumulator will be reset.
            </summary>
            <param name="origin">Origin of the ray to test against the tree.</param>
            <param name="direction">Direction of the ray to test against the tree.</param>
            <param name="maximumT">Maximum distance that the ray will travel in units of the ray's length.</param>
            <param name="id">Identifier value for the ray. Leaf tests will have access to the id.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.Flush">
            <summary>
            Tests any accumulated rays against the broad phase trees and then resets the batcher.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.BroadPhaseRayBatcher`1.Dispose">
            <summary>
            Disposes the underlying batcher resources.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.SimulationRayBatcher`1">
            <summary>
            Tests batches of rays against the simulation.
            </summary>
            <typeparam name="TRayHitHandler">Type used to handle hits against objects in the simulation.</typeparam>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.SimulationRayBatcher`1.Add(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,System.Int32)">
            <summary>
            Adds a ray to the batcher to test against the simulation.
            If the underlying ray batcher hits its maximum capacity, all the accumulated rays will be tested against the simulation and the accumulator will be reset.
            </summary>
            <param name="origin">Origin of the ray to test against the simulation.</param>
            <param name="direction">Direction of the ray to test against the simulation.</param>
            <param name="maximumT">Maximum distance that the ray will travel in units of the ray's length.</param>
            <param name="id">Identifier value for the ray. Callbacks will have access to the id.</param>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.SimulationRayBatcher`1.Flush">
            <summary>
            Tests any accumulated rays against the broad phase trees and then resets the batcher.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:BepuPhysics.CollisionDetection.ISweepFilter.AllowTest(System.Int32,System.Int32)" -->
        <member name="P:BepuPhysics.CollisionDetection.SweepTask.ShapeTypeIndexA">
            <summary>
            Gets the first shape type index associated with the task.
            </summary>
        </member>
        <member name="P:BepuPhysics.CollisionDetection.SweepTask.ShapeTypeIndexB">
            <summary>
            Gets the second shape type index associated with the task.
            </summary>
        </member>
        <member name="M:BepuPhysics.CollisionDetection.UntypedList.Allocate(System.Int32,System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Allocates an element in the list, initializing the backing buffer if needed.
            </summary>
            <param name="elementSizeInBytes">Number of bytes per element.</param>
            <param name="minimumElementCount">Minimum size of the backing buffer to create if this is a new allocation.</param>
            <param name="pool">Pool to pull allocations from.</param>
            <returns>Index of the element in bytes within the list's buffer.</returns>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.WideRayTester">
            <summary>
            Helper class for creating runtime specialized vectorized ray intersection tests with shapes that support broadcasting.
            </summary>
        </member>
        <member name="T:BepuPhysics.CollisionDetection.WorkerPairCache">
            <summary>
            The cached pair data created by a single worker during the last execution of narrow phase pair processing.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.WorkerPairCache.PendingAdds">
            <summary>
            The set of pair-pointer associations created by this worker that should be added to the pair mapping.
            </summary>
        </member>
        <member name="F:BepuPhysics.CollisionDetection.WorkerPairCache.PendingRemoves">
            <summary>
            The set of pairs to remove from the pair cache generated by the worker.
            </summary>
        </member>
        <member name="T:BepuPhysics.ConstraintBatch">
            <summary>
            Contains a set of type batches whose constraints share no body references.
            </summary>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.GetTypeBatch(System.Int32)">
            <summary>
            Gets a type batch in the batch matching the given type id.
            Requires that there exists at least one constraint in the type batch.
            </summary>
            <param name="typeId">Id of the TypeBatch's type to retrieve.</param>
            <returns>TypeBatch instance associated with the given type.</returns>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.GetTypeBatchPointer(System.Int32)">
            <summary>
            Gets a pointer to the type batch in the batch matching the given type id.
            Requires that there exists at least one constraint in the type batch.
            </summary>
            <param name="typeId">Id of the TypeBatch's type to retrieve.</param>
            <returns>TypeBatch instance associated with the given type.</returns>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.EnsureTypeBatchCapacities(BepuPhysics.Solver)">
            <summary>
            Ensures that all type batches within this constraint batch meet or exceed the size requirements of the per-type capacities defined by the solver.
            </summary>
            <param name="solver">Solver to pull minimum capacities from.</param>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.ResizeTypeBatchCapacities(BepuPhysics.Solver)">
            <summary>
            Applies the solver-defined minimum capacities to existing type batches.
            </summary>
            <param name="solver">Solver to pull minimum capacities from.</param>
        </member>
        <member name="M:BepuPhysics.ConstraintBatch.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Releases all memory used by the batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.ConstraintGraphRemovalEnumerator">
            <summary>
            Enumerates the bodies attached to an active constraint and removes the constraint's handle from all of the connected body constraint reference lists.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLayoutOptimizer.Optimization.BundleIndex">
            <summary>
            Index of the target constraint bundle to optimize.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLayoutOptimizer.Optimization.TypeBatchIndex">
            <summary>
            Index of the last optimized type batch.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLayoutOptimizer.Optimization.BatchIndex">
            <summary>
            Index of the last optimized batch.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintLayoutOptimizer.shouldOffset">
            <summary>
            If true, regions are offset by a half region width. Toggled each frame. Offsets allow the sorted regions to intermix, eventually converging to a full sort.
            </summary>
        </member>
        <member name="P:BepuPhysics.ConstraintSet.BundleCount">
            <summary>
            Gets the total number of bundles across all types and batches.
            </summary>
        </member>
        <member name="P:BepuPhysics.ConstraintSet.ConstraintCount">
            <summary>
            Gets the total number of bundles across all types and batches.
            </summary>
        </member>
        <member name="P:BepuPhysics.ConstraintSet.Allocated">
            <summary>
            Gets whether this constraint set is allocated. 
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularAxisMotor">
            <summary>
            Constrains two bodies to rotate around a local axis attached to body A at a target velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisMotor.LocalAxisA">
            <summary>
            Axis of rotation in body A's local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisMotor.TargetVelocity">
            <summary>
            Target relative angular velocity around the axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularAxisMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularHinge">
            <summary>
            Angular component of a hinge. Constrains the angular degrees of freedom of two bodies such that they can only rotate relative to each other around the hinge's axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularHinge.LocalHingeAxisA">
            <summary>
            Hinge axis in the local space of A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularHinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularHinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularMotor">
            <summary>
            Constrains the relative angular velocity between two bodies to a target.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularMotor.TargetVelocityLocalA">
            <summary>
            Target relative angular velocity between A and B, stored in A's local space. Target world space angular velocity of B is AngularVelocityA + TargetVelocityLocalA * OrientationA.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularServo">
            <summary>
            Constrains two bodies to have a target relative rotation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularServo.TargetRelativeRotationLocalA">
            <summary>
            The target relative rotation from body A to body B in body A's local space. The constraint tries to maintain OrientationB = TargetRelativeRotationLocalA * OrientationA.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AngularSwivelHinge">
            <summary>
            Constrains two bodies with the angular component of a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularSwivelHinge.LocalSwivelAxisA">
            <summary>
            Swivel axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularSwivelHinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of body B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AngularSwivelHinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.AreaConstraint">
            <summary>
            Constrains the area of a triangle connecting the centers of three bodies to match a goal area. 
            Scaled volume computed from ||ab x ac||.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AreaConstraint.TargetScaledArea">
            <summary>
            2 times the target area of the triangle. Computed from ||ab x ac||.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.AreaConstraint.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.AreaConstraint.#ctor(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,BepuPhysics.Constraints.SpringSettings)">
            <summary>
            Creates a new area constraint, initializing the target area using a set of initial positions.
            </summary>
            <param name="a">Initial position of the first body.</param>
            <param name="b">Initial position of the second body.</param>
            <param name="c">Initial position of the third body.</param>
            <param name="springSettings">Spring settings to apply to the volume constraint.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.AreaConstraintTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocket">
            <summary>
            Constrains a point on one body to a point on another body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocket.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocket.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocket.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketMotor">
            <summary>
            Constrains the relative linear velocity between two bodies to a target.
            Conceptually, controls the relative velocity by a virtual lever arm attached to the center of A and leading to the anchor of B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketMotor.LocalOffsetB">
            <summary>
            Offset from body B to its anchor.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketMotor.TargetVelocityLocalA">
            <summary>
            Target relative linear velocity between A and B, stored in A's local space. Target world space linear velocity of B is LinearVelocityA + TargetVelocityLocalA * OrientationA.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketMotorTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket motor constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketServo">
            <summary>
            Constrains a point on one body to a point on another body.
            Provides speed and force configuration that the BallSocket joint does not.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.BallSocketServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketServoTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket servo constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.BallSocketShared">
            <summary>
            Provides shared functionality for constraints with jacobians similar to the BallSocket.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.CenterDistanceConstraint">
            <summary>
            Constrains the center of two bodies to be separated by a goal distance.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.CenterDistanceConstraint.TargetDistance">
            <summary>
            Target distance between the body centers.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.CenterDistanceConstraint.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.CenterDistanceTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of distance servos.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsFiniteNumber(System.Single)">
            <summary>
            Checks if a value is a finite number- neither infinite nor NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is neither infinite nor NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsPositiveNumber(System.Single)">
            <summary>
            Checks if a value is a finite value greater than zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number greater than zero and not NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsNonnegativeNumber(System.Single)">
            <summary>
            Checks if a value is a finite value greater than or equal to zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number greater than or equal to zero and not NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsNegativeNumber(System.Single)">
            <summary>
            Checks if a value is a finite value less than zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number less than zero and not NaN, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.ConstraintChecker.IsNonpositiveNumber(System.Single)">
            <summary>
            Checks if a value is a finite value less than or equal to zero and not NaN.
            </summary>
            <param name="value">Value to check.</param>
            <returns>True if the value is a finite number less than or equal to zero and not NaN, false otherwise.</returns>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact1OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 1-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4OneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact1TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 1-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4TypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2NonconvexTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact nonconvex two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact2NonconvexOneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 2-contact nonconvex one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3NonconvexTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact nonconvex two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact3NonconvexOneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 3-contact nonconvex one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4NonconvexTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact nonconvex two body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.Contact4NonconvexOneBodyTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of 4-contact nonconvex one body manifold constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor">
            <summary>
            Callbacks for direct references to the solver's contact constraint data.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.ConvexOneBody``2(BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a convex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandle">Body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.ConvexTwoBody``2(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a convex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandleA">First body handle referenced by the constraint.</param>
            <param name="bodyHandleB">Second body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.NonconvexOneBody``2(BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandle">Body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.NonconvexTwoBody``2(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="bodyHandleA">First body handle referenced by the constraint.</param>
            <param name="bodyHandleB">Second body handle referenced by the constraint.</param>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor">
            <summary>
            Callbacks for direct references to the solver's contact constraint data. Includes only prestep and impulse data.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.ConvexOneBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a convex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.ConvexTwoBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a convex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.NonconvexOneBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.NonconvexTwoBody``2(``0@,``1@)">
            <summary>
            Provides a reference to a nonconvex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors).
            </summary>
            <typeparam name="TPrestep">Type of the prestep data returned.</typeparam>
            <typeparam name="TAccumulatedImpulses">Type of the accumulated impulses data returned.</typeparam>
            <param name="prestep">Prestep data associated with the constraint.</param>
            <param name="impulses">Accumulated impulses associated with the constraint.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.PenetrationLimit.ApplyImpulse(BepuPhysics.Constraints.Contact.PenetrationLimitProjection@,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.PenetrationLimitOneBody.ApplyImpulse(BepuPhysics.Constraints.Contact.PenetrationLimitOneBodyProjection@,BepuPhysics.BodyInertias@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocities@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TangentFriction">
            <summary>
            Handles the tangent friction implementation.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TangentFriction.ApplyImpulse(BepuPhysics.Constraints.Contact.TangentFriction.Jacobians@,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@,BepuUtilities.Vector2Wide@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TangentFrictionOneBody">
            <summary>
            Handles the tangent friction implementation for one body contact constraints.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TangentFrictionOneBody.ApplyImpulse(BepuPhysics.Constraints.Contact.TangentFrictionOneBody.Jacobians@,BepuPhysics.BodyInertias@,BepuUtilities.Vector2Wide@,BepuPhysics.BodyVelocities@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TwistFriction">
            <summary>
            Handles the tangent friction implementation.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TwistFriction.ApplyImpulse(BepuUtilities.Vector3Wide@,BepuPhysics.BodyInertias@,BepuPhysics.BodyInertias@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Contact.TwistFrictionOneBody">
            <summary>
            Handles the tangent friction implementation.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.Contact.TwistFrictionOneBody.ApplyImpulse(BepuUtilities.Vector3Wide@,BepuPhysics.BodyInertias@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocities@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceLimit">
            <summary>
            Constrains points on two bodies to be separated by a distance within a range.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.MinimumDistance">
            <summary>
            Minimum distance permitted between the point on A and the point on B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.MaximumDistance">
            <summary>
            Maximum distance permitted between the point on A and the point on B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.DistanceLimit.#ctor(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,System.Single,BepuPhysics.Constraints.SpringSettings@)">
            <summary>
            Creates a distance limit description.
            </summary>
            <param name="localOffsetA">Local offset from the center of body A to its attachment point.</param>
            <param name="localOffsetB">Local offset from the center of body B to its attachment point.</param>
            <param name="minimumDistance">Minimum distance permitted between the point on A and the point on B.</param>
            <param name="maximumDistance">Maximum distance permitted between the point on A and the point on B.</param>
            <param name="springSettings">Spring frequency and damping parameters.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceLimitTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of distance servos.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceServo">
            <summary>
            Constrains points on two bodies to be separated by a goal distance.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.TargetDistance">
            <summary>
            Distance that the constraint will try to reach between the attachment points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.DistanceServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.DistanceServo.#ctor(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,BepuPhysics.Constraints.SpringSettings@,BepuPhysics.Constraints.ServoSettings@)">
            <summary>
            Creates a distance servo description.
            </summary>
            <param name="localOffsetA">Local offset from the center of body A to its attachment point.</param>
            <param name="localOffsetB">Local offset from the center of body B to its attachment point.</param>
            <param name="targetDistance">Distance that the constraint will try to reach between the attachment points.</param>
            <param name="springSettings">Spring frequency and damping parameters.</param>
            <param name="servoSettings">Servo control parameters.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.DistanceServoTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of distance servos.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.FourBodyReferences">
            <summary>
            A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IFourBodyConstraintFunctions`3">
            <summary>
            Prestep, warm start and solve iteration functions for a four body constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
            <typeparam name="TProjection">Type of the projection to input.</typeparam>
        </member>
        <member name="T:BepuPhysics.Constraints.FourBodyTypeProcessor`4">
            <summary>
            Shared implementation across all four body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Hinge">
            <summary>
            Constrains two bodies with a hinge. Equivalent to a BallSocket constraint and an AngularHinge constraint solved together.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalHingeAxisA">
            <summary>
            Hinge axis in the local space of A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Hinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IConstraintDescription`1">
            <summary>
            Marks a type as a description of a constraint associated with a particular batch.
            </summary>
            <remarks>
            Note that one batch may have multiple description types associated with it, each one potentially offering a different subset of properties or translation logic.
            </remarks>
            <typeparam name="TDescription">Type of the description object.</typeparam>
        </member>
        <member name="M:BepuPhysics.Constraints.IConstraintDescription`1.ApplyDescription(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32)">
            <summary>
            Changes the batch-held memory at a given location to match the given description.
            </summary>
            <param name="batch">Batch to modify.</param>
            <param name="bundleIndex">Index of the target constraint's bundle.</param>
            <param name="innerIndex">Index of the target constraint within its bundle.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.IConstraintDescription`1.BuildDescription(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,`0@)">
            <summary>
            Creates a description from the batch-held memory at a given location.
            </summary>
            <param name="batch">Batch to read.</param>
            <param name="bundleIndex">Index of the source constraint's bundle.</param>
            <param name="innerIndex">Index of the source constraint within its bundle.</param>
            <param name="description">Description of the constraint.</param>
        </member>
        <member name="P:BepuPhysics.Constraints.IConstraintDescription`1.ConstraintTypeId">
            <summary>
            Gets the type id of the constraint that this is a description of.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.IConstraintDescription`1.TypeProcessorType">
            <summary>
            Gets the type of the type batch which contains described constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IOneBodyConstraintDescription`1">
            <summary>
            Marks a type as a one body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="T:BepuPhysics.Constraints.ITwoBodyConstraintDescription`1">
            <summary>
            Marks a type as a two body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="T:BepuPhysics.Constraints.IThreeBodyConstraintDescription`1">
            <summary>
            Marks a type as a three body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="T:BepuPhysics.Constraints.IFourBodyConstraintDescription`1">
            <summary>
            Marks a type as a four body constraint description.
            </summary>
            <typeparam name="TDescription">Type of the description.</typeparam>
            <remarks>This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts.</remarks>
        </member>
        <member name="M:BepuPhysics.Constraints.Inequality2Body1DOF.ApplyImpulse(BepuPhysics.Constraints.Projection2Body1DOF@,System.Numerics.Vector{System.Single}@,BepuPhysics.BodyVelocities@,BepuPhysics.BodyVelocities@)">
            <summary>
            Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.LinearAxisLimit">
            <summary>
            Constrains points on two bodies to a range of offsets from each other along a direction anchored to body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.LocalAxis">
            <summary>
            Direction of the motorized axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.MinimumOffset">
            <summary>
            Minimum offset along the world axis between A and B's anchor points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.MaximumOffset">
            <summary>
            Maximum offset along the world axis between A and B's anchor points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.LinearAxisMotor">
            <summary>
            Constrains points on two bodies to move relative to each other along a direction.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.LocalAxis">
            <summary>
            Direction of the motorized axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.TargetVelocity">
            <summary>
            Target relative velocity along the world axis between A and B's anchor points.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.LinearAxisServo">
            <summary>
            Constrains points on two bodies to be on a plane defined in the local space of one of the bodies.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.LocalPlaneNormal">
            <summary>
            Direction of the plane normal in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.TargetOffset">
            <summary>
            Target offset from A's plane anchor to B's anchor along the plane normal.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.LinearAxisServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.MotorSettings">
            <summary>
            Defines some of the shared behavior across motor constraints.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.MotorSettings.MaximumForce">
            <summary>
            Maximum amount of force the motor can apply in one unit of time.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.MotorSettings.Damping">
            <summary>
            Mass-scaled damping constant. If you want to simulate a viscous damping coefficient of D with an object of mass M, set this damping value to D / M.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.MotorSettings.Softness">
            <summary>
            Gets or sets how soft the constraint is. Values range from 0 to infinity. Softness is inverse damping; 0 is perfectly rigid, 1 is very soft, float.MaxValue is effectively nonexistent.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.MotorSettings.Validate(BepuPhysics.Constraints.MotorSettings@)">
            <summary>
            Checks if a settings instance has valid nonnegative values.
            </summary>
            <param name="settings">Instance to examine.</param>
            <returns>True if the settings are valid, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.MotorSettings.#ctor(System.Single,System.Single)">
            <summary>
            Defines settings for a motor constraint.
            </summary>
            <param name="maximumForce">Maximum amount of force the motor can apply in one unit of time.</param>
            <param name="softness">Gets or sets how soft the constraint is. Values range from 0 to infinity. Softness is inverse damping; 0 is perfectly rigid, 1 is very soft, float.MaxValue is effectively nonexistent.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyAngularMotor">
            <summary>
            Constrains the angular velocity of one body to the target.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularMotor.TargetVelocity">
            <summary>
            Target angular velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyAngularServo">
            <summary>
            Constrains a single body to a target orientation.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularServo.TargetOrientation">
            <summary>
            Target orientation of the constraint.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyAngularServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyLinearMotor">
            <summary>
            Constrains a point on a body to have a target linear velocity.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearMotor.LocalOffset">
            <summary>
            Offset to the attachment point in the local space of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearMotor.TargetVelocity">
            <summary>
            Target velocity of the attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyLinearServo">
            <summary>
            Constrains a point on a body to a target location.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.LocalOffset">
            <summary>
            Offset to the attachment point in the local space of the body.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.Target">
            <summary>
            Target position.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.OneBodyLinearServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IOneBodyConstraintFunctions`3">
            <summary>
            Prestep, warm start and solve iteration functions for a constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
            <typeparam name="TProjection">Type of the projection to input.</typeparam>
        </member>
        <member name="T:BepuPhysics.Constraints.IOneBodyContactConstraintFunctions`3">
            <summary>
            Prestep, warm start, solve iteration, and incremental contact update functions for a one body contact constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
            <typeparam name="TProjection">Type of the projection to input.</typeparam>
        </member>
        <member name="T:BepuPhysics.Constraints.OneBodyTypeProcessor`4">
            <summary>
            Shared implementation across all one body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.PointOnLineServo">
            <summary>
            Constrains a point on body B to be on a line attached to body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.LocalDirection">
            <summary>
            Direction of the line in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.PointOnLineServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.ServoSettings.Default">
            <summary>
            Gets settings representing a servo with unlimited force, speed, and no base speed.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.ServoSettings.Validate(BepuPhysics.Constraints.ServoSettings@)">
            <summary>
            Checks servo settings to ensure valid values.
            </summary>
            <param name="settings">Settings to check.</param>
            <returns>True if the settings contain valid values, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.SpringSettingsWide.ComputeSpringiness(BepuPhysics.Constraints.SpringSettingsWide@,System.Single,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes springiness values for a set of constraints.
            </summary>
            <param name="settings">Spring settings associated with the constraints.</param>
            <param name="dt">Duration of the time step.</param>
            <param name="positionErrorToVelocity">The multiplier applied to error to get bias velocity.</param>
            <param name="effectiveMassCFMScale">Scaling factor to apply to the effective mass to get the softened effective mass.</param>
            <param name="softnessImpulseScale">Scaling factor to apply to the accumulated impulse during the solve to soften the target velocity.</param>
        </member>
        <member name="F:BepuPhysics.Constraints.SpringSettings.AngularFrequency">
            <summary>
            Target number of undamped oscillations per unit of time, scaled by 2 * PI.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SpringSettings.TwiceDampingRatio">
            <summary>
            Twice the ratio of the spring's actual damping to its critical damping.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.SpringSettings.Frequency">
            <summary>
            Gets or sets the target number of undamped oscillations per unit of time.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.SpringSettings.DampingRatio">
            <summary>
            Gets or sets the ratio of the spring's actual damping to its critical damping. 0 is undamped, 1 is critically damped, and higher values are overdamped.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.SpringSettings.Validate(BepuPhysics.Constraints.SpringSettings@)">
            <summary>
            Checks if a spring settings instance contains valid values.
            </summary>
            <param name="springSettings">Settings to check.</param>
            <returns>True if the spring settings are valid, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.SpringSettings.#ctor(System.Single,System.Single)">
            <summary>
            Constructs a new spring settings instance.
            </summary>
            <param name="frequency">Target number of undamped oscillations per unit of time.</param>
            <param name="dampingRatio">Ratio of the spring's actual damping to its critical damping. 0 is undamped, 1 is critically damped, and higher values are overdamped.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.SwingLimit">
            <summary>
            Restricts axes attached to two bodies to fall within a maximum swing angle.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.AxisLocalA">
            <summary>
            Axis attached to body A in its local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.AxisLocalB">
            <summary>
            Axis attached to body B in its local space.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.MinimumDot">
            <summary>
            Minimum dot product between the world space A and B axes that the constraint attempts to maintain.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwingLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.SwingLimit.MaximumSwingAngle">
            <summary>
            Gets or sets the maximum swing angle that the constraint allows between world axis A and B. Based on the MinimumDot field.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.SwivelHinge">
            <summary>
            Constrains two bodies with a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen. Equivalent to a BallSocket constraint and an AngularSwivelHinge constraint solved together.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalOffsetA">
            <summary>
            Local offset from the center of body A to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalSwivelAxisA">
            <summary>
            Swivel axis in the local space of body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalOffsetB">
            <summary>
            Local offset from the center of body B to its attachment point.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.LocalHingeAxisB">
            <summary>
            Hinge axis in the local space of body B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.SwivelHinge.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.ThreeBodyReferences">
            <summary>
            A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IThreeBodyConstraintFunctions`3">
            <summary>
            Prestep, warm start and solve iteration functions for a three body constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
            <typeparam name="TProjection">Type of the projection to input.</typeparam>
        </member>
        <member name="T:BepuPhysics.Constraints.ThreeBodyTypeProcessor`4">
            <summary>
            Shared implementation across all four body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwistLimit">
            <summary>
            Constrains two bodies' rotations around attached twist axes to a range of permitted twist angles.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.LocalBasisA">
            <summary>
            Local space basis attached to body A against which to measure body B's transformed axis. Expressed as a 3x3 rotation matrix, the X axis corresponds with 0 degrees, 
            the Y axis corresponds to 90 degrees, and the Z axis is the twist axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.LocalBasisB">
            <summary>
            Local space basis attached to body B that will be measured against body A's basis.
            Expressed as a 3x3 rotation matrix, the transformed X axis will be measured against A's X and Y axes. The Z axis is the twist axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.MinimumAngle">
            <summary>
            Minimum angle between B's axis to measure and A's measurement axis. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.MaximumAngle">
            <summary>
            Maximum angle between B's axis to measure and A's measurement axis. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistLimit.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwistMotor">
            <summary>
            Constrains the twist velocity between two bodies to a target.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.LocalAxisA">
            <summary>
            Local twist axis attached to body A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.LocalAxisB">
            <summary>
            Local twist axis attached to body B.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.TargetVelocity">
            <summary>
            Goal relative twist velocity around the body axes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistMotor.Settings">
            <summary>
            Motor control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwistServo">
            <summary>
            Constrains two bodies to maintain a target twist angle around body-attached axes.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.LocalBasisA">
            <summary>
            Local space basis attached to body A against which to measure body B's transformed axis. Expressed as a 3x3 rotation matrix, the X axis corresponds with 0 degrees, 
            the Y axis corresponds to 90 degrees, and the -Z axis is the twist axis. When viewed along the twist axis, positive change in angle causes counterclockwise rotation in right handed coordinates.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.LocalBasisB">
            <summary>
            Local space basis attached to body B that will be measured against body A's basis.
            Expressed as a 3x3 rotation matrix, the transformed X axis will be measured against A's X and Y axes. The Z axis is the twist axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.TargetAngle">
            <summary>
            Target angle between B's axis to measure and A's measurement axis. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.TwistServo.ServoSettings">
            <summary>
            Servo control parameters.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TwoBodyReferences">
            <summary>
            A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve.
            Two address streams isn't much of a problem for prefetching.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.IConstraintFunctions`3">
            <summary>
            Prestep, warm start and solve iteration functions for a two body constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
            <typeparam name="TProjection">Type of the projection to input.</typeparam>
        </member>
        <member name="T:BepuPhysics.Constraints.IContactConstraintFunctions`3">
            <summary>
            Prestep, warm start, solve iteration, and incremental contact update functions for a two body contact constraint type.
            </summary>
            <typeparam name="TPrestepData">Type of the prestep data used by the constraint.</typeparam>
            <typeparam name="TAccumulatedImpulse">Type of the accumulated impulses used by the constraint.</typeparam>
            <typeparam name="TProjection">Type of the projection to input.</typeparam>
        </member>
        <member name="T:BepuPhysics.Constraints.TwoBodyTypeProcessor`4">
            <summary>
            Shared implementation across all two body constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TypeBatch">
            <summary>
            Stores the raw AOSOA formatted data associated with constraints in a type batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.TypeProcessor">
            <summary>
            Superclass of constraint type batch processors. Responsible for interpreting raw type batches for the purposes of bookkeeping and solving.
            </summary>
            <remarks>
            <para>This class holds no actual state of its own. A solver creates a unique type processor for each registered constraint type, and all instances are held in untyped memory.
            Splitting the functionality from the data allows for far fewer GC-tracked instances and allows the raw data layout to be shared more easily.</para>
            <para>For example, sleeping simulation islands store type batches, but they are created and used differently- and for convenience, they are stored on a per-island basis.
            Using the same system but with reference type TypeBatches, tens of thousands of inactive islands would imply tens of thousands of GC-tracked objects.</para>
            That's not acceptable, so here we are. 
            <para>Conceptually, you can think of the solver's array of TypeProcessors like C function pointers.</para>
            </remarks>
        </member>
        <member name="P:BepuPhysics.Constraints.TypeProcessor.BodiesPerConstraint">
            <summary>
            Gets the number of bodies associated with each constraint in this type processor.
            </summary>
        </member>
        <member name="P:BepuPhysics.Constraints.TypeProcessor.ConstrainedDegreesOfFreedom">
            <summary>
            Gets the number of degrees of freedom that each constraint in this type processor constrains. Equal to the number of entries in the accumulated impulses.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor.Allocate(BepuPhysics.Constraints.TypeBatch@,BepuPhysics.ConstraintHandle,System.Int32*,BepuUtilities.Memory.BufferPool)">
            <summary>
            Allocates a slot in the batch.
            </summary>
            <param name="typeBatch">Type batch to allocate in.</param>
            <param name="handle">Handle of the constraint to allocate. Establishes a link from the allocated constraint to its handle.</param>
            <param name="bodyIndices">Pointer to a list of body indices (not handles!) with count equal to the type batch's expected number of involved bodies.</param>
            <param name="pool">Allocation provider to use if the type batch has to be resized.</param>
            <returns>Index of the slot in the batch.</returns>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor.TransferConstraint(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,BepuPhysics.Solver,BepuPhysics.Bodies,System.Int32)">
            <summary>
            Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type.
            </summary>
            <param name="sourceBatchIndex">Index of the batch that owns the type batch that is the source of the constraint transfer.</param>
            <param name="indexInTypeBatch">Index of the constraint to move in the current type batch.</param>
            <param name="solver">Solver that owns the batches.</param>
            <param name="bodies">Bodies set that owns all the constraint's bodies.</param>
            <param name="targetBatchIndex">Index of the ConstraintBatch in the solver to copy the constraint into.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.ISortKeyGenerator`1">
            <summary>
            Defines a function that creates a sort key from body references in a type batch. Used by constraint layout optimization.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor`4.Move(`0@,`1@,`3@,BepuPhysics.ConstraintHandle,System.Int32,`0@,`1@,`3@,BepuPhysics.ConstraintHandle@,System.Int32,System.Int32,BepuUtilities.Memory.Buffer{BepuPhysics.ConstraintLocation}@)">
            <summary>
            Overwrites all the data in the target constraint slot with source data.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor`4.Remove(BepuPhysics.Constraints.TypeBatch@,System.Int32,BepuUtilities.Memory.Buffer{BepuPhysics.ConstraintLocation}@)">
            <summary>
            Removes a constraint from the batch.
            </summary>
            <param name="index">Index of the constraint to remove.</param>
            <param name="handlesToConstraints">The handle to constraint mapping used by the solver that could be modified by a swap on removal.</param>
        </member>
        <member name="M:BepuPhysics.Constraints.TypeProcessor`4.TransferConstraint(BepuPhysics.Constraints.TypeBatch@,System.Int32,System.Int32,BepuPhysics.Solver,BepuPhysics.Bodies,System.Int32)">
            <summary>
            Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type.
            </summary>
            <param name="sourceBatchIndex">Index of the batch that owns the type batch that is the source of the constraint transfer.</param>
            <param name="indexInTypeBatch">Index of the constraint to move in the current type batch.</param>
            <param name="solver">Solver that owns the batches.</param>
            <param name="bodies">Bodies set that owns all the constraint's bodies.</param>
            <param name="targetBatchIndex">Index of the ConstraintBatch in the solver to copy the constraint into.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.VolumeConstraint">
            <summary>
            Constrains the volume of a tetrahedron connecting the centers of four bodies to match a goal volume. 
            Scaled volume computed from (ab x ac) * ad; the volume may be negative depending on the winding of the tetrahedron.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.VolumeConstraint.TargetScaledVolume">
            <summary>
            6 times the target volume of the tetrahedra. Computed from (ab x ac) * ad; this may be negative depending on the winding of the tetrahedron.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.VolumeConstraint.SpringSettings">
            <summary>
            Spring frequency and damping parameters.
            </summary>
        </member>
        <member name="M:BepuPhysics.Constraints.VolumeConstraint.#ctor(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,BepuPhysics.Constraints.SpringSettings)">
            <summary>
            Creates a new volume constraint, initializing the target volume using a set of initial positions.
            </summary>
            <param name="a">Initial position of the first body.</param>
            <param name="b">Initial position of the second body.</param>
            <param name="c">Initial position of the third body.</param>
            <param name="d">Initial position of the fourth body.</param>
            <param name="springSettings">Spring settings to apply to the volume constraint.</param>
        </member>
        <member name="T:BepuPhysics.Constraints.VolumeConstraintTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of volume constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.Weld">
            <summary>
            Constrains two bodies to maintain a relative position and orientation. All six degrees of freedom are solved simultaneously.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Weld.LocalOffset">
            <summary>
            Offset from body A to body B in the local space of A.
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Weld.LocalOrientation">
            <summary>
            Target orientation of body B in body A's local space. 
            </summary>
        </member>
        <member name="F:BepuPhysics.Constraints.Weld.SpringSettings">
            <summary>
            Springiness of the position and orientation constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.Constraints.WeldTypeProcessor">
            <summary>
            Handles the solve iterations of a bunch of ball socket constraints.
            </summary>
        </member>
        <member name="T:BepuPhysics.DefaultTypes">
            <summary>
            Helper class to register the default types within a simulation instance.
            </summary>
        </member>
        <member name="M:BepuPhysics.DefaultTypes.RegisterDefaults(BepuPhysics.Solver,BepuPhysics.CollisionDetection.NarrowPhase)">
            <summary>
            Registers the set of constraints that are packaged in the engine.
            </summary>
        </member>
        <member name="M:BepuPhysics.DefaultTypes.CreateDefaultCollisionTaskRegistry">
            <summary>
            Creates a task registry containing the default collision pair types.
            </summary>
        </member>
        <member name="M:BepuPhysics.DefaultTypes.CreateDefaultSweepTaskRegistry">
            <summary>
            Creates a task registry containing the default sweep task types.
            </summary>
        </member>
        <member name="T:BepuPhysics.FallbackBatch">
            <summary>
            Contains constraints that could not belong to any lower constraint batch due to their involved bodies. All of the contained constraints will be solved using a fallback solver that
            trades rigidity for parallelism.
            </summary>
        </member>
        <member name="P:BepuPhysics.FallbackBatch.BodyCount">
            <summary>
            Gets the number of bodies in the fallback batch.
            </summary>
        </member>
        <member name="T:BepuPhysics.BodyHandle">
            <summary>
            Unique identifier of a body belonging to a simulation's Bodies collection.
            </summary>
        </member>
        <member name="F:BepuPhysics.BodyHandle.Value">
            <summary>
            Index in the handle-to-memory mapping table used to look up the current memory location of the body. 
            This value will not (and must not) change during the body's lifespan, but the memory that the table points to could change.
            </summary>
        </member>
        <member name="T:BepuPhysics.StaticHandle">
            <summary>
            Unique identifier of a static belonging to a simulation's Statics collection.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticHandle.Value">
            <summary>
            Index in the handle-to-memory mapping table used to look up the current memory location of the body. 
            This value will not (and must not) change during the body's lifespan, but the memory that the table points to could change.
            </summary>
        </member>
        <member name="T:BepuPhysics.ConstraintHandle">
            <summary>
            Unique identifier of a constraint belonging to a simulation's Solver.
            </summary>
        </member>
        <member name="F:BepuPhysics.ConstraintHandle.Value">
            <summary>
            Index in the handle-to-memory mapping table used to look up the current memory location of the constraint. 
            This value will not (and must not) change during the constraint's lifespan, but the memory that the table points to could change.
            </summary>
        </member>
        <member name="T:BepuPhysics.ActiveConstraintBodyHandleCollector">
            <summary>
            Collects body handles associated with an active constraint as integers.
            </summary>
        </member>
        <member name="T:BepuPhysics.Helpers">
            <summary>
            Shared miscellaneous helper functions.
            </summary>
        </member>
        <member name="T:BepuPhysics.IslandAwakener">
            <summary>
            Provides functionality for efficiently waking up sleeping bodies.
            </summary>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenBody(BepuPhysics.BodyHandle)">
            <summary>
            Wakes up a body if it is sleeping. All bodies that can be found by traversing the constraint graph from the body will also be awakened.
            If the body is already awake, this does nothing.
            </summary>
            <param name="bodyHandle">Handle of the body to awaken.</param>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenConstraint(BepuPhysics.ConstraintHandle)">
            <summary>
            Wakes up any sleeping bodies associated with a constraint. All bodies that can be found by traversing the constraint graph from the constraint referenced bodies will also be awakened.
            If all bodies associated with the constraint are already awake, this does nothing.
            </summary>
            <param name="constraintHandle">Handle of the constraint to awaken.</param>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenSet(System.Int32)">
            <summary>
            Wakes up all bodies and constraints within a set. Doesn't do anything if the set is awake (index zero).
            </summary>
            <param name="setIndex">Index of the set to awaken.</param>
        </member>
        <member name="M:BepuPhysics.IslandAwakener.AwakenSets(BepuUtilities.Collections.QuickList{System.Int32}@,BepuUtilities.IThreadDispatcher)">
            <summary>
            Awakens a list of set indices.
            </summary>
            <param name="setIndices">List of set indices to wake up.</param>
            <param name="threadDispatcher">Thread dispatcher to use when waking the bodies. Pass null to run on a single thread.</param>
        </member>
        <member name="T:BepuPhysics.IslandScaffold">
            <summary>
            Represents the constraint batch structure and all references in an island. Holds everything necessary to create and gather a full island.
            </summary>
        </member>
        <member name="P:BepuPhysics.IslandSleeper.TestedFractionPerFrame">
            <summary>
            Gets or sets the multiplier applied to the active body count used to calculate the number of sleep traversals in a given timestep.
            </summary>
        </member>
        <member name="P:BepuPhysics.IslandSleeper.TargetSleptFraction">
            <summary>
            Gets or sets the fraction of the active set to target as the number of bodies slept in a given frame.
            This is only a goal; the actual number of slept bodies may be more or less.
            </summary>
        </member>
        <member name="P:BepuPhysics.IslandSleeper.TargetTraversedFraction">
            <summary>
            Gets or sets the fraction of the active set to target as the number of bodies traversed for sleeping in a given frame.
            This is only a goal; the actual number of traversed bodies may be more or less.
            </summary>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.CollectIsland``1(BepuUtilities.Memory.BufferPool,System.Int32,``0@,BepuUtilities.Collections.QuickList{System.Int32}@,BepuUtilities.Collections.QuickList{BepuPhysics.ConstraintHandle}@)">
            <summary>
            Traverses the active constraint graph collecting bodies that match a predicate. If any body visited during the traversal fails to match the predicate, the traversal terminates.
            </summary>
            <typeparam name="TTraversalPredicate">Type of the predicate to test each body index with.</typeparam>
            <param name="pool">Pool to allocate temporary collections from.</param>
            <param name="startingActiveBodyIndex">Index of the active body to start the traversal at.</param>
            <param name="predicate">Predicate to test each traversed body with. If any body results in the predicate returning false, the traversal stops and the function returns false.</param>
            <param name="bodyIndices">List to fill with body indices traversed during island collection. Bodies failing the predicate will not be included.</param>
            <param name="constraintHandles">List to fill with constraint handles traversed during island collection.</param>
            <returns>True if the simulation graph was traversed without ever finding a body that made the predicate return false. False if any body failed the predicate.
            The bodyIndices and constraintHandles lists will contain all traversed predicate-passing bodies and constraints.</returns>
        </member>
        <member name="F:BepuPhysics.IslandSleeper.GatheringJob.IsBodyJob">
            <summary>
            If true, this job relates to a subset of body indices. If false, this job relates to a subset of constraint handles.
            </summary>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.Sleep(BepuUtilities.Collections.QuickList{System.Int32}@,BepuUtilities.IThreadDispatcher,System.Boolean)">
            <summary>
            Forcefully sleeps a list of bodies and all bodies that can be reached by traversing the constraint graph from those bodies.
            </summary>
            <param name="bodyIndices">List of body indices to sleep.</param>
            <param name="threadDispatcher">Thread dispatcher to use for the sleep attempt, if any. If null, sleep is performed on the calling thread.</param>
            <param name="deterministic">True if the sleep should produce deterministic results at higher cost, false otherwise.</param>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.Sleep(System.Int32)">
            <summary>
            Forces a body and all bodies that can be found by traversing the constraint graph from that body to go to sleep.
            </summary>
            <param name="bodyIndex">Index of the body to sleep in the active set.</param>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.EnsureSetsCapacity(System.Int32)">
            <summary>
            Ensures that the Bodies, Solver, and NarrowPhase can hold at least the given number of sets (BodySets for the Bodies collection, ConstraintSets for the Solver, PairSubcaches for the NarrowPhase.PairCache).
            </summary>
            <param name="setsCapacity">Number of sets to guarantee space for.</param>
        </member>
        <member name="M:BepuPhysics.IslandSleeper.ResizeSetsCapacity(System.Int32)">
            <summary>
            Ensures that the Bodies and Solver can hold the given number of sets. 
            If the existing allocation is smaller than the requested sets capacity, the allocation will be enlarged.
            If the existing allocation is larger than both the existing potentially allocated set range and the requested sets capacity, the allocation will be shrunk.
            Shrinks will never cause an existing set to be lost.
            </summary>
            <param name="setsCapacity">Target number of sets to allocate space for.</param>
        </member>
        <member name="T:BepuPhysics.TimestepperStageHandler">
            <summary>
            Delegate used by ITimesteppers for their stage callbacks.
            </summary>
            <param name="dt">Time step duration.</param>
            <param name="threadDispatcher">Thread dispatcher used for this timestep.</param>
        </member>
        <member name="T:BepuPhysics.TimestepperSubstepStageHandler">
            <summary>
            Delegate used by ITimesteppers for stage callbacks within substepping loops.
            </summary>
            <param name="substepIndex">Index of the substep executing this stage.</param>
            <param name="dt">Time step duration.</param>
            <param name="threadDispatcher">Thread dispatcher used for this timestep.</param>
        </member>
        <member name="T:BepuPhysics.ITimestepper">
            <summary>
            Defines a type capable of updating the simulation state for a given elapsed time.
            </summary>
        </member>
        <member name="E:BepuPhysics.ITimestepper.BeforeCollisionDetection">
            <summary>
            Callbacks to execute immediately before collision detection executes.
            </summary>
        </member>
        <member name="E:BepuPhysics.ITimestepper.CollisionsDetected">
            <summary>
            Callbacks to execute after collision detection completes.
            </summary>
        </member>
        <member name="M:BepuPhysics.ITimestepper.Timestep(BepuPhysics.Simulation,System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Performs one timestep of the given length.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="T:BepuPhysics.AngularIntegrationMode">
            <summary>
            Defines how a pose integrator should handle angular velocity integration.
            </summary>
        </member>
        <member name="F:BepuPhysics.AngularIntegrationMode.Nonconserving">
            <summary>
            Angular velocity is directly integrated and does not change as the body pose changes. Does not conserve angular momentum.
            </summary>
        </member>
        <member name="F:BepuPhysics.AngularIntegrationMode.ConserveMomentum">
            <summary>
            Approximately conserves angular momentum by updating the angular velocity according to the change in orientation. Does a decent job for gyroscopes, but angular velocities will tend to drift towards a minimal inertia axis.
            </summary>
        </member>
        <member name="F:BepuPhysics.AngularIntegrationMode.ConserveMomentumWithGyroscopicTorque">
            <summary>
            Approximately conserves angular momentum by including an implicit gyroscopic torque. Best option for Dzhanibekov effect simulation, but applies a damping effect that can make gyroscopes less useful.
            </summary>
        </member>
        <member name="T:BepuPhysics.IPoseIntegratorCallbacks">
            <summary>
            Defines a type that handles callbacks for body pose integration.
            </summary>
        </member>
        <member name="P:BepuPhysics.IPoseIntegratorCallbacks.AngularIntegrationMode">
            <summary>
            Gets how the pose integrator should handle angular velocity integration.
            </summary>
        </member>
        <member name="M:BepuPhysics.IPoseIntegratorCallbacks.Initialize(BepuPhysics.Simulation)">
            <summary>
            Performs any required initialization logic after the Simulation instance has been constructed.
            </summary>
            <param name="simulation">Simulation that owns these callbacks.</param>
        </member>
        <member name="M:BepuPhysics.IPoseIntegratorCallbacks.PrepareForIntegration(System.Single)">
            <summary>
            Called prior to integrating the simulation's active bodies. When used with a substepping timestepper, this could be called multiple times per frame with different time step values.
            </summary>
            <param name="dt">Current time step duration.</param>
        </member>
        <member name="M:BepuPhysics.IPoseIntegratorCallbacks.IntegrateVelocity(System.Int32,BepuPhysics.RigidPose@,BepuPhysics.BodyInertia@,System.Int32,BepuPhysics.BodyVelocity@)">
            <summary>
            Callback called for each active body within the simulation during body integration.
            </summary>
            <param name="bodyIndex">Index of the body being visited.</param>
            <param name="pose">Body's current pose.</param>
            <param name="localInertia">Body's current local inertia.</param>
            <param name="workerIndex">Index of the worker thread processing this body.</param>
            <param name="velocity">Reference to the body's current velocity to integrate.</param>
        </member>
        <member name="T:BepuPhysics.PoseIntegration">
            <summary>
            Provides helper functions for integrating body poses.
            </summary>
        </member>
        <member name="T:BepuPhysics.PoseIntegrator`1">
            <summary>
            Integrates the velocity of mobile bodies over time into changes in position and orientation. Also applies gravitational acceleration to dynamic bodies.
            </summary>
            <remarks>
            This variant of the integrator uses a single global gravity. Other integrators that provide per-entity gravity could exist later.
            This integrator also assumes that the bodies positions are stored in terms of single precision floats. Later on, we will likely modify the Bodies
            storage to allow different representations for larger simulations. That will require changes in this integrator, the relative position calculation of collision detection,
            the bounding box calculation, and potentially even in the broadphase in extreme cases (64 bit per component positions).
            </remarks>
        </member>
        <member name="T:BepuPhysics.PositionFirstTimestepper">
            <summary>
            Updates the simulation in the order of: sleeper -> integrate body poses, velocity and bounding boxes -> collision detection -> solver -> data structure optimization.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionFirstTimestepper.Slept">
            <summary>
            Fires after the sleeper completes and before bodies are integrated.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionFirstTimestepper.BeforeCollisionDetection">
            <summary>
            Fires after bodies have had their position, velocity, and bounding boxes updated, but before collision detection begins.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionFirstTimestepper.CollisionsDetected">
            <summary>
            Fires after all collisions have been identified, but before constraints are solved.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionFirstTimestepper.ConstraintsSolved">
            <summary>
            Fires after the solver executes and before data structures are incrementally optimized.
            </summary>
        </member>
        <member name="T:BepuPhysics.PositionLastTimestepper">
            <summary>
            Updates the simulation in the order of: sleeper -> integrate velocities and update body bounding boxes -> collision detection -> solver -> integrate body poses -> data structure optimization.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionLastTimestepper.Slept">
            <summary>
            Fires after the sleeper completes and before bodies are integrated.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionLastTimestepper.BeforeCollisionDetection">
            <summary>
            Fires after bodies have had their velocities and bounding boxes updated, but before collision detection begins.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionLastTimestepper.CollisionsDetected">
            <summary>
            Fires after all collisions have been identified, but before constraints are solved.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionLastTimestepper.ConstraintsSolved">
            <summary>
            Fires after the solver executes and before body poses are integrated.
            </summary>
        </member>
        <member name="E:BepuPhysics.PositionLastTimestepper.PosesIntegrated">
            <summary>
            Fires after bodies have their poses integrated and before data structures are incrementally optimized.
            </summary>
        </member>
        <member name="T:BepuPhysics.Simulation">
            <summary>
            Orchestrates the bookkeeping and execution of a full dynamic simulation.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.Profiler">
            <summary>
            Gets the simulation profiler. Note that the SimulationProfiler implementation only exists when the library is compiled with the PROFILE compilation symbol; if not defined, returned times are undefined.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.BufferPool">
            <summary>
            Gets the main memory pool used to fill persistent structures and main thread ephemeral resources across the engine.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.Timestepper">
            <summary>
            Gets the timestepper used to update the simulation state.
            </summary>
        </member>
        <member name="P:BepuPhysics.Simulation.Deterministic">
            <summary>
            Gets or sets whether to use a deterministic time step when using multithreading. When set to true, additional time is spent sorting constraint additions and transfers.
            Note that this can only affect determinism locally- different processor architectures may implement instructions differently.
            </summary>
        </member>
        <member name="M:BepuPhysics.Simulation.Create``2(BepuUtilities.Memory.BufferPool,``0,``1,BepuPhysics.ITimestepper,System.Int32,System.Int32,System.Nullable{BepuPhysics.SimulationAllocationSizes})">
            <summary>
            Constructs a simulation supporting dynamic movement and constraints with the specified narrow phase callbacks.
            </summary>
            <param name="bufferPool">Buffer pool used to fill persistent structures and main thread ephemeral resources across the engine.</param>
            <param name="narrowPhaseCallbacks">Callbacks to use in the narrow phase.</param>
            <param name="poseIntegratorCallbacks">Callbacks to use in the pose integrator.</param>
            <param name="timestepper">Timestepper that defines how the simulation state should be updated.</param>
            <param name="solverIterationCount">Number of iterations the solver should use.</param>
            <param name="solverFallbackBatchThreshold">Number of synchronized batches the solver should maintain before falling back to a lower quality jacobi hybrid solver.</param>
            <param name="initialAllocationSizes">Allocation sizes to initialize the simulation with. If left null, default values are chosen.</param>
            <returns>New simulation.</returns>
        </member>
        <member name="M:BepuPhysics.Simulation.Sleep(BepuUtilities.IThreadDispatcher)">
            <summary>
            Executes the sleep stage, moving candidate
            </summary>
            <param name="threadDispatcher">Thread dispatcher to use for the sleeper execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.IntegrateBodiesAndUpdateBoundingBoxes(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Updates the position, velocity, world inertia, deactivation candidacy and bounding boxes of active bodies.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.PredictBoundingBoxes(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Predicts the bounding boxes of active bodies by speculatively integrating velocity. Does not actually modify body velocities. Updates deactivation candidacy.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.IntegrateVelocitiesBoundsAndInertias(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Updates the velocities, world space inertias, bounding boxes, and deactivation candidacy of active bodies.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.IntegrateVelocitiesAndUpdateInertias(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Updates the velocities and world space inertias of active bodies.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.IntegratePoses(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Updates the poses of active bodies.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.CollisionDetection(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Updates the broad phase structure for the current body bounding boxes, finds potentially colliding pairs, and then executes the narrow phase for all such pairs. Generates contact constraints for the solver.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.IncrementallyUpdateContactConstraints(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Uses the current body velocities to incrementally update all active contact constraint penetration depths.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Solve(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Solves all active constraints in the simulation.
            </summary>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.IncrementallyOptimizeDataStructures(BepuUtilities.IThreadDispatcher)">
            <summary>
            Incrementally improves body and constraint storage for better performance.
            </summary>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Timestep(System.Single,BepuUtilities.IThreadDispatcher)">
            <summary>
            Performs one timestep of the given length.
            </summary>
            <remarks>
            Be wary of variable timesteps. They can harm stability. Whenever possible, keep the timestep the same across multiple frames unless you have a specific reason not to.
            </remarks>
            <param name="dt">Duration of the time step.</param>
            <param name="threadDispatcher">Thread dispatcher to use for execution, if any.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Clear">
            <summary>
            Clears the simulation of every object, only returning memory to the pool that would be returned by sequential removes. 
            Other persistent allocations, like those in the Bodies set, will remain.
            </summary>
        </member>
        <member name="M:BepuPhysics.Simulation.EnsureCapacity(BepuPhysics.SimulationAllocationSizes)">
            <summary>
            Increases the allocation size of any buffers too small to hold the allocation target.
            </summary>
            <remarks>
            <para>
            The final size of the allocated buffers are constrained by the allocator. It is not guaranteed to be exactly equal to the target, but it is guaranteed to be at least as large.
            </para>
            <para>
            This is primarily a convenience function. Everything it does internally can be done externally.
            For example, if only type batches need to be resized, the solver's own functions can be used directly.
            </para>
            </remarks>
            <param name="allocationTarget">Allocation sizes to guarantee sufficient size for.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Resize(BepuPhysics.SimulationAllocationSizes)">
            <summary>
            Increases the allocation size of any buffers too small to hold the allocation target, and decreases the allocation size of any buffers that are unnecessarily large.
            </summary>
            <remarks>
            <para>
            The final size of the allocated buffers are constrained by the allocator. It is not guaranteed to be exactly equal to the target, but it is guaranteed to be at least as large.
            </para>
            <para>
            This is primarily a convenience function. Everything it does internally can be done externally.
            For example, if only type batches need to be resized, the solver's own functions can be used directly.
            </para>
            </remarks>
            <param name="allocationTarget">Allocation sizes to guarantee sufficient size for.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Dispose">
            <summary>
            Clears the simulation of every object and returns all pooled memory to the buffer pool. Leaves the simulation in an unusable state.
            </summary>
        </member>
        <member name="M:BepuPhysics.Simulation.RayCast``1(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,``0@,System.Int32)">
            <summary>
            Intersects a ray against the simulation.
            </summary>
            <typeparam name="THitHandler">Type of the callbacks to execute on ray-object intersections.</typeparam>
            <param name="origin">Origin of the ray to cast.</param>
            <param name="direction">Direction of the ray to cast.</param>
            <param name="maximumT">Maximum length of the ray traversal in units of the direction's length.</param>
            <param name="hitHandler">callbacks to execute on ray-object intersections.</param>
            <param name="id">User specified id of the ray.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Sweep``2(``0,BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,System.Single,BepuUtilities.Memory.BufferPool,``1@,System.Single,System.Single,System.Int32)">
            <summary>
            Sweeps a shape against the simulation.
            </summary>
            <typeparam name="TShape">Type of the shape to sweep.</typeparam>
            <typeparam name="TSweepHitHandler">Type of the callbacks executed when a sweep impacts an object in the scene.</typeparam>
            <param name="shape">Shape to sweep.</param>
            <param name="pose">Starting pose of the sweep.</param>
            <param name="velocity">Velocity of the swept shape.</param>
            <param name="maximumT">Maximum length of the sweep in units of time used to integrate the velocity.</param>
            <param name="pool">Pool to allocate any temporary resources in during execution.</param>
            <param name="hitHandler">Callbacks executed when a sweep impacts an object in the scene.</param>
            <remarks>Simulation objects are treated as stationary during the sweep.</remarks>
            <param name="minimumProgression">Minimum amount of progress in terms of t parameter that any iterative sweep tests should make for each sample.</param>
            <param name="convergenceThreshold">Threshold in terms of t parameter under which iterative sweep tests are permitted to exit in collision.</param>
            <param name="maximumIterationCount">Maximum number of iterations to use in iterative sweep tests.</param>
        </member>
        <member name="M:BepuPhysics.Simulation.Sweep``2(``0@,BepuPhysics.RigidPose@,BepuPhysics.BodyVelocity@,System.Single,BepuUtilities.Memory.BufferPool,``1@)">
            <summary>
            Sweeps a shape against the simulation.
            </summary>
            <typeparam name="TShape">Type of the shape to sweep.</typeparam>
            <typeparam name="TSweepHitHandler">Type of the callbacks executed when a sweep impacts an object in the scene.</typeparam>
            <param name="shape">Shape to sweep.</param>
            <param name="pose">Starting pose of the sweep.</param>
            <param name="velocity">Velocity of the swept shape.</param>
            <param name="maximumT">Maximum length of the sweep in units of time used to integrate the velocity.</param>
            <param name="pool">Pool to allocate any temporary resources in during execution.</param>
            <param name="hitHandler">Callbacks executed when a sweep impacts an object in the scene.</param>
            <remarks>Simulation objects are treated as stationary during the sweep.</remarks>
        </member>
        <member name="T:BepuPhysics.SimulationAllocationSizes">
            <summary>
            The common set of allocation sizes for a simulation.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Bodies">
            <summary>
            The number of bodies to allocate space for.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Statics">
            <summary>
            The number of statics to allocate space for.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Islands">
            <summary>
            The number of inactive islands to allocate space for.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.ShapesPerType">
            <summary>
            Minimum number of shapes to allocate space for in each shape type batch.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.Constraints">
            <summary>
            The number of constraints to allocate bookkeeping space for. This does not affect actual type batch allocation sizes, only the solver-level constraint handle storage.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.ConstraintsPerTypeBatch">
            <summary>
            The minimum number of constraints to allocate space for in each individual type batch.
            New type batches will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.
            The number of constraints can vary greatly across types- there are usually far more contacts than ragdoll constraints.
            Per type estimates can be assigned within the Solver.TypeBatchAllocation if necessary. This value acts as a lower bound for all types.
            </summary>
        </member>
        <member name="F:BepuPhysics.SimulationAllocationSizes.ConstraintCountPerBodyEstimate">
            <summary>
            The minimum number of constraints to allocate space for in each body's constraint list.
            New bodies will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.
            </summary>
        </member>
        <member name="T:BepuPhysics.SimulationProfiler">
            <summary>
            Stores profiling information for the previous simulation execution.
            </summary>
        </member>
        <member name="P:BepuPhysics.SimulationProfiler.Item(System.Object)">
            <summary>
            Gets the time it took to complete the last execution of the given stage. If no stage matching the given object ran, returns -1.
            </summary>
            <param name="stage">Stage to look up the time for.</param>
            <returns>Time it took to complete the last execution of the given stage.</returns>
        </member>
        <member name="M:BepuPhysics.IShapeRayHitHandler.AllowTest(System.Int32)">
            <summary>
            Checks whether the child of a collidable should be tested against a ray. Only called by shape types that can have more than one child.
            </summary>
            <param name="childIndex">Index of the candidate in the parent collidable.</param>
            <returns>True if the child should be tested by the ray, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.IShapeRayHitHandler.OnRayHit(BepuPhysics.Trees.RayData@,System.Single@,System.Single,System.Numerics.Vector3@,System.Int32)">
            <summary>
            Called when a ray impact has been found.
            </summary>
            <param name="ray">Information about the ray associated with this hit.</param>
            <param name="maximumT">Maximum distance along the ray that the traversal is allowed to go in units of ray direction length. Can be set to limit future tests.</param>
            <param name="t">Distance along the ray to the impact in units of ray direction length. In other words, hitLocation = ray.Origin + ray.Direction * t.</param>
            <param name="normal">Surface normal at the hit location.</param>
            <param name="childIndex">Index of the hit child. For convex shapes or other types that don't have multiple children, this is always zero.</param>
        </member>
        <member name="T:BepuPhysics.IRayHitHandler">
            <summary>
            Defines a type capable of filtering ray test candidates and handling ray hit results.
            </summary>
        </member>
        <member name="M:BepuPhysics.IRayHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Checks whether a collidable identified by the acceleration structure should be tested against a ray.
            </summary>
            <param name="collidable">Candidate collidable for ray testing.</param>
            <returns>True if the collidable should be tested by the ray, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.IRayHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference,System.Int32)">
            <summary>
            Checks whether the child of a collidable should be tested against a ray. Only called by shape types that can have more than one child.
            </summary>
            <param name="collidable">Parent of the candidate.</param>
            <param name="childIndex">Index of the candidate in the parent collidable.</param>
            <returns>True if the child should be tested by the ray, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.IRayHitHandler.OnRayHit(BepuPhysics.Trees.RayData@,System.Single@,System.Single,System.Numerics.Vector3@,BepuPhysics.Collidables.CollidableReference,System.Int32)">
            <summary>
            Called when a ray impact has been found.
            </summary>
            <param name="ray">Information about the ray associated with this hit.</param>
            <param name="maximumT">Maximum distance along the ray that the traversal is allowed to go in units of ray direction length. Can be set to limit future tests.</param>
            <param name="t">Distance along the ray to the impact in units of ray direction length. In other words, hitLocation = ray.Origin + ray.Direction * t.</param>
            <param name="normal">Surface normal at the hit location.</param>
            <param name="collidable">Collidable hit by the ray.</param>
            <param name="childIndex">Index of the hit child. For convex shapes or other types that don't have multiple children, this is always zero.</param>
        </member>
        <member name="T:BepuPhysics.ISweepHitHandler">
            <summary>
            Defines a type capable of filtering sweep candidates and handling sweep results.
            </summary>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Checks whether to run a detailed sweep test against a target collidable.
            </summary>
            <param name="collidable">Collidable to check.</param>
            <returns>True if the sweep test should be attempted, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.AllowTest(BepuPhysics.Collidables.CollidableReference,System.Int32)">
            <summary>
            Checks whether to run a detailed sweep test against a target collidable's child.
            </summary>
            <param name="collidable">Collidable to check.</param>
            <param name="child">Index of the child in the collidable to check.</param>
            <returns>True if the sweep test should be attempted, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.OnHit(System.Single@,System.Single,System.Numerics.Vector3@,System.Numerics.Vector3@,BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Called when a sweep test detects a hit with nonzero T value.
            </summary>
            <param name="maximumT">Reference to maximumT passed to the traversal.</param>
            <param name="t">Time of impact for the sweep test.</param>
            <param name="hitLocation">Location of the first hit detected by the sweep.</param>
            <param name="hitNormal">Surface normal at the hit location.</param>
            <param name="collidable">Collidable hit by the traversal.</param>
        </member>
        <member name="M:BepuPhysics.ISweepHitHandler.OnHitAtZeroT(System.Single@,BepuPhysics.Collidables.CollidableReference)">
            <summary>
            Called when a sweep test detects a hit at T = 0, meaning that no location or normal can be computed.
            </summary>
            <param name="maximumT">Reference to maximumT passed to the traversal.</param>
            <param name="collidable">Collidable hit by the traversal.</param>
        </member>
        <member name="F:BepuPhysics.Solver.Sets">
            <summary>
            Buffer containing all constraint sets. The first slot is dedicated to the active set; subsequent slots may be occupied by the constraints associated with inactive islands.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.ActiveSet">
            <summary>
            Gets a reference to the active set of constraints, stored in the first set slot.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.HandlePool">
            <summary>
            Pool to retrieve constraint handles from when creating new constraints.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.FallbackBatchThreshold">
            <summary>
            Gets the maximum number of solver batches to allow before resorting to a fallback solver.
            If a single body is constrained by more than FallbackBatchThreshold constraints, all constraints beyond FallbackBatchThreshold are placed into a fallback batch.
            The fallback batch uses a different solver that can handle multiple constraints affecting a single body in a single batch, allowing greater parallelism at the cost of convergence speed.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.IterationCount">
            <summary>
            Gets or sets the number of solver iterations to compute per call to Update.
            </summary>
        </member>
        <member name="P:BepuPhysics.Solver.MinimumCapacityPerTypeBatch">
            <summary>
            Gets or sets the minimum amount of space, in constraints, initially allocated in any new type batch.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.SetMinimumCapacityForType(System.Int32,System.Int32)">
            <summary>
            Sets the minimum capacity initially allocated to a new type batch of the given type.
            </summary>
            <param name="typeId">Id of the constraint type to check the initial capacity of.</param>
            <param name="minimumInitialCapacityForType">Minimum capacity to use for the type.</param>
        </member>
        <member name="M:BepuPhysics.Solver.GetMinimumCapacityForType(System.Int32)">
            <summary>
            Gets the minimum initial capacity for a given type.
            The returned value is the larger of MinimumCapacityPerTypeBatch and the value set by SetMinimumCapacityForType for the given type id.
            </summary>
            <param name="typeId">Type id to retrieve the minm</param>
            <returns>Larger of MinimumCapacityPerTypeBatch and the given type's minimum set by SetMinimumCapacityForType.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.ResetPerTypeInitialCapacities">
            <summary>
            Resets all per-type initial capacities to zero. Leaves the minimum capacity across all constraints unchanged.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.CountConstraints">
            <summary>
            Gets the total number of constraints across all sets, batches, and types. Requires enumerating
            all type batches; this can be expensive.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.ConstraintExists(BepuPhysics.ConstraintHandle)">
            <summary>
            Gets whether the given constraint handle refers to a constraint in the solver.
            </summary>
            <param name="constraintHandle">Constraint handle to check for existence in the solver.</param>
            <returns>True if the constraint handle exists in the solver, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.GetConstraintReference(BepuPhysics.ConstraintHandle,BepuPhysics.ConstraintReference@)">
            <summary>
            Gets a direct reference to the constraint associated with a handle.
            The reference is temporary; any constraint removals that affect the referenced type batch may invalidate the index.
            </summary>
            <typeparam name="T">Type of the type batch being referred to.</typeparam>
            <param name="handle">Handle index of the constraint.</param>
            <param name="reference">Temporary direct reference to the type batch and index in the type batch associated with the constraint handle.
            May be invalidated by constraint removals.</param>
        </member>
        <member name="M:BepuPhysics.Solver.FindCandidateBatch(System.Span{BepuPhysics.BodyHandle})">
            <summary>
            Attempts to locate a spot for a new constraint. Does not perform allocation for the constraint. If no batch exists, returns the index just beyond the end of the existing list of batches.
            </summary>
            <returns>Index of the batch that the constraint would fit in.</returns>
            <remarks>This is used by the narrowphase's multithreaded constraint adders to locate a spot for a new constraint without requiring a lock. Only after a candidate is located
            do those systems attempt an actual claim, limiting the duration of locks and increasing potential parallelism.</remarks>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescriptionWithoutWaking``1(BepuPhysics.ConstraintReference@,``0@)">
            <summary>
            Applies a description to a constraint slot without waking up the associated island.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintReference">Reference of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescriptionWithoutWaking``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Applies a description to a constraint slot without waking up the associated island.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintHandle">Handle of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescriptionWithoutWaking``1(BepuPhysics.ConstraintHandle,``0)">
            <summary>
            Applies a description to a constraint slot without waking up the associated island.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintHandle">Handle of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescription``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Applies a description to a constraint slot, waking up the connected bodies if necessary.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintHandle">Handle of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ApplyDescription``1(BepuPhysics.ConstraintHandle,``0)">
            <summary>
            Applies a description to a constraint slot, waking up the connected bodies if necessary.
            </summary>
            <typeparam name="TDescription">Type of the description to apply.</typeparam>
            <param name="constraintHandle">Handle of the constraint being updated.</param>
            <param name="description">Description to apply to the slot.</param>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(System.Span{BepuPhysics.BodyHandle},``0@)">
            <summary>
            Allocates a constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandles">Body handles used by the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(System.Span{BepuPhysics.BodyHandle},``0)">
            <summary>
            Allocates a constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandles">Body handles referenced by the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a one-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandle">Body connected to the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,``0)">
            <summary>
            Allocates a one-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandle">First body of the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a two-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0)">
            <summary>
            Allocates a two-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a three-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <param name="bodyHandleC">Third body of the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0)">
            <summary>
            Allocates a three-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <param name="bodyHandleC">Third body of the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0@)">
            <summary>
            Allocates a four-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <param name="bodyHandleC">Third body of the constraint.</param>
            <param name="bodyHandleD">Fourth body of the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.Add``1(BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,BepuPhysics.BodyHandle,``0)">
            <summary>
            Allocates a four-body constraint slot and sets up a constraint with the specified description.
            </summary>
            <typeparam name="TDescription">Type of the constraint description to add.</typeparam>
            <param name="bodyHandleA">First body of the constraint.</param>
            <param name="bodyHandleB">Second body of the constraint.</param>
            <param name="bodyHandleC">Third body of the constraint.</param>
            <param name="bodyHandleD">Fourth body of the constraint.</param>
            <returns>Allocated constraint handle.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.RemoveFromBatch(BepuPhysics.ConstraintHandle,System.Int32,System.Int32,System.Int32)">
            <summary>
            Removes a constraint from a batch, performing any necessary batch cleanup, but does not return the constraint's handle to the pool.
            </summary>
            <param name="constraintHandle">Handle of the constraint being removed.</param>
            <param name="batchIndex">Index of the batch to remove from.</param>
            <param name="typeId">Type id of the constraint to remove.</param>
            <param name="indexInTypeBatch">Index of the constraint to remove within its type batch.</param>
        </member>
        <member name="M:BepuPhysics.Solver.Remove(BepuPhysics.ConstraintHandle)">
            <summary>
            Removes the constraint associated with the given handle. Note that this may invalidate any outstanding direct constraint references
            by reordering the constraints within the TypeBatch subject to removal.
            </summary>
            <param name="handle">Handle of the constraint to remove from the solver.</param>
        </member>
        <member name="M:BepuPhysics.Solver.UpdateForBodyMemoryMove(System.Int32,System.Int32)">
            <summary>
            Changes the body references of all constraints associated with a body in response to its movement into a new slot.
            Constraints associated with the body now at its old slot, if any, are left untouched.
            </summary>
            <param name="originalBodyIndex">Memory index that the moved body used to inhabit.</param>
            <param name="newBodyLocation">Memory index that the moved body now inhabits.</param>
        </member>
        <member name="M:BepuPhysics.Solver.UpdateForBodyMemorySwap(System.Int32,System.Int32)">
            <summary>
            Changes the body references of all constraints associated with two bodies in response to them swapping slots in memory.
            </summary>
            <param name="a">First swapped body index.</param>
            <param name="b">Second swapped body index.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ScaleAccumulatedImpulses(BepuPhysics.ConstraintSet@,System.Single)">
            <summary>
            Scales the accumulated impulses associated with a constraint set by a given scale.
            </summary>
            <param name="set">Set to scale.</param>
            <param name="scale">Scale to apply to accumulated impulses.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ScaleActiveAccumulatedImpulses(System.Single)">
            <summary>
            Scales all accumulated impulses in the active set.
            </summary>
            <param name="scale">Scale to apply to accumulated impulses.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ScaleAccumulatedImpulses(System.Single)">
            <summary>
            Scales all accumulated impulses in all constraint sets.
            </summary>
            <param name="scale">Scale to apply to accumulated impulses.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateAccumulatedImpulses``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Enumerates the accumulated impulses associated with a constraint.
            </summary>
            <param name="constraintHandle">Constraint to enumerate.</param>
            <param name="enumerator">Enumerator to use.</param>
        </member>
        <member name="M:BepuPhysics.Solver.GetAccumulatedImpulseMagnitudeSquared(BepuPhysics.ConstraintHandle)">
            <summary>
            Gathers the squared magnitude of the accumulated impulse for a given constraint.
            </summary>
            <param name="constraintHandle">Constraint to look up the accumulated impulses of.</param>
            <returns>Squared magnitude of the accumulated impulses associated with the given constraint.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.GetAccumulatedImpulseMagnitude(BepuPhysics.ConstraintHandle)">
            <summary>
            Gathers the magnitude of the accumulated impulse for a given constraint.
            </summary>
            <param name="constraintHandle">Constraint to look up the accumulated impulses of.</param>
            <returns>Magnitude of the accumulated impulses associated with the given constraint.</returns>
        </member>
        <member name="M:BepuPhysics.Solver.EnumerateConnectedBodies``1(BepuPhysics.ConstraintHandle,``0@)">
            <summary>
            Enumerates the set of bodies associated with a constraint in order of their references within the constraint.
            </summary>
            <param name="constraintHandle">Constraint to enumerate.</param>
            <param name="enumerator">Enumerator to use.</param>
        </member>
        <member name="M:BepuPhysics.Solver.Clear">
            <summary>
            Removes all objects from the solver. This is meant as a fast path to empty a simulation's constraints. It makes no attempt to retain synchronization with other systems
            which may depend on the existence of constraints, like the per-body constraint lists.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.EnsureSolverCapacities(System.Int32,System.Int32)">
            <summary>
            Adjusts the size of the the solvers non-typebatch data structures. An allocation will grow if the given capacity exceeds the currently allocated capacity.
            </summary>
            <param name="bodyHandleCapacity">Size of the span of body handles to allocate space for. Applies to batch referenced handle sets.</param>
            <param name="constraintHandleCapacity">Number of constraint handles to allocate space for. Applies to the handle->constraint mapping table.</param>
        </member>
        <member name="M:BepuPhysics.Solver.ResizeSolverCapacities(System.Int32,System.Int32)">
            <summary>
            Adjusts the size of the the solvers non-typebatch data structures. An allocation is allowed to shrink if it fits both all existing entries and the given capacity.
            An allocation will grow if the given capacity exceeds the currently allocated capacity.
            </summary>
            <param name="bodyHandleCapacity">Size of the span of body handles to allocate space for. Applies to batch referenced handle sets.</param>
            <param name="constraintHandleCapacity">Number of constraint handles to allocate space for. Applies to the handle->constraint mapping table.</param>
        </member>
        <member name="M:BepuPhysics.Solver.EnsureTypeBatchCapacities">
            <summary>
            Ensures all existing active type batches meet or exceed the current solver-defined minimum capacities. Type batches with capacities smaller than the minimums will be enlarged.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.ResizeTypeBatchCapacities">
            <summary>
            Applies the current solver-defined minimum capacities to existing type batches. Type batches with capacities larger than the minimums and counts less than the minimums may be shrunk.
            Type batches with capacities smaller than the minimums will be enlarged.
            </summary>
        </member>
        <member name="M:BepuPhysics.Solver.Dispose">
            <summary>
            Returns all pool-retrieved resources to the pool.
            </summary>
            <remarks>
            The solver cannot be 'rehydrated' for reuse after a disposal. If you want to return bulk data to the pool while leaving the solver in a usable state, consider using Clear instead.
            </remarks>
        </member>
        <member name="F:BepuPhysics.Solver.WorkBlock.StartBundle">
            <summary>
            Index of the first bundle in the block.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.WorkBlock.End">
            <summary>
            Exlusive end index of the bundle. Index of the last bundle in the block is End - 1.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.WorkerBounds.Min">
            <summary>
            Inclusive start of blocks known to be claimed by any worker.
            </summary>
        </member>
        <member name="F:BepuPhysics.Solver.WorkerBounds.Max">
            <summary>
            Exclusive end of blocks known to be claimed by any worker.
            </summary>
        </member>
        <member name="T:BepuPhysics.Solver.LocalSpinWait">
            <summary>
            Behaves like a framework SpinWait, but never voluntarily relinquishes the timeslice to off-core threads.
            </summary>
            <remarks><para>There are three big reasons for using this over the regular framework SpinWait:</para>
            <para>1) The framework spinwait relies on spins for quite a while before resorting to any form of timeslice surrender.
            Empirically, this is not ideal for the solver- if the sync condition isn't met within several nanoseconds, it will tend to be some microseconds away.
            This spinwait is much more aggressive about moving to yields.</para>
            <para>2) After a number of yields, the framework SpinWait will resort to calling Sleep.
            This widens the potential set of schedulable threads to those not native to the current core. If we permit that transition, it is likely to evict cached solver data.
            (For very large simulations, the use of Sleep(0) isn't that concerning- every iteration can be large enough to evict all of cache- 
            but there still isn't much benefit to using it over yields in context.)</para>
            <para>3) After a particularly long wait, the framework SpinWait resorts to Sleep(1). This is catastrophic for the solver- worse than merely interfering with cached data,
            it also simply prevents the thread from being rescheduled for an extremely long period of time (potentially most of a frame!) under the default clock resolution.</para>
            <para>Note that this isn't an indication that the framework SpinWait should be changed, but rather that the solver's requirements are extremely specific and don't match
            a general purpose solution very well.</para></remarks>
        </member>
        <member name="T:BepuPhysics.StaticDescription">
            <summary>
            Describes the properties of a static object. When added to a simulation, static objects can collide but have no velocity and will not move in response to forces.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticDescription.Pose">
            <summary>
            Position and orientation of the static.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticDescription.Collidable">
            <summary>
            Collidable properties of the static.
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(System.Numerics.Vector3@,System.Numerics.Quaternion@,BepuPhysics.Collidables.CollidableDescription@)">
            <summary>
            Builds a new static description.
            </summary>
            <param name="position">Position of the static.</param>
            <param name="orientation">Orientation of the static.</param>
            <param name="collidable">Collidable description for the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(System.Numerics.Vector3@,BepuPhysics.Collidables.CollidableDescription@)">
            <summary>
            Builds a new static description.
            </summary>
            <param name="position">Position of the static.</param>
            <param name="collidable">Collidable description for the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(System.Numerics.Vector3@,System.Numerics.Quaternion@,BepuPhysics.Collidables.TypedIndex,System.Single)">
            <summary>
            Builds a new static description with discrete continuity.
            </summary>
            <param name="position">Position of the static.</param>
            <param name="orientation">Orientation of the static.</param>
            <param name="shapeIndex">Index of the static's shape in the simulation shapes set.</param>
            <param name="speculativeMargin">Distance beyond the surface of the static to allow speculative contacts to be generated.</param>
        </member>
        <member name="M:BepuPhysics.StaticDescription.#ctor(System.Numerics.Vector3@,BepuPhysics.Collidables.TypedIndex,System.Single)">
            <summary>
            Builds a new static description with discrete continuity.
            </summary>
            <param name="position">Position of the static.</param>
            <param name="shapeIndex">Index of the static's shape in the simulation shapes set.</param>
            <param name="speculativeMargin">Distance beyond the surface of the body to allow speculative contacts to be generated.</param>
        </member>
        <member name="T:BepuPhysics.StaticReference">
            <summary>
            Convenience structure for directly referring to a static's properties.
            </summary>
            <remarks>Note that this type makes no attempt to protect against unsafe modification of static properties.</remarks>
        </member>
        <member name="F:BepuPhysics.StaticReference.Handle">
            <summary>
            Handle of the static that this reference refers to.
            </summary>
        </member>
        <member name="F:BepuPhysics.StaticReference.Statics">
            <summary>
            The collection containing the static.
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticReference.#ctor(BepuPhysics.StaticHandle,BepuPhysics.Statics)">
            <summary>
            Constructs a new static reference.
            </summary>
            <param name="handle">Handle of the static to refer to.</param>
            <param name="statics">Collection containing the static.</param>
        </member>
        <member name="P:BepuPhysics.StaticReference.Exists">
            <summary>
            Gets whether the static reference exists within the static set. True if the handle maps to a valid memory location that agrees that the handle points to it, false otherwise.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Index">
            <summary>
            Gets a the static's index in the statics collection.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Pose">
            <summary>
            Gets a reference to the static's pose.
            </summary>
        </member>
        <member name="P:BepuPhysics.StaticReference.Collidable">
            <summary>
            Gets a reference to the static's collidable.
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticReference.GetDescription(BepuPhysics.StaticDescription@)">
            <summary>
            Gets a description of the static.
            </summary>
            <param name="description">Description of the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticReference.ApplyDescription(BepuPhysics.StaticDescription@)">
            <summary>
            Sets a static's properties according to a description.
            </summary>
            <param name="description">Description of the static.</param>
        </member>
        <member name="M:BepuPhysics.StaticReference.SetShape(BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a static.
            </summary>
            <param name="newShape">Index of the new shape to use for the static.</param>
        </member>
        <member name="P:BepuPhysics.StaticReference.BoundingBox">
            <summary>
            Gets a copy of the static's bounding box.
            </summary>
        </member>
        <member name="M:BepuPhysics.StaticReference.GetBoundsReferencesFromBroadPhase(System.Numerics.Vector3*@,System.Numerics.Vector3*@)">
            <summary>
            Gets direct pointers to the static's bounding box minimum and maximum in the broad phase. Outputs null if the static has no shape.
            </summary>
            <param name="min">Pointer to the bounding box minimum in the broad phase.</param>
            <param name="max">Pointer to the bounding box maximum in the broad phase.</param>
        </member>
        <member name="M:BepuPhysics.StaticReference.UpdateBounds">
            <summary>
            Updates the static's bounds in the broad phase for its current state. Does not include velocity expansion. Does nothing if the static has no shape.
            </summary>
            <remarks>Can be useful if you made modifications to the static's state that you want reflected in the broad phase before the next timestep.
            For example, if you want to perform ray casts against the broad phase after moving objects around directly, their bounds must be updated or else the broad phase bounds will be out of date and the ray will likely miss.</remarks>
        </member>
        <member name="T:BepuPhysics.Statics">
            <summary>
            Collection of allocated static collidables.
            </summary>
        </member>
        <member name="F:BepuPhysics.Statics.HandleToIndex">
            <summary>
            Remaps a static handle integer value to the actual array index of the static.
            The backing array index may change in response to cache optimization.
            </summary>
        </member>
        <member name="F:BepuPhysics.Statics.IndexToHandle">
            <summary>
            Remaps a static index to its handle.
            </summary>
        </member>
        <member name="F:BepuPhysics.Statics.Collidables">
            <summary>
            The set of collidables owned by each static. Speculative margins, continuity settings, and shape indices can be changed directly.
            Shape indices cannot transition between pointing at a shape and pointing at nothing or vice versa without notifying the broad phase of the collidable addition or removal.
            </summary>
        </member>
        <member name="M:BepuPhysics.Statics.StaticExists(BepuPhysics.StaticHandle)">
            <summary>
            Checks whether a static handle is currently registered with the statics set.
            </summary>
            <param name="handle">Handle to check for.</param>
            <returns>True if the handle exists in the collection, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.RemoveAt(System.Int32)">
            <summary>
            Removes a static from the set by index. Any inactive bodies with bounding boxes overlapping the removed static's bounding box will be forced active.
            </summary>
            <param name="index">Index of the static to remove.</param>
        </member>
        <member name="M:BepuPhysics.Statics.Remove(BepuPhysics.StaticHandle)">
            <summary>
            Removes a static from the set. Any inactive bodies with bounding boxes overlapping the removed static's bounding box will be forced active.
            </summary>
            <param name="handle">Handle of the static to remove.</param>
        </member>
        <member name="M:BepuPhysics.Statics.UpdateBounds(BepuPhysics.StaticHandle)">
            <summary>
            Updates the bounds held within the broad phase for the static's current state.
            </summary>
        </member>
        <member name="M:BepuPhysics.Statics.Add(BepuPhysics.StaticDescription@)">
            <summary>
            Adds a new static body to the simulation. All inactive bodies whose bounding boxes overlap the new static are forced active.
            </summary>
            <param name="description">Description of the static to add.</param>
            <returns>Handle of the new static.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.SetShape(BepuPhysics.StaticHandle,BepuPhysics.Collidables.TypedIndex)">
            <summary>
            Changes the shape of a static and updates its bounds in the broad phase.
            </summary>
            <param name="handle">Handle of the static to change the shape of.</param>
            <param name="newShape">Index of the new shape to use for the static.</param>
        </member>
        <member name="M:BepuPhysics.Statics.ApplyDescription(BepuPhysics.StaticHandle,BepuPhysics.StaticDescription@)">
            <summary>
            Applies a new description to an existing static object. All inactive bodies with bounding boxes overlapping the old or new static collidable are forced active.
            Updates the bounds of the static in the broad phase.
            </summary>
            <param name="handle">Handle of the static to apply the description to.</param>
            <param name="description">Description to apply to the static.</param>
        </member>
        <member name="M:BepuPhysics.Statics.GetDescription(BepuPhysics.StaticHandle,BepuPhysics.StaticDescription@)">
            <summary>
            Gets the current description of the static referred to by a given handle.
            </summary>
            <param name="handle">Handle of the static to look up the description of.</param>
            <param name="description">Gathered description of the handle-referenced static.</param>
        </member>
        <member name="M:BepuPhysics.Statics.GetStaticReference(BepuPhysics.StaticHandle)">
            <summary>
            Gets a reference to a static by its handle.
            </summary>
            <param name="handle">Handle of the static to grab a reference of.</param>
            <returns>Reference to the desired static.</returns>
        </member>
        <member name="M:BepuPhysics.Statics.Clear">
            <summary>
            Clears all bodies from the set without returning any memory to the pool.
            </summary>
        </member>
        <member name="M:BepuPhysics.Statics.Resize(System.Int32)">
            <summary>
            Resizes the allocated spans for static data. Note that this is conservative; it will never orphan existing objects.
            </summary>
            <param name="capacity">Target static data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Statics.EnsureCapacity(System.Int32)">
            <summary>
            Increases the size of buffers if needed to hold the target capacity.
            </summary>
            <param name="capacity">Target data capacity.</param>
        </member>
        <member name="M:BepuPhysics.Statics.Dispose">
            <summary>
            Returns all static resources to the pool used to create them.
            </summary>
            <remarks>The object can be reused if it is reinitialized by using EnsureCapacity or Resize.</remarks>
        </member>
        <member name="T:BepuPhysics.SubsteppingTimestepper">
            <summary>
            Updates the simulation in the order of: sleeper -> predict body bounding boxes -> collision detection -> LOOP { contact data update (if on iteration > 0) -> integrate body velocities -> solver -> integrate body poses } -> data structure optimization.
            Each inner loop execution simulates a sub-timestep of length dt/substepCount.
            Useful for simulations with difficult to solve constraint systems that need shorter timestep durations but which don't require high frequency collision detection.
            </summary>
        </member>
        <member name="P:BepuPhysics.SubsteppingTimestepper.SubstepCount">
            <summary>
            Gets or sets the number of substeps to execute during each timestep.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.Slept">
            <summary>
            Fires after the sleeper completes and before bodies are integrated.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.BeforeCollisionDetection">
            <summary>
            Fires after bodies have their bounding boxes updated for the frame's predicted motion and before collision detection.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.CollisionsDetected">
            <summary>
            Fires after all collisions have been identified, but before the substep loop begins.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.SubstepStarted">
            <summary>
            Fires at the beginning of a substep.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.ContactConstraintsUpdatedForSubstep">
            <summary>
            Fires after contact constraints are incrementally updated at the beginning of substeps after the first and before velocities are integrated.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.VelocitiesIntegrated">
            <summary>
            Fires after bodies have their velocities integrated and before the solver executes.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.ConstraintsSolved">
            <summary>
            Fires after the solver executes and before body poses are integrated.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.PosesIntegrated">
            <summary>
            Fires after bodies have their poses integrated and before the substep ends.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.SubstepEnded">
            <summary>
            Fires at the end of a substep.
            </summary>
        </member>
        <member name="E:BepuPhysics.SubsteppingTimestepper.SubstepsComplete">
            <summary>
            Fires after all substeps are finished executing and before data structures are incrementally optimized.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.Leaf">
            <summary>
            Pointer to a leaf's tree location.
            </summary>
            <remarks>The identity of a leaf is implicit in its position within the leaf array.</remarks>
        </member>
        <member name="P:BepuPhysics.Trees.Leaf.NodeIndex">
            <summary>
            Gets the index of the node that the leaf is directly held by.
            </summary>
        </member>
        <member name="P:BepuPhysics.Trees.Leaf.ChildIndex">
            <summary>
            Gets which child within the owning node the leaf is in.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.Node">
            <summary>
            2-wide tree node.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.Metanode">
            <summary>
            Metadata associated with a 2-child tree node.
            </summary>
        </member>
        <member name="F:BepuPhysics.Trees.Metanode.LocalCostChange">
            <summary>
            Cached change in cost of the tree starting at this node since the previous frame.
            The local cost change is unioned with the refine flags. They're never used simultaneously.
            This will be overwritten right after use, so don't expect anything meaningful here outside of refinement scheduling's scope.
            </summary>
        </member>
        <member name="T:BepuPhysics.Trees.TreeRay">
            <summary>
            Ray representation designed for quicker intersection against axis aligned bounding boxes.
            </summary>
        </member>
        <member name="P:BepuPhysics.Trees.RaySource.RayCount">
            <summary>
            Gets the number of rays in the batch.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.RaySource.GetRay(System.Int32,BepuPhysics.Trees.RayData*@,System.Single*@)">
            <summary>
            Gets pointers to the data for a ray.
            </summary>
            <param name="rayIndex">Index of the ray to grab.</param>
            <param name="ray">Pointer to the ray's origin and direction. Note that changing the ray's origin and direction mid-traversal will not change the path of the traversal, 
            but it will be visible by any future leafs impacted by this ray.</param>
            <param name="maximumT">Pointer to the maximum length of the ray in units of the ray's length.
            Decreasing this value will prevent the traversal from visiting more distant nodes later in the traversal.</param>
        </member>
        <member name="M:BepuPhysics.Trees.RaySource.GetRay(System.Int32)">
            <summary>
            Gets a reference to the data for a ray.
            </summary>
            <param name="rayIndex">Index of the ray to grab.</param>
            <returns>Returns a reference to the ray in the ray source.</returns>
        </member>
        <member name="T:BepuPhysics.Trees.RayBatcher">
            <summary>
            Reusable structure for testing large numbers of rays against trees.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.#ctor(BepuUtilities.Memory.BufferPool,System.Int32,System.Int32)">
            <summary>
            Constructs a ray batcher and initializes its backing resources.
            </summary>
            <param name="pool">Pool to pull resources from.</param>
            <param name="rayCapacity">Maximum number of rays to execute in each traversal.
            This should typically be chosen as the highest value which avoids spilling data out of L2 cache.</param>
            <param name="treeDepthForPreallocation">Tree depth to preallocate ray stack space for. If a traversal finds nodes deeper than this, a dynamic resize will be triggered.</param>
        </member>
        <member name="T:BepuPhysics.Trees.RayBatcher.TreeRayWide">
            <summary>
            Ray representation designed for quicker intersection against axis aligned bounding boxes.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.TestRays``1(BepuPhysics.Trees.Tree@,``0@)">
            <summary>
            Tests any batched rays against the given tree.
            </summary>
            <param name="tree">Tree to test the accumulated rays against.</param>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.Add(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Single,System.Int32)">
            <summary>
            Adds a ray to the batcher. Returns true if the batcher has reached maximum ray capacity and needs to be reset in order to continue adding rays.
            </summary>
            <param name="origin">Origin of the ray to test against the tree.</param>
            <param name="direction">Direction of the ray to test against the tree.</param>
            <param name="maximumT">Maximum distance that the ray will travel in units of the ray's length.</param>
            <param name="id">Identifier value for the ray. Leaf tests will have access to the id.</param>
            <returns>True if the batcher is full and requires a call to ResetRays before adding any more rays, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.ResetRays">
            <summary>
            Resets the accumulated ray count to zero.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.RayBatcher.Dispose">
            <summary>
            Disposes all the resources backing the ray batcher.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.#ctor(BepuUtilities.Memory.BufferPool,System.Int32)">
            <summary>
            Constructs an empty tree.
            </summary>
            <param name="initialLeafCapacity">Initial number of leaves to allocate room for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.#ctor(System.Span{System.Byte},BepuUtilities.Memory.BufferPool)">
            <summary>
            Loads a tree from a byte buffer created by the Serialize function.
            </summary>
            <param name="data">Data to load into the tree.</param>
            <param name="pool">Pool to use to create the tree.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.GetSerializedByteCount">
            <summary>
            Gets the number of bytes required to store the tree.
            </summary>
            <param name="tree">Tree to measure.</param>
            <returns>Number of bytes required to store the tree.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Serialize(System.Span{System.Byte})">
            <summary>
            Writes a tree into a byte buffer.
            </summary>
            <param name="tree">Tree to write into the buffer.</param>
            <param name="bytes">Buffer to hold the tree's data.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Resize(BepuUtilities.Memory.BufferPool,System.Int32)">
            <summary>
            Resizes the buffers backing the tree's nodes and leaves. Will not shrink the buffers below the size needed by the currently resident nodes and leaves.
            </summary>
            <param name="pool">Pool from which to take and return resources.</param>
            <param name="targetLeafSlotCount">The desired number of available leaf slots.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Clear">
            <summary>
            Resets the tree to a fresh post-construction state, clearing out leaves and nodes but leaving the backing resources intact.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Disposes the tree's backing resources, returning them to the Pool currently associated with the tree.
            </summary>
            <param name="pool">Pool to return resources to.</param>
            <remarks>Disposed trees can be reused if EnsureCapacity or Resize is used to rehydrate them.</remarks>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Equals(BepuPhysics.Trees.Tree@,BepuPhysics.Trees.Tree@)">
            <summary>
            Tests if two tree references point to the same data.
            </summary>
            <param name="a">First tree to compare.</param>
            <param name="b">Second tree to compare.</param>
            <returns>True if the two trees have the same nodes and node count, false otherwise.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MergeLeafNodes(BepuUtilities.BoundingBox@,System.Int32,System.Int32,BepuUtilities.BoundingBox@)">
            <summary>
            Merges a new leaf node with an existing leaf node, producing a new internal node referencing both leaves, and then returns the index of the leaf node.
            </summary>
            <param name="newLeafBounds">Bounding box of the leaf being added.</param>
            <param name="parentIndex">Index of the parent node that the existing leaf belongs to.</param>
            <param name="indexInParent">Index of the child wtihin the parent node that the existing leaf belongs to.</param>
            <param name="merged">Bounding box holding both the new and existing leaves.</param>
            <returns>Index of the leaf </returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.Add(BepuUtilities.BoundingBox@,BepuUtilities.Memory.BufferPool)">
            <summary>
            Adds a leaf to the tree with the given bounding box and returns the index of the added leaf.
            </summary>
            <param name="bounds">Extents of the leaf bounds.</param>
            <param name="pool">Resource pool to use if resizing is required.</param>
            <returns>Index of the leaf allocated in the tree's leaf array.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.TrySwapNodesThreadSafe(System.Int32@,System.Int32@)">
            <summary>
            Attempts to swap two nodes. Aborts without changing memory if the swap is contested by another thread.
            </summary>
            <remarks>Uses Node.RefineFlag as a lock-keeping mechanism. All refine flags should be cleared to 0 before a multithreaded processing stage that performs swaps.</remarks>
            <param name="aIndex">First node of the swap pair.</param>
            <param name="bIndex">Second node of the swap pair.</param>
            <returns>True if the nodes were swapped, false if the swap was contested.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.IncrementalCacheOptimizeThreadSafe(System.Int32)">
            <summary>
            Moves the children if the specified node into the correct relative position in memory.
            Takes care to avoid contested moves in multithreaded contexts. May not successfully
            complete all desired moves if contested.
            </summary>
            <param name="nodeIndex">Node whose children should be optimized.</param>
            <returns>True if no other threads contested the optimization or if the node is already optimized, otherwise false.
            Will return true even if not all nodes are optimized if the reason was a target index outside of the node list bounds.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.CacheOptimize(System.Int32)">
            <summary>
            Begins a cache optimization at the given node and proceeds all the way to the bottom of the tree.
            Requires that the targeted node is already at the global optimum position.
            </summary>
            <param name="nodeIndex">Node to begin the optimization process at.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedIntertreeTest`1.PrepareJobs(BepuPhysics.Trees.Tree@,BepuPhysics.Trees.Tree@,`0[],System.Int32)">
            <summary>
            Prepares the jobs associated with a self test. Must be called before a dispatch over PairTest.
            </summary>
            <param name="overlapHandlers">Callbacks used to handle individual overlaps detected by the self test.</param>
            <param name="threadCount">Number of threads to prepare jobs for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedIntertreeTest`1.CompleteTest">
            <summary>
            Cleans up after a multithreaded self test.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedIntertreeTest`1.PairTest(System.Int32)">
            <summary>
            Executes a single worker of the multithreaded self test.
            </summary>
            <param name="workerIndex">Index of the worker executing this set of tests.</param>
        </member>
        <member name="T:BepuPhysics.Trees.Tree.RefitAndRefineMultithreadedContext">
            <summary>
            Caches input and output for the multithreaded execution of a tree's refit and refinement operations.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.RefitForNodeBoundsChange(System.Int32)">
            <summary>
            Refits the bounding box of every parent of the node recursively to the root.
            </summary>
            <param name="nodeIndex">Node to propagate a node change for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.RemoveAt(System.Int32)">
            <summary>
            Removes a leaf at an index. If the index is not at the end of the leaf list, the last leaf is swapped into the removed location.
            </summary>
            <param name="leafIndex">Index of the leaf to remove.</param>
            <returns>Former index of the leaf that was moved into the removed leaf's slot, if any.
            If leafIndex pointed at the last slot in the list, then this returns -1 since no leaf was moved.</returns>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedSelfTest`1.PrepareJobs(BepuPhysics.Trees.Tree@,`0[],System.Int32)">
            <summary>
            Prepares the jobs associated with a self test. Must be called before a dispatch over PairTest.
            </summary>
            <param name="tree">Tree to test against itself.</param>
            <param name="overlapHandlers">Callbacks used to handle individual overlaps detected by the self test.</param>
            <param name="threadCount">Number of threads to prepare jobs for.</param>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedSelfTest`1.CompleteSelfTest">
            <summary>
            Cleans up after a multithreaded self test.
            </summary>
        </member>
        <member name="M:BepuPhysics.Trees.Tree.MultithreadedSelfTest`1.PairTest(System.Int32)">
            <summary>
            Executes a single worker of the multithreaded self test.
            </summary>
            <param name="workerIndex">Index of the worker executing this set of tests.</param>
        </member>
    </members>
</doc>
