<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BepuUtilities</name>
    </assembly>
    <members>
        <member name="T:BepuUtilities.AffineTransform">
            <summary>
             A transformation composed of a linear transformation and a translation.
            </summary>
        </member>
        <member name="F:BepuUtilities.AffineTransform.Translation">
            <summary>
             Translation in the affine transform.
            </summary>
        </member>
        <member name="F:BepuUtilities.AffineTransform.LinearTransform">
            <summary>
            Linear transform in the affine transform.
            </summary>
        </member>
        <member name="P:BepuUtilities.AffineTransform.Identity">
            <summary>
             Gets the identity affine transform.
            </summary>
        </member>
        <member name="M:BepuUtilities.AffineTransform.#ctor(System.Numerics.Vector3@)">
            <summary>
             Constructs a new affine transform.
            </summary>
            <param name="translation">Translation to use in the transform.</param>
        </member>
        <member name="M:BepuUtilities.AffineTransform.#ctor(System.Numerics.Quaternion@,System.Numerics.Vector3@)">
            <summary>
             Constructs a new affine tranform.
            </summary>
            <param name="orientation">Orientation to use as the linear transform.</param>
            <param name="translation">Translation to use in the transform.</param>
        </member>
        <member name="M:BepuUtilities.AffineTransform.#ctor(System.Numerics.Vector3@,System.Numerics.Quaternion@,System.Numerics.Vector3@)">
            <summary>
             Constructs a new affine transform.
            </summary>
            <param name="scaling">Scaling to apply in the linear transform.</param>
            <param name="orientation">Orientation to apply in the linear transform.</param>
            <param name="translation">Translation to apply.</param>
        </member>
        <member name="M:BepuUtilities.AffineTransform.#ctor(BepuUtilities.Matrix3x3@,System.Numerics.Vector3@)">
            <summary>
             Constructs a new affine transform.
            </summary>
            <param name="linearTransform">The linear transform component.</param>
            <param name="translation">Translation component of the transform.</param>
        </member>
        <member name="M:BepuUtilities.AffineTransform.Transform(System.Numerics.Vector3@,BepuUtilities.AffineTransform@,System.Numerics.Vector3@)">
            <summary>
             Transforms a vector by an affine transform.
            </summary>
            <param name="position">Position to transform.</param>
            <param name="transform">Transform to apply.</param>
            <param name="transformed">Transformed position.</param>
        </member>
        <member name="M:BepuUtilities.AffineTransform.Invert(BepuUtilities.AffineTransform@,BepuUtilities.AffineTransform@)">
            <summary>
             Inverts an affine transform.
            </summary>
            <param name="transform">Transform to invert.</param>
             <param name="inverse">Inverse of the transform.</param>
        </member>
        <member name="M:BepuUtilities.AffineTransform.InvertRigid(BepuUtilities.AffineTransform@,BepuUtilities.AffineTransform@)">
            <summary>
             Inverts a rigid transform.
            </summary>
            <param name="transform">Transform to invert.</param>
             <param name="inverse">Inverse of the transform.</param>
        </member>
        <member name="M:BepuUtilities.AffineTransform.Multiply(BepuUtilities.AffineTransform@,BepuUtilities.AffineTransform@,BepuUtilities.AffineTransform@)">
            <summary>
            Multiplies a transform by another transform.
            </summary>
            <param name="a">First transform.</param>
            <param name="b">Second transform.</param>
            <param name="transform">Combined transform.</param>
        </member>
        <member name="T:BepuUtilities.BoundingBox">
            <summary>
            Provides XNA-like axis-aligned bounding box functionality.
            </summary>
        </member>
        <member name="F:BepuUtilities.BoundingBox.Min">
            <summary>
            Location with the lowest X, Y, and Z coordinates in the axis-aligned bounding box.
            </summary>
        </member>
        <member name="F:BepuUtilities.BoundingBox.Max">
            <summary>
            Location with the highest X, Y, and Z coordinates in the axis-aligned bounding box.
            </summary>
        </member>
        <member name="M:BepuUtilities.BoundingBox.#ctor(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary>
            Constructs a bounding box from the specified minimum and maximum.
            </summary>
            <param name="min">Location with the lowest X, Y, and Z coordinates contained by the axis-aligned bounding box.</param>
            <param name="max">Location with the highest X, Y, and Z coordinates contained by the axis-aligned bounding box.</param>
        </member>
        <member name="M:BepuUtilities.BoundingBox.Intersects(BepuUtilities.BoundingBox@,BepuUtilities.BoundingBox@)">
            <summary>
            Determines if a bounding box intersects another bounding box.
            </summary>
            <param name="a">First bounding box to test.</param>
            <param name="b">Second bounding box to test.</param>
            <returns>Whether the bounding boxes intersected.</returns>
        </member>
        <member name="M:BepuUtilities.BoundingBox.Intersects(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Determines if a bounding box intersects another bounding box.
            </summary>
            <param name="a">First bounding box to test.</param>
            <param name="b">Second bounding box to test.</param>
            <returns>Whether the bounding boxes intersected.</returns>
        </member>
        <member name="M:BepuUtilities.BoundingBox.ComputeVolume(BepuUtilities.BoundingBox@)">
            <summary>
            Computes the volume of the bounding box.
            </summary>
            <param name="box">Bounding box to measure.</param>
            <returns>Volume of the bounding box.</returns>
        </member>
        <member name="M:BepuUtilities.BoundingBox.CreateMerged(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Computes a bounding box which contains two other bounding boxes.
            </summary>
            <param name="minA">Minimum of the first bounding box to merge.</param>
            <param name="maxA">Maximum of the first bounding box to merge.</param>
            <param name="minB">Minimum of the second bounding box to merge.</param>
            <param name="maxB">Maximum of the second bounding box to merge.</param>
            <param name="min">Minimum of the merged bounding box.</param>
            <param name="max">Maximum of the merged bounding box.</param>
        </member>
        <member name="M:BepuUtilities.BoundingBox.CreateMerged(BepuUtilities.BoundingBox@,BepuUtilities.BoundingBox@,BepuUtilities.BoundingBox@)">
            <summary>
            Computes a bounding box which contains two other bounding boxes.
            </summary>
            <param name="a">First bounding box to contain.</param>
            <param name="b">Second bounding box to contain.</param>
            <param name="merged">Bounding box to contain both input boxes.</param>
        </member>
        <member name="M:BepuUtilities.BoundingBox.Intersects(BepuUtilities.BoundingSphere@)">
            <summary>
            Determines if a bounding box intersects a bounding sphere.
            </summary>
            <param name="boundingSphere">Sphere to test for intersection.</param>
            <returns>Whether the bounding shapes intersect.</returns>
        </member>
        <member name="M:BepuUtilities.BoundingBox.CreateFromPoints(System.Collections.Generic.IList{System.Numerics.Vector3})">
            <summary>
            Creates the smallest possible bounding box that contains a list of points.
            </summary>
            <param name="points">Points to enclose with a bounding box.</param>
            <returns>Bounding box which contains the list of points.</returns>
        </member>
        <member name="M:BepuUtilities.BoundingBox.CreateFromSphere(BepuUtilities.BoundingSphere@,BepuUtilities.BoundingBox@)">
            <summary>
            Creates a bounding box from a bounding sphere.
            </summary>
            <param name="boundingSphere">Bounding sphere to be used to create the bounding box.</param>
            <param name="boundingBox">Bounding box created from the bounding sphere.</param>
        </member>
        <member name="M:BepuUtilities.BoundingBox.ToString">
            <summary>
            Creates a string representation of the bounding box.
            </summary>
            <returns>String representation of the bounding box.</returns>
        </member>
        <member name="T:BepuUtilities.BoundingSphere">
            <summary>
            Provides XNA-like bounding sphere functionality.
            </summary>
        </member>
        <member name="F:BepuUtilities.BoundingSphere.Center">
            <summary>
            Location of the center of the sphere.
            </summary>
        </member>
        <member name="F:BepuUtilities.BoundingSphere.Radius">
            <summary>
            Radius of the sphere.
            </summary>
        </member>
        <member name="M:BepuUtilities.BoundingSphere.#ctor(System.Numerics.Vector3,System.Single)">
            <summary>
            Constructs a new bounding sphere.
            </summary>
            <param name="center">Location of the center of the sphere.</param>
            <param name="radius">Radius of the sphere.</param>
        </member>
        <member name="T:BepuUtilities.BundleIndexing">
            <summary>
            Some helpers for indexing into vector bundles.
            </summary>
        </member>
        <member name="P:BepuUtilities.BundleIndexing.VectorMask">
            <summary>
            <![CDATA[Gets the mask value such that x & VectorMask computes x % Vector<float>.Count.]]>
            </summary>
            <remarks>The JIT recognizes that this value is constant!</remarks>
        </member>
        <member name="P:BepuUtilities.BundleIndexing.VectorShift">
            <summary>
            <![CDATA[Gets the shift value such that x >> VectorShift divides x by Vector<float>.Count.]]>
            </summary>
            <remarks>The JIT recognizes that this value is constant!</remarks>
        </member>
        <member name="M:BepuUtilities.BundleIndexing.GetLastSetLaneCount(System.Numerics.Vector{System.Int32})">
            <summary>
            Gets the number of lanes that occur at or before the last set lane. In other words, if the lanes in the vector are (-1, 0, -1, 0), then this will return 3.
            </summary>
            <param name="v">Vector to examine.</param>
            <returns>Number of lanes that occur at or before the last set lane.</returns>
        </member>
        <member name="T:BepuUtilities.Collections.ArrayEnumerable`1">
            <summary>
            Enumerable wrapper of an array interval.
            </summary>
            <typeparam name="T">Type of the array elements.</typeparam>
        </member>
        <member name="M:BepuUtilities.Collections.ArrayEnumerable`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a enumerable that spans an interval in an array.
            </summary>
            <param name="array">Array to iterate over.</param>
            <param name="start">Inclusive beginning of the iteration interval.</param>
            <param name="end">Exclusive end of the iteration interval.</param>
        </member>
        <member name="M:BepuUtilities.Collections.ArrayEnumerable`1.#ctor(`0[],System.Int32)">
            <summary>
            Creates a enumerable that starts at the first index of the array.
            </summary>
            <param name="array">Array to iterate over.</param>
            <param name="count">Exclusive end of the iteration interval.</param>
        </member>
        <member name="M:BepuUtilities.Collections.ArrayEnumerable`1.#ctor(`0[])">
            <summary>
            Creates a enumerable over the entire array.
            </summary>
            <param name="array">Array to iterate over.</param>
        </member>
        <member name="T:BepuUtilities.Collections.ArrayEnumerator`1">
            <summary>
            Enumerates over a given array region.
            </summary>
            <typeparam name="T">Type of the array to iterate over.</typeparam>
        </member>
        <member name="T:BepuUtilities.Collections.IComparerRef`1">
            <summary>
            Defines a type capable of comparing two objects passed by reference.
            </summary>
            <typeparam name="T">Type of the objects to compare.</typeparam>
        </member>
        <member name="T:BepuUtilities.Collections.IEqualityComparerRef`1">
            <summary>
            Defines a type capable of performing the hashing and equality comparisons necessary for hash based collections.
            </summary>
            <typeparam name="T">Type of the elements to be hashed and compared.</typeparam>
        </member>
        <member name="T:BepuUtilities.Collections.IndexSet">
            <summary>
            Collection of unique indices supporting add, remove, and contains operations.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.IndexSet.Flags">
            <summary>
            Since we only ever need to support add, remove and contains checks, and because the indices are guaranteed unique,
            we can just use packed bitfields. Each bit represents one index's containment state.
            </summary>
            <remarks> 
            This can grow up to the number of (indexCount / 8) bytes in the worst case, but that is much, much smaller than using a dictionary or set.
            16384 bodies would only take 2KB. Even if you have 1000 batches all at that size, it's a pretty unconcerning amount of storage.
            (And to be clear, 1000 batches is a crazy pathological number. Most simulations will have less than 20 batches.)
            </remarks>
        </member>
        <member name="M:BepuUtilities.Collections.IndexSet.CanFit(System.Span{System.Int32})">
            <summary>
            Gets whether the batch could hold the specified indices.
            </summary>
            <param name="indexList">List of indices to check for in the batch.</param>
            <returns>True if none of the indices are present in the set, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.IndexSet.SetUnsafely(System.Int32)">
            <summary>
            Sets an index in the set to contained without checking capacity or whether it is already set.
            </summary>
            <param name="index">Index to add.</param>
            <remarks>This is functionally identical to the AddUnsafely method, but it doesn't include the same debug assertions. Just a way to make intent clear so that the assert can catch errors.</remarks>
        </member>
        <member name="M:BepuUtilities.Collections.IndexSet.Set(System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Sets an index in the set to contained without checking whether it is already set.
            </summary>
            <param name="index">Index to add.</param>
            <param name="pool">Pool to reuse the set if necessary.</param>
            <remarks>This is functionally identical to the Add method, but it doesn't include the same debug assertions. Just a way to make intent clear so that the assert can catch errors.</remarks>
        </member>
        <member name="M:BepuUtilities.Collections.IndexSet.Unset(System.Int32)">
            <summary>
            Marks an index in the set as uncontained without checking whether it is already set.
            </summary>
            <param name="index">Index to add.</param>
            <remarks>This is functionally identical to the Remove method, but it doesn't include the same debug assertions. Just a way to make intent clear so that the assert can catch errors.</remarks>
        </member>
        <member name="M:BepuUtilities.Collections.IndexSet.AddUnsafely(System.Int32)">
            <summary>
            Adds an index to the set without checking capacity.
            </summary>
            <param name="index">Index to add.</param>
        </member>
        <member name="M:BepuUtilities.Collections.IndexSet.Add(System.Int32,BepuUtilities.Memory.BufferPool)">
            <summary>
            Adds an index to the set.
            </summary>
            <param name="index">Index to add.</param>
            <param name="pool">Pool to use to resize the set if necessary.</param>
        </member>
        <member name="M:BepuUtilities.Collections.IndexSet.Dispose(BepuUtilities.Memory.BufferPool)">
            <summary>
            Disposes the internal buffer.
            </summary>
            <remarks>The instance can be reused after a Dispose if EnsureCapacity or Resize is called.
            That's a little meaningless given that the instance is a value type, but hey, you don't have to new another one, that's something.</remarks>
        </member>
        <member name="T:BepuUtilities.Collections.IPredicate`1">
            <summary>
            Defines a type able to match an element.
            </summary>
            <typeparam name="T">Type of the object to match.</typeparam>
        </member>
        <member name="M:BepuUtilities.Collections.LSBRadixSort.Sort``1(BepuUtilities.Memory.Buffer{System.Int32}@,BepuUtilities.Memory.Buffer{``0}@,BepuUtilities.Memory.Buffer{System.Int32}@,BepuUtilities.Memory.Buffer{``0}@,System.Int32,System.Int32,System.Int32,BepuUtilities.Memory.BufferPool,BepuUtilities.Memory.Buffer{System.Int32}@,BepuUtilities.Memory.Buffer{``0}@)">
            <summary>
            Sorts a set of keys and their associated values using radix sort.
            </summary>
            <remarks>Only one invocation of the sort can be running at a time on a given instance of the sorter.</remarks>
            <typeparam name="TValue">Type of the values to sort.</typeparam>
            <typeparam name="TKeySpan">Type of the span that holds the keys to sort.</typeparam>
            <typeparam name="TValueSpan">Type of the span that holds the values to sort.</typeparam>
            <param name="inputKeys">Span containing the keys to sort.</param>
            <param name="inputValues">Span containing the values to sort.</param>
            <param name="scratchKeys">Scratch array to write temporary results into.</param>
            <param name="scratchValues">Scratch array to write temporary results into.</param>
            <param name="startIndex">Start location of the sort.</param>
            <param name="count">Number of elements, including the start index, to sort.</param>
            <param name="keysUpperBound">Value equal to or greater than the value of any key within the sorted key set. Tighter bounds can allow faster execution.</param>
            <param name="bufferPool">Pool to pull temporary buffers from.</param>
            <param name="sortedKeys">Span containing the sorted keys. Will be either the input keys span or scratchKeys span depending on the keysUpperBound.</param>
            <param name="sortedValues">Span containing the sorted values. Will be either the input values span or scratchValues span depending on the keysUpperBound.
            Only the region defined by the startIndex and count is modified; the remainder of the span (whether it be the input span or the scratch span) is unmodified.</param>
        </member>
        <member name="T:BepuUtilities.Collections.PrimitiveComparer`1">
            <summary>
            Provides optimized equality testing, comparison, and hashing for primitive types.
            </summary>
            <typeparam name="T">Type to compare and hash.</typeparam>
        </member>
        <member name="T:BepuUtilities.Collections.HashHelper">
            <summary>
            Contains basic helpers for hashing.
            </summary>
        </member>
        <member name="M:BepuUtilities.Collections.HashHelper.Rehash(System.Int32)">
            <summary>
            Redistributes a hash. Useful for converting unique but contiguous hashes into a semirandom distribution.
            </summary>
            <param name="hash">Hash to redistribute.</param>
            <returns>Hashed hash.</returns>
        </member>
        <member name="T:BepuUtilities.Collections.QuickDictionary`3">
            <summary>
            Container supporting constant time adds and removes of key-value pairs while preserving fast iteration times.
            Offers very direct access to information at the cost of safety.
            </summary>
            <remarks>
            <para>
            Be very careful when using this type. It has sacrificed a lot upon the altar of performance; a few notable issues include:
            it is a value type and copying it around will break things without extreme care,
            it cannot be validly default-constructed,
            it exposes internal structures to user modification, 
            it rarely checks input for errors,
            the enumerator doesn't check for mid-enumeration modification,
            it allows unsafe addition that can break if the user doesn't manage the capacity,
            it works on top of an abstracted memory blob which might internally be a pointer that could be rugpulled, 
            it does not (and is incapable of) checking that provided memory gets returned to the same pool that it came from.
            </para>
            <para>Note that the implementation is extremely simple. It uses single-step linear probing under the assumption of very low collision rates.
            A generous table capacity is recommended; this trades some memory for simplicity and runtime performance.</para></remarks>
            <typeparam name="TKey">Type of key held by the container.</typeparam>
            <typeparam name="TValue">Type of value held by the container.</typeparam>
            <typeparam name="TEqualityComparer">Type of the equality tester and hash calculator used.</typeparam>
        </member>
        <member name="F:BepuUtilities.Collections.QuickDictionary`3.Count">
            <summary>
            Gets the number of elements in the dictionary.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickDictionary`3.TableMask">
            <summary>
            Mask for use in performing fast modulo operations for hashes. Requires that the table span is a power of 2.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickDictionary`3.TablePowerOffset">
            <summary>
            Desired size of the table relative to the size of the key/value spans in terms of a power of 2. Table capacity target will be elementCapacityTarget * 2^TablePowerOffset.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickDictionary`3.Table">
            <summary>
            Backing memory of the dictionary's table. Values are distributed according to the EqualityComparer's hash function.
            Slots containing 0 are unused and point to nothing. Slots containing higher values are equal to one plus the index of an element in the Span.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickDictionary`3.Keys">
            <summary>
            Backing memory containing the keys of the dictionary.
            Indices from 0 to Count-1 hold actual data. All other data is undefined.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickDictionary`3.Values">
            <summary>
            Backing memory containing the values of the dictionary.
            Indices from 0 to Count-1 hold actual data. All other data is undefined.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickDictionary`3.EqualityComparer">
            <summary>
            Equality comparer used to compare and hash keys.
            </summary>
        </member>
        <member name="P:BepuUtilities.Collections.QuickDictionary`3.Item(System.Int32)">
            <summary>
            Gets or sets a key-value pair at the given index in the list representation.
            </summary>
            <param name="index">Index to grab a pair from.</param>
            <returns>Pair at the given index in the dictionary.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.#ctor(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{`1}@,BepuUtilities.Memory.Buffer{System.Int32}@,`2,System.Int32)">
            <summary>
            Creates a new dictionary.
            </summary>
            <param name="initialKeySpan">Span to use as backing memory of the dictionary keys.</param>
            <param name="initialValueSpan">Span to use as backing memory of the dictionary values.</param>
            <param name="initialTableSpan">Span to use as backing memory of the table. Must be zeroed.</param>
            <param name="comparer">Comparer to use for the dictionary.</param>
            <param name="tablePowerOffset">Target size of the table relative to the number of stored elements.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.#ctor(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{`1}@,BepuUtilities.Memory.Buffer{System.Int32}@,System.Int32)">
            <summary>
            Creates a new dictionary with a default constructed comparer.
            </summary>
            <param name="initialKeySpan">Span to use as backing memory of the dictionary keys.</param>
            <param name="initialValueSpan">Span to use as backing memory of the dictionary values.</param>
            <param name="initialTableSpan">Span to use as backing memory of the table. Must be zeroed.</param>
            <param name="comparer">Comparer to use for the dictionary.</param>
            <param name="tablePowerOffset">Target size of the table relative to the number of stored elements.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.#ctor(System.Int32,System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool,`2)">
            <summary>
            Creates a new dictionary.
            </summary>
            <param name="initialCapacity">Initial target size of the key and value spans. The size of the initial buffer will be at least as large as the initialCapacity.</param>
            <param name="tableSizePower">Target capacity relative to the initial capacity in terms of a power of 2. The size of the initial table buffer will be at least 2^tableSizePower times larger than the initial capacity.</param>
            <param name="comparer">Comparer to use in the dictionary.</param>
            <param name="pool">Pool used for spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.#ctor(System.Int32,System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Creates a new dictionary with a default constructed comparer.
            </summary>
            <param name="initialCapacity">Initial target size of the key and value spans. The size of the initial buffer will be at least as large as the initialCapacity.</param>
            <param name="tableSizePower">Target capacity relative to the initial capacity in terms of a power of 2. The size of the initial table buffer will be at least 2^tableSizePower times larger than the initial capacity.</param>
            <param name="comparer">Comparer to use in the dictionary.</param>
            <param name="pool">Pool used for spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.#ctor(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Creates a new dictionary with a default constructed comparer.
            </summary>
            <param name="initialCapacity">Initial target size of the key and value spans. The size of the initial buffer will be at least as large as the initialCapacity.</param>
            <param name="comparer">Comparer to use in the dictionary.</param>
            <param name="pool">Pool used for spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.Resize(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{`1}@,BepuUtilities.Memory.Buffer{System.Int32}@,BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{`1}@,BepuUtilities.Memory.Buffer{System.Int32}@)">
            <summary>
            Swaps out the dictionary's backing memory span for a new span.
            If the new span is smaller, the dictionary's count is truncated and the extra elements are dropped. 
            The old span is not cleared or returned to any pool; if it needs to be pooled or cleared, the user must handle it.
            </summary>
            <param name="newKeySpan">New span to use for keys.</param>
            <param name="newValueSpan">New span to use for values.</param>
            <param name="newTableSpan">New span to use for the table. Must be zeroed.</param>
            <param name="oldKeySpan">Previous span used for keys.</param>
            <param name="oldValueSpan">Previous span used for values.</param>
            <param name="oldTableSpan">Previous span used for the table.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.Resize(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Resizes the dictionary's backing array for the given size.
            If the new span is smaller, the dictionary's count is truncated and the extra elements are dropped. 
            </summary>
            <param name="newSize">Minimum size of the new object memory block. Actual size may be larger.</param>
            <param name="pool">Pool used for spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.Dispose(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Returns the resources associated with the dictionary to pools.
            </summary>
            <param name="keyPool">Pool used for key spans.</param>   
            <param name="valuePool">Pool used for value spans.</param>   
            <param name="tablePool">Pool used for table spans.</param>
            <typeparam name="TKeyPool">Type of the pool used for key spans.</typeparam>
            <typeparam name="TValuePool">Type of the pool used for value spans.</typeparam>
            <typeparam name="TTablePool">Type of the pool used for table spans.</typeparam>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.EnsureCapacity(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Ensures that the dictionary has enough room to hold the specified number of elements.
            </summary>     
            <param name="pool">Pool used for spans.</param>   
            <param name="count">Number of elements to hold.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.Compact(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Shrinks the internal buffers to the smallest acceptable size and releases the old buffers to the pools.
            </summary>
            <param name="pool">Pool used for spans.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.GetTableIndices(`0@,System.Int32@,System.Int32@)">
            <summary>
            Gets the index of the element in the table.
            </summary>
            <param name="element">Element to look up.</param>
            <param name="tableIndex">Index of the element in the redirect table, or if it is not present, the index of where it would be added.</param>
            <param name="elementIndex">The index of the element in the element arrays, if it exists; -1 otherwise.</param>
            <returns>True if the element is present in the dictionary, false if it is not.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.IndexOf(`0)">
            <summary>
            Gets the index of the key in the dictionary values list if it exists.
            </summary>
            <param name="key">Key to get the index of.</param>
            <returns>The index of the key if the key exists in the dictionary, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.IndexOf(`0@)">
            <summary>
            Gets the index of the key in the dictionary values list if it exists.
            </summary>
            <param name="key">Key to get the index of.</param>
            <returns>The index of the key if the key exists in the dictionary, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.ContainsKey(`0)">
            <summary>
            Checks if a given key already belongs to the dictionary.
            </summary>
            <param name="key">Key to test for.</param>
            <returns>True if the key already belongs to the dictionary, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.ContainsKey(`0@)">
            <summary>
            Checks if a given key already belongs to the dictionary.
            </summary>
            <param name="key">Key to test for.</param>
            <returns>True if the key already belongs to the dictionary, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.TryGetValue(`0,`1@)">
            <summary>
            Tries to retrieve the value associated with a key if it exists.
            </summary>
            <param name="key">Key to look up.</param>
            <param name="value">Value associated with the specified key.</param>
            <returns>True if a value was found, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.TryGetValue(`0@,`1@)">
            <summary>
            Tries to retrieve the value associated with a key if it exists.
            </summary>
            <param name="key">Key to look up.</param>
            <param name="value">Value associated with the specified key.</param>
            <returns>True if a value was found, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FindOrAllocateSlotUnsafely(`0@,System.Int32@)">
            <summary>
            Attempts to find the index of the given key. If it is present, outputs the index and returns true. If it is not present, it allocates a slot for it, outputs the index of that new slot, and returns false.
            If a new slot is allocated, the value stored in the slot is undefined.
            </summary>
            <param name="key">Key to find or allocate a slot for.</param>
            <param name="slotIndex">Index of the found or allocated slot.</param>
            <returns>True if the key was already present in the dictionary, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FindOrAllocateSlotUnsafely(`0,System.Int32@)">
            <summary>
            Attempts to find the index of the given key. If it is present, outputs the index and returns true. If it is not present, it allocates a slot for it, outputs the index of that new slot, and returns false.
            If a new slot is allocated, the value stored in the slot is undefined.
            </summary>
            <param name="key">Key to find or allocate a slot for.</param>
            <param name="slotIndex">Index of the found or allocated slot.</param>
            <returns>True if the key was already present in the dictionary, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FindOrAllocateSlot(`0@,BepuUtilities.Memory.BufferPool,System.Int32@)">
            <summary>
            Attempts to find the index of the given key. If it is present, outputs the index and returns true. If it is not present, it allocates a slot for it, outputs the index of that new slot, and returns false.
            If a new slot is allocated, the value stored in the slot is undefined.
            </summary>
            <param name="key">Key to find or allocate a slot for.</param>
            <param name="pool">Pool used to resize the container if necessary to allocate.</param>
            <param name="slotIndex">Index of the found or allocated slot.</param>
            <returns>True if the key was already present in the dictionary, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FindOrAllocateSlot(`0,BepuUtilities.Memory.BufferPool,System.Int32@)">
            <summary>
            Attempts to find the index of the given key. If it is present, outputs the index and returns true. If it is not present, it allocates a slot for it, outputs the index of that new slot, and returns false.
            If a new slot is allocated, the value stored in the slot is undefined.
            </summary>
            <param name="key">Key to find or allocate a slot for.</param>
            <param name="pool">Pool used to resize the container if necessary to allocate.</param>
            <param name="slotIndex">Index of the found or allocated slot.</param>
            <returns>True if the key was already present in the dictionary, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.AddAndReplaceUnsafely(`0@,`1@)">
            <summary>
            Adds a pair to the dictionary. If a version of the key (same hash code, 'equal' by comparer) is already present,
            the existing pair is replaced by the given version.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <returns>True if the pair was added to the dictionary, false if the key was already present and its pair was replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.AddAndReplaceUnsafely(`0,`1@)">
            <summary>
            Adds a pair to the dictionary. If a version of the key (same hash code, 'equal' by comparer) is already present,
            the existing pair is replaced by the given version.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <returns>True if the pair was added to the dictionary, false if the key was already present and its pair was replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.AddUnsafely(`0@,`1@)">
            <summary>
            Adds a pair to the dictionary if it is not already present.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <returns>True if the pair was added to the dictionary, false if the key was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.AddUnsafely(`0,`1@)">
            <summary>
            Adds a pair to the dictionary if it is not already present.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <returns>True if the pair was added to the dictionary, false if the key was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.AddAndReplace(`0@,`1@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds a pair to the dictionary. If a version of the key (same hash code, 'equal' by comparer) is already present,
            the existing pair is replaced by the given version.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <param name="pool">Pool used for spans.</param>   
            <returns>True if the pair was added to the dictionary, false if the key was already present and its pair was replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.AddAndReplace(`0,`1@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds a pair to the dictionary. If a version of the key (same hash code, 'equal' by comparer) is already present,
            the existing pair is replaced by the given version.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <param name="pool">Pool used for spans.</param>   
            <returns>True if the pair was added to the dictionary, false if the key was already present and its pair was replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.Add(`0@,`1@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds a pair to the dictionary if it is not already present.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <param name="pool">Pool used for spans.</param>   
            <typeparam name="TPool">Type of the pool used for spans.</typeparam>
            <returns>True if the pair was added to the dictionary, false if the key was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.Add(`0,`1@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds a pair to the dictionary if it is not already present.
            </summary>
            <param name="key">Key of the pair to add.</param>
            <param name="value">Value of the pair to add.</param>
            <param name="pool">Pool to pull resources from and to return resources to.</param>   
            <typeparam name="TPool">Type of the pool to use.</typeparam>
            <returns>True if the pair was added to the dictionary, false if the key was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FastRemove(System.Int32,System.Int32)">
            <summary>
            Removes an element from the dictionary according to its table and element index. Can only be used if the table and element index are valid.
            </summary>
            <param name="tableIndex">Index of the table entry associated with the existing element to remove.</param>
            <param name="elementIndex">Index of the existing element to remove in the contiguous key/value arrays.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FastRemove(`0@)">
            <summary>
            Removes a pair associated with a key from the dictionary if belongs to the dictionary.
            Does not preserve the order of elements in the dictionary.
            </summary>
            <param name="key">Key of the pair to remove.</param>
            <returns>True if the key was found and removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FastRemove(`0)">
            <summary>
            Removes a pair associated with a key from the dictionary if belongs to the dictionary.
            Does not preserve the order of elements in the dictionary.
            </summary>
            <param name="key">Key of the pair to remove.</param>
            <returns>True if the key was found and removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.Clear">
            <summary>
            Removes all elements from the dictionary.
            </summary>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.FastClear">
            <summary>
            Removes all elements from the dictionary without modifying the contents of the keys or values arrays.
            </summary>
        </member>
        <member name="M:BepuUtilities.Collections.QuickDictionary`3.AsSpans(System.Span{`0}@,System.Span{`1}@)">
            <summary>
            Gets the keys and values wrapped in spans.
            </summary>
            <param name="keys">Keys from the dictionary.</param>
            <param name="values">Values from the dictionary.</param>
        </member>
        <member name="T:BepuUtilities.Collections.QuickList`1">
            <summary>
            Container supporting list-like behaviors built on top of unmanaged buffers.
            </summary>
            <remarks>
            Be very careful when using this type. It has sacrificed a lot upon the altar of performance; a few notable issues include:
            it is a value type and copying it around will break things without extreme care,
            it cannot be validly default-constructed,
            it exposes internal structures to user modification, 
            it rarely checks input for errors,
            the enumerator doesn't check for mid-enumeration modification,
            it allows unsafe addition that can break if the user doesn't manage the capacity,
            it works on top of an abstracted memory blob which might internally be a pointer that could be rugpulled, 
            it does not (and is incapable of) checking that provided memory gets returned to the same pool that it came from.
            </remarks>
            <typeparam name="T">Type of the elements in the list.</typeparam>
        </member>
        <member name="F:BepuUtilities.Collections.QuickList`1.Span">
            <summary>
            Backing memory containing the elements of the list.
            Indices from 0 to Count-1 hold actual data. All other data is undefined.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickList`1.Count">
            <summary>
            Number of elements in the list.
            </summary>
        </member>
        <member name="P:BepuUtilities.Collections.QuickList`1.Item(System.Int32)">
            <summary>
            Gets a reference to the element at the given index in the list.
            </summary>
            <param name="index">Index to grab an element from.</param>
            <returns>Element at the given index in the list.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.GetPointer(System.Int32)">
            <summary>
            Gets a pointer to the element at the given index in the list.
            </summary>
            <param name="index">Index to grab an element pointer from.</param>
            <returns>Pointer to the element at the given index in the list.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.#ctor(BepuUtilities.Memory.Buffer{`0}@)">
            <summary>
            Creates a new list.
            </summary>
            <param name="initialSpan">Span to use as backing memory to begin with.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.#ctor(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Creates a new list.
            </summary>
            <param name="pool">Pool to pull a span from.</param>
            <param name="minimumInitialCount">The minimum size of the region to be pulled from the pool. Actual span may be larger.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Resize(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{`0}@)">
            <summary>
            Swaps out the list's backing memory span for a new span.
            If the new span is smaller, the list's count is truncated and the extra elements are dropped. 
            The old span is not cleared or returned to any pool; if it needs to be pooled or cleared, the user must handle it.
            </summary>
            <param name="newSpan">New span to use.</param>
            <param name="oldSpan">Previous span used for elements.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Resize(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Resizes the list's backing array for the given size.
            Any elements that do not fit in the resized span are dropped and the count is truncated.
            </summary>
            <param name="newSize">Minimum number of elements required in the new backing array. Actual capacity of the created span may exceed this size.</param>
            <param name="pool">Pool to pull a new span from and return the old span to.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Dispose(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Returns the resources associated with the list to pools. Any managed references still contained within the list are cleared (and some unmanaged resources may also be cleared).
            </summary>
            <param name="pool">Pool used for element spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.EnsureCapacity(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Ensures that the list has enough room to hold the specified number of elements. Can be used to initialize a list.
            </summary>
            <param name="count">Number of elements to hold.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Compact(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Compacts the internal buffer to the minimum size required for the number of elements in the list.
            </summary>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRangeUnsafely(BepuUtilities.Memory.Buffer{`0}@,System.Int32,System.Int32)">
            <summary>
            Adds the elements of a buffer to the QuickList without checking capacity.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRange(BepuUtilities.Memory.Buffer{`0}@,System.Int32,System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds the elements of a buffer to the QuickList.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRangeUnsafely(BepuUtilities.Memory.Buffer{`0}@)">
            <summary>
            Adds the elements of a buffer to the QuickList without checking capacity.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRange(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds the elements of a buffer to the QuickList.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRangeUnsafely(System.Span{`0}@,System.Int32,System.Int32)">
            <summary>
            Adds the elements of a span to the QuickList without checking capacity.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRange(System.Span{`0}@,System.Int32,System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds the elements of a span to the QuickList.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRangeUnsafely(System.Span{`0}@)">
            <summary>
            Adds the elements of a span to the QuickList without checking capacity.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRange(System.Span{`0}@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds the elements of a span to the QuickList.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRangeUnsafely(System.ReadOnlySpan{`0}@,System.Int32,System.Int32)">
            <summary>
            Adds the elements of a span to the QuickList without checking capacity.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRange(System.ReadOnlySpan{`0}@,System.Int32,System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds the elements of a span to the QuickList.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRangeUnsafely(System.ReadOnlySpan{`0}@)">
            <summary>
            Adds the elements of a span to the QuickList without checking capacity.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddRange(System.ReadOnlySpan{`0}@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds the elements of a span to the QuickList.
            </summary>
            <param name="span">Span of elements to add.</param>
            <param name="start">Start index of the added range.</param>
            <param name="count">Number of elements in the added range.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AllocateUnsafely">
            <summary>
            Appends space on the end of the list without checking capacity and returns a reference to it.
            </summary>
            <returns>Reference to the allocated space.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AllocateUnsafely(System.Int32)">
            <summary>
            Appends space on the end of the list without checking capacity and returns a reference to the beginning of it.
            </summary>
            <param name="count">Number of elements to allocate space for.</param>
            <returns>Reference to the beginning of the allocated space.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Allocate(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Appends space on the end of the list and returns a reference to it.
            </summary>
            <returns>Reference to the allocated space.</returns>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Allocate(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Appends space on the end of the list and returns a reference to the beginning of it.
            </summary>
            <returns>Reference to the beginning of the allocated space.</returns>
            <param name="count">Number of elements to allocate space for.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.AddUnsafely(`0@)">
            <summary>
            Adds the element to the list without checking the count against the capacity.
            </summary>
            <param name="element">Item to add.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Add(`0@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds the element to the list.
            </summary>
            <param name="element">Item to add.</param>
            <param name="pool">Pool used to obtain a new span if needed.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.IndexOf(`0)">
            <summary>
            Gets the index of the element in the list using the default comparer, if present.
            </summary>
            <param name="element">Element to find.</param>
            <returns>Index of the element in the list if present, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.IndexOf(`0@)">
            <summary>
            Gets the index of the element in the list using the default comparer, if present.
            </summary>
            <param name="element">Element to find.</param>
            <returns>Index of the element in the list if present, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.IndexOf``1(``0@)">
            <summary>
            Gets the index of the first element in the list which matches a predicate, if any.
            </summary>
            <param name="predicate">Predicate to match.</param>
            <returns>Index of the first matching element in the list if present, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Remove(`0@)">
            <summary>
            Removes an element from the list. Preserves the order of elements.
            </summary>
            <param name="element">Element to remove from the list.</param>
            <returns>True if the element was present and was removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Remove(`0)">
            <summary>
            Removes an element from the list. Preserves the order of elements.
            </summary>
            <param name="element">Element to remove from the list.</param>
            <returns>True if the element was present and was removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Remove``1(``0@)">
            <summary>
            Removes the first element that matches a predicate from the list. Preserves the order of elements.
            </summary>
            <param name="predicate">Predicate to test elements with.</param>
            <returns>True if an element matched and was removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.FastRemove(`0@)">
            <summary>
            Removes an element from the list. Does not preserve the order of elements.
            </summary>
            <param name="element">Element to remove from the list.</param>
            <returns>True if the element was present and was removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.FastRemove(`0)">
            <summary>
            Removes an element from the list. Comparisons use the default comparer for the type. Does not preserve the order of elements.
            </summary>
            <param name="element">Element to remove from the list.</param>
            <returns>True if the element was present and was removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.FastRemove``1(``0@)">
            <summary>
            Removes the first element from the list that matches a predicate, moving from low to high indices. Does not preserve the order of elements.
            </summary>
            <param name="predicate">Predicate to test elements with.</param>
            <returns>True if an element matched and was removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.RemoveAt(System.Int32)">
            <summary>
            Removes an element from the list at the given index. Preserves the order of elements.
            </summary>
            <param name="index">Index of the element to remove from the list.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.FastRemoveAt(System.Int32)">
            <summary>
            Removes an element from the list at the given index. Does not preserve the order of elements.
            </summary>
            <param name="index">Index of the element to remove from the list.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Pop(`0@)">
            <summary>
            Removes and outputs the last element in the list. Assumes positive count. User is responsible for guaranteeing correctness.
            </summary>
            <param name="element">Last element of the list.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.TryPop(`0@)">
            <summary>
            Removes and outputs the last element in the list if it exists.
            </summary>
            <param name="element">Last element of the list.</param>
            <returns>True if the element existed and was removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="element"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            <param name="element">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Contains(`0@)">
            <summary>
            Determines whether the collection contains a specific value.
            </summary>
            <returns>
            True if <paramref name="element"/> is found in the collection; otherwise, false.
            </returns>
            <param name="element">The object to locate in the collection.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Contains``1(``0@)">
            <summary>
            Determines whether the collection contains an element that matches a predicate.
            </summary>
            <returns>
            True if an element matching the predicate exists, otherwise false.
            </returns>
            <param name="predicate">The predicate to test against elements in the list.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickList`1.Clear">
            <summary>
            Clears the list by setting the count to zero and explicitly setting all relevant indices in the backing array to default values.
            </summary>
        </member>
        <member name="T:BepuUtilities.Collections.QuickQueue`1">
            <summary>
            Container supporting double ended queue behaviors built on top of pooled arrays.
            </summary>
            <remarks>
            Be very careful when using this type. It has sacrificed a lot upon the altar of performance; a few notable issues include:
            it is a value type and copying it around will break things without extreme care,
            it cannot be validly default-constructed,
            it exposes internal structures to user modification, 
            it rarely checks input for errors,
            the enumerator doesn't check for mid-enumeration modification,
            it allows unsafe addition that can break if the user doesn't manage the capacity,
            it works on top of an abstracted memory blob which might internally be a pointer that could be rugpulled, 
            it does not (and is incapable of) checking that provided memory gets returned to the same pool that it came from.
            </remarks>
            <typeparam name="T">Type of the elements in the queue.</typeparam>
        </member>
        <member name="F:BepuUtilities.Collections.QuickQueue`1.Count">
            <summary>
            Number of elements in the queue.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickQueue`1.FirstIndex">
            <summary>
            Index of the first element in the queue.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickQueue`1.LastIndex">
            <summary>
            Index of the last element in the queue.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickQueue`1.CapacityMask">
            <summary>
            Mask based on the current span length used to do fast modulo operations; requires that the span has a power of 2 length.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickQueue`1.Span">
            <summary>
            Gets the backing memory containing the elements of the queue.
            Indices from FirstIndex to LastIndex inclusive hold actual data. All other data is undefined.
            Watch out for wrap around; LastIndex can be less than FirstIndex even when count > 0!
            </summary>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.GetBackingArrayIndex(System.Int32)">
            <summary>
            Gets the backing array index for the logical queue index.
            </summary>
            <param name="queueIndex">Index in the logical queue.</param>
            <returns>The index in in the backing array corresponding to the given logical queue index.</returns>
        </member>
        <member name="P:BepuUtilities.Collections.QuickQueue`1.Item(System.Int32)">
            <summary>
            Gets an element at the given index in the queue.
            0 gets the element at the FirstIndex. Count-1 would get the element at LastIndex.
            </summary>
            <param name="index">Index to grab an element from.</param>
            <returns>Element at the given index in the queue.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.#ctor(BepuUtilities.Memory.Buffer{`0}@)">
            <summary>
            Creates a new queue.
            </summary>
            <param name="initialSpan">Span to use as backing memory to begin with.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.#ctor(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Creates a new queue.
            </summary>
            <param name="pool">Pool to pull a span from.</param>
            <param name="minimumInitialCount">The minimum size of the region to be pulled from the pool. Actual span may be larger.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.Resize(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{`0}@)">
            <summary>
            Swaps out the queue's backing memory span for a new span.
            If the new span is smaller, the queue's count is truncated and the extra elements are dropped. 
            The old span is not cleared or returned to any pool; if it needs to be pooled or cleared, the user must handle it.
            </summary>
            <param name="newSpan">New span to use.</param>
            <param name="oldSpan">Previous span used for elements.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.Resize(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Resizes the queue's backing array for the given size.
            Any elements that do not fit in the resized span are dropped and the count is truncated.
            </summary>
            <param name="newSize">Minimum number of elements required in the new backing array. Actual capacity of the created span may exceed this size.</param>
            <param name="pool">Pool to pull a new span from and return the old span to.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.Dispose(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Returns the resources associated with the queue to pools. Any managed references still contained within the queue are cleared (and some unmanaged resources may also be cleared).
            </summary>
            <param name="pool">Pool used for element spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.EnsureCapacity(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Ensures that the queue has enough room to hold the specified number of elements.
            </summary>
            <param name="count">Number of elements to hold.</param>
            <param name="pool">Pool to pull a new span from and return the old span to.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.Compact(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Compacts the internal buffer to the minimum size required for the number of elements in the queue.
            </summary>
            <param name="pool">Pool to pull from if necessary.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.EnqueueUnsafely(`0@)">
            <summary>
            Enqueues the element to the end of the queue, incrementing the last index.
            </summary>
            <param name="element">Item to enqueue.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.EnqueueFirstUnsafely(`0@)">
            <summary>
            Enqueues the element to the start of the queue, decrementing the first index.
            </summary>
            <param name="element">Item to enqueue.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.Enqueue(`0@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Enqueues the element to the end of the queue, incrementing the last index.
            </summary>
            <param name="element">Item to enqueue.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.EnqueueFirst(`0@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Enqueues the element to the start of the queue, decrementing the first index.
            </summary>
            <param name="element">Item to enqueue.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.Dequeue">
            <summary>
            Dequeues an element from the start of the queue, incrementing the first index.
            </summary>
            <returns>Element removed from the queue.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.DequeueLast">
            <summary>
            Dequeues an element from the end of the queue, decrementing the last index.
            </summary>
            <returns>Element removed from the queue.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.TryDequeue(`0@)">
            <summary>
            Attempts to dequeue an element from the start of the queue, incrementing the first index.
            </summary>
            <param name="element">Element removed from the queue, if any.</param>
            <returns>True if an element was available to remove, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.TryDequeueLast(`0@)">
            <summary>
            Attempts to dequeue an element from the end of the queue, decrementing the last index.
            </summary>
            <param name="element">Element removed from the queue, if any.</param>
            <returns>True if an element was available to remove, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the given index, preserving the order of the queue.
            </summary>
            <param name="queueIndex">Index in the queue to remove. The index is in terms of the conceptual queue, not the backing array.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.Clear">
            <summary>
            Clears the queue by setting the count to zero and explicitly setting all relevant indices in the backing array to default values.
            </summary>
        </member>
        <member name="M:BepuUtilities.Collections.QuickQueue`1.FastClear">
            <summary>
            Clears the queue without changing any of the values in the backing array. Be careful about using this if the queue contains reference types.
            </summary>
        </member>
        <member name="T:BepuUtilities.Collections.QuickSet`2">
            <summary>
            Container supporting constant time adds and removes while preserving fast iteration times.
            Offers very direct access to information at the cost of safety.
            </summary>
            <remarks>
            <para>
            Be very careful when using this type. It has sacrificed a lot upon the altar of performance; a few notable issues include:
            it is a value type and copying it around will break things without extreme care,
            it cannot be validly default-constructed,
            it exposes internal structures to user modification, 
            it rarely checks input for errors,
            the enumerator doesn't check for mid-enumeration modification,
            it allows unsafe addition that can break if the user doesn't manage the capacity,
            it works on top of an abstracted memory blob which might internally be a pointer that could be rugpulled, 
            it does not (and is incapable of) checking that provided memory gets returned to the same pool that it came from.
            </para>
            <para>Note that the implementation is extremely simple. It uses single-step linear probing under the assumption of very low collision rates.
            A generous table capacity is recommended; this trades some memory for simplicity and runtime performance.</para></remarks>
            <typeparam name="T">Type of element held by the container.</typeparam>
            <typeparam name="TEqualityComparer">Type of the equality tester and hash calculator used.</typeparam>
        </member>
        <member name="F:BepuUtilities.Collections.QuickSet`2.Count">
            <summary>
            Gets the number of elements in the set.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickSet`2.TableMask">
            <summary>
            Mask for use in performing fast modulo operations for hashes. Requires that the table span is a power of 2.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickSet`2.TablePowerOffset">
            <summary>
            Desired size of the table relative to the size of the key/value spans in terms of a power of 2. Table capacity target will be elementCapacityTarget * 2^TablePowerOffset.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickSet`2.Table">
            <summary>
            Backing memory of the set's table. Values are distributed according to the EqualityComparer's hash function.
            Slots containing 0 are unused and point to nothing. Slots containing higher values are equal to one plus the index of an element in the Span.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickSet`2.Span">
            <summary>
            Backing memory containing the elements of the set.
            Indices from 0 to Count-1 hold actual data. All other data is undefined.
            </summary>
        </member>
        <member name="F:BepuUtilities.Collections.QuickSet`2.EqualityComparer">
            <summary>
            Equality comparer used to compare and hash elements.
            </summary>
        </member>
        <member name="P:BepuUtilities.Collections.QuickSet`2.Item(System.Int32)">
            <summary>
            Gets or sets an element at the given index in the list representation of the set.
            </summary>
            <param name="index">Index to grab an element from.</param>
            <returns>Element at the given index in the set.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.#ctor(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{System.Int32}@,`1,System.Int32)">
            <summary>
            Creates a new set.
            </summary>
            <param name="initialSpan">Span to use as backing memory of the set elements.</param>
            <param name="initialTableSpan">Span to use as backing memory of the table. Must be zeroed out.</param>
            <param name="comparer">Comparer to use for the set.</param>
            <param name="tablePowerOffset">Target size of the table relative to the number of stored elements.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.#ctor(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{System.Int32}@,System.Int32)">
            <summary>
            Creates a new set using a default constructed equality comparer.
            </summary>
            <param name="initialSpan">Span to use as backing memory of the set elements.</param>
            <param name="initialTableSpan">Span to use as backing memory of the table. Must be zeroed.</param>
            <param name="tablePowerOffset">Target size of the table relative to the number of stored elements.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.#ctor(System.Int32,System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool,`1)">
            <summary>
            Creates a new set.
            </summary>
            <param name="pool">Pool to pull spans from.</param>   
            <param name="initialCapacity">Initial target size of the key and value spans. The size of the initial buffer will be at least as large as the initialCapacity.</param>
            <param name="tableSizePower">Target capacity relative to the initial capacity in terms of a power of 2. The size of the initial table buffer will be at least 2^tableSizePower times larger than the initial capacity.</param>
            <param name="comparer">Comparer to use in the set.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.#ctor(System.Int32,System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Creates a new set with a default constructed comparer.
            </summary>
            <param name="pool">Pool to pull spans from.</param>   
            <param name="initialCapacity">Initial target size of the key and value spans. The size of the initial buffer will be at least as large as the initialCapacity.</param>
            <param name="tableSizePower">Target capacity relative to the initial capacity in terms of a power of 2. The size of the initial table buffer will be at least 2^tableSizePower times larger than the initial capacity.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.#ctor(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Creates a new set with a default constructed comparer.
            </summary>
            <param name="pool">Pool to pull spans from.</param>   
            <param name="initialCapacity">Initial target size of the key and value spans. The size of the initial buffer will be at least as large as the initialCapacity.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Resize(BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{System.Int32}@,BepuUtilities.Memory.Buffer{`0}@,BepuUtilities.Memory.Buffer{System.Int32}@)">
            <summary>
            Swaps out the set's backing memory span for a new span.
            If the new span is smaller, the set's count is truncated and the extra elements are dropped. 
            The old span is not cleared or returned to any pool; if it needs to be pooled or cleared, the user must handle it.
            </summary>      
            <param name="newSpan">New span to use for elements.</param>
            <param name="newTableSpan">New span to use for the table. Must be zeroed.</param>
            <param name="oldSpan">Previous span used for elements.</param>
            <param name="oldTableSpan">Previous span used for the table.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Resize(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Resizes the set's backing array for the given size.
            If the new span is smaller, the set's count is truncated and the extra elements are dropped. 
            </summary>
            <param name="newSize">Minimum size of the new object memory block. Actual size may be larger.</param>
            <param name="pool">Pool to take spans from.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Dispose(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Returns the resources associated with the set to pools. Any managed references still contained within the set are cleared (and some unmanaged resources may also be cleared).
            </summary>
            <param name="pool">Pool used for element spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.EnsureCapacity(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Ensures that the set has enough room to hold the specified number of elements.
            </summary>     
            <param name="pool">Pool used for spans.</param>   
            <param name="count">Number of elements to hold.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Compact(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Shrinks the internal buffers to the smallest acceptable size and releases the old buffers to the pools.
            </summary>
            <param name="element">Element to add.</param>
            <param name="pool">Pool used for spans.</param>   
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.GetTableIndices(`0@,System.Int32@,System.Int32@)">
            <summary>
            Gets the index of the element in the table.
            </summary>
            <param name="element">Element to look up.</param>
            <param name="tableIndex">Index of the element in the redirect table, or if it is not present, the index of where it would be added.</param>
            <param name="elementIndex">The index of the element in the elements array, if it exists; -1 otherwise.</param>
            <returns>True if the element is present in the set, false if it is not.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.IndexOf(`0)">
            <summary>
            Gets the index of the element in the set if it exists.
            </summary>
            <param name="element">Element to get the index of.</param>
            <returns>The index of the element if the element exists in the set, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.IndexOf(`0@)">
            <summary>
            Gets the index of the element in the set if it exists.
            </summary>
            <param name="element">Element to get the index of.</param>
            <returns>The index of the element if the element exists in the set, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Contains(`0)">
            <summary>
            Checks if a given element already belongs to the set.
            </summary>
            <param name="element">Element to test for.</param>
            <returns>True if the element already belongs to the set, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Contains(`0@)">
            <summary>
            Checks if a given element already belongs to the set.
            </summary>
            <param name="element">Element to test for.</param>
            <returns>True if the element already belongs to the set, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.AddAndReplaceUnsafely(`0@)">
            <summary>
            Adds an element to the set. If a version of the element (same hash code, 'equal' by comparer) is already present,
            it is replaced by the given version.
            Does not resize in the event that the capacity is exceeded.
            </summary>
            <param name="element">Element to add.</param>
            <returns>True if the element was added to the set, false if the element was already present and was instead replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.AddAndReplaceUnsafely(`0)">
            <summary>
            Adds an element to the set. If a version of the element (same hash code, 'equal' by comparer) is already present,
            it is replaced by the given version.
            Does not resize in the event that the capacity is exceeded.
            </summary>
            <param name="element">Element to add.</param>
            <returns>True if the element was added to the set, false if the element was already present and was instead replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.AddUnsafely(`0@)">
            <summary>
            Adds an element to the set if it is not already present.
            Does not resize in the event that the capacity is exceeded.
            </summary>
            <param name="element">Element to add.</param>
            <returns>True if the element was added to the set, false if the element was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.AddUnsafely(`0)">
            <summary>
            Adds an element to the set if it is not already present.
            Does not resize in the event that the capacity is exceeded.
            </summary>
            <param name="element">Element to add.</param>
            <returns>True if the element was added to the set, false if the element was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.AddAndReplace(`0@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds an element to the set. If a version of the element (same hash code, 'equal' by comparer) is already present,
            it is replaced by the given version.
            </summary>
            <param name="element">Element to add.</param>
            <param name="pool">Pool used for spans.</param>   
            <returns>True if the element was added to the set, false if the element was already present and was instead replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Add(`0@,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds an element to the set if it is not already present.
            </summary>
            <param name="element">Element to add.</param>
            <param name="pool">Pool used for spans.</param>   
            <returns>True if the element was added to the set, false if the element was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.AddAndReplace(`0,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds an element to the set. If a version of the element (same hash code, 'equal' by comparer) is already present,
            it is replaced by the given version.
            </summary>
            <param name="element">Element to add.</param>
            <param name="pool">Pool used for spans.</param>   
            <returns>True if the element was added to the set, false if the element was already present and was instead replaced.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Add(`0,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Adds an element to the set if it is not already present.
            </summary>
            <param name="element">Element to add.</param>
            <param name="pool">Pool used for spans.</param>   
            <returns>True if the element was added to the set, false if the element was already present.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.FastRemove(System.Int32,System.Int32)">
            <summary>
            Removes an element from the dictionary according to its table and element index. Can only be used if the table and element index are valid.
            </summary>
            <param name="tableIndex">Index of the table entry associated with the existing element to remove.</param>
            <param name="elementIndex">Index of the existing element to remove in the contiguous element array.</param>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.FastRemove(`0@)">
            <summary>
            Removes an element from the set if belongs to the set.
            Does not preserve the order of elements in the set.
            </summary>
            <param name="element">Element to remove.</param>
            <returns>True if the element was found and removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.FastRemove(`0)">
            <summary>
            Removes an element from the set if belongs to the set.
            Does not preserve the order of elements in the set.
            </summary>
            <param name="element">Element to remove.</param>
            <returns>True if the element was found and removed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.Clear">
            <summary>
            Removes all elements from the set.
            </summary>
        </member>
        <member name="M:BepuUtilities.Collections.QuickSet`2.FastClear">
            <summary>
            Removes all elements from the set without modifying the contents of the elements array.
            </summary>
        </member>
        <member name="T:BepuUtilities.Collections.ReferenceComparer`1">
            <summary>
            Provides equality comparison and hashing for referenced types.
            </summary>
            <typeparam name="T">Type to compare for equality and hash.</typeparam>
        </member>
        <member name="T:BepuUtilities.Collections.WrapperEqualityComparer`1">
            <summary>
            IEqualityComparerRef wrapper around an EqualityComparer.
            </summary>
            <typeparam name="T">Type of the objects to compare and hash.</typeparam>
        </member>
        <member name="M:BepuUtilities.Collections.WrapperEqualityComparer`1.CreateDefault(BepuUtilities.Collections.WrapperEqualityComparer{`0}@)">
            <summary>
            Creates a default comparer for the given type.
            </summary>
            <param name="predicate">Predicate to test against other items using the default comparer for this type.</param>
        </member>
        <member name="T:BepuUtilities.Collections.WrapperPredicate`1">
            <summary>
            IPredicate wrapper around an EqualityComparer and an object to compare against.
            </summary>
            <typeparam name="T">Type of the objects to compare.</typeparam>
        </member>
        <member name="M:BepuUtilities.Collections.WrapperPredicate`1.CreateDefault(`0@,BepuUtilities.Collections.WrapperPredicate{`0}@)">
            <summary>
            Creates a default comparer for the given type.
            </summary>
            <param name="item">Item to compare against other items.</param>
            <param name="predicate">Predicate to test against other items using the default comparer for this type.</param>
        </member>
        <member name="T:BepuUtilities.ContainmentType">
            <summary>
            The current containment state of two objects.
            </summary>
        </member>
        <member name="F:BepuUtilities.ContainmentType.Disjoint">
            <summary>
            The objects are separate.
            </summary>
        </member>
        <member name="F:BepuUtilities.ContainmentType.Contains">
            <summary>
            One object fully contains the other.
            </summary>
        </member>
        <member name="F:BepuUtilities.ContainmentType.Intersects">
            <summary>
            The objects are intersecting, but neither object fully contains the other.
            </summary>
        </member>
        <member name="M:BepuUtilities.GatherScatter.Get``1(System.Numerics.Vector{``0}@,System.Int32)">
            <summary>
            Gets a reference to an element from a vector without using pointers, bypassing direct vector access for codegen reasons. This performs no bounds testing!
            </summary>
        </member>
        <member name="M:BepuUtilities.GatherScatter.CopyLane``1(``0@,System.Int32,``0@,System.Int32)">
            <summary>
            Copies from one bundle lane to another. The bundle must be a contiguous block of Vector types.
            </summary>
            <typeparam name="T">Type of the copied bundles.</typeparam>
            <param name="sourceBundle">Source bundle of the data to copy.</param>
            <param name="sourceInnerIndex">Index of the lane within the source bundle.</param>
            <param name="targetBundle">Target bundle of the data to copy.</param>
            <param name="targetInnerIndex">Index of the lane within the target bundle.</param>
            <remarks>
            For performance critical operations, a specialized implementation should be used. This uses a loop with stride equal to a Vector that isn't yet unrolled.
            </remarks>
        </member>
        <member name="M:BepuUtilities.GatherScatter.ClearLane``2(``0@,System.Int32)">
            <summary>
            Clears a bundle lane using the default value of the specified type. The bundle must be a contiguous block of Vector types, all sharing the same type,
            and the first vector must start at the address pointed to by the bundle reference.
            </summary>
            <typeparam name="TOuter">Type containing one or more Vectors.</typeparam>
            <typeparam name="TVector">Type of the vectors to clear.</typeparam>
            <param name="bundle">Target bundle to clear a lane in.</param>
            <param name="innerIndex">Index of the lane within the target bundle to clear.</param>
            <remarks>
            For performance critical operations, a specialized implementation should be used. This uses a loop with stride equal to a Vector.
            </remarks>
        </member>
        <member name="M:BepuUtilities.GatherScatter.GetOffsetInstance``1(``0@,System.Int32)">
            <summary>
            Gets a reference to a shifted bundle container such that the first slot of each bundle covers the given inner index of the original bundle reference.
            </summary>
            <typeparam name="T">Type of the bundle container.</typeparam>
            <param name="bundleContainer">Bundle container whose reference acts as the base for the shifted reference.</param>
            <param name="innerIndex">Index within the bundle to access with the shifted reference.</param>
            <returns>Shifted bundle container reference covering the inner index of the original bundle reference.</returns>
        </member>
        <member name="M:BepuUtilities.GatherScatter.GetFirst``1(System.Numerics.Vector{``0}@)">
            <summary>
            Gets a reference to the first element in the vector reference.
            </summary>
            <typeparam name="T">Type of value held by the vector.</typeparam>
            <param name="vector">Vector to pull the first slot value from.</param>
            <returns>Reference to the value in the given vector's first slot.</returns>
        </member>
        <member name="T:BepuUtilities.IForEachRef`1">
            <summary>
            Defines a loop body function able to handle the equivalent of a foreach's body. Takes a ref parameter for efficiency when dealing with large value types.
            </summary>
            <typeparam name="T">Type to enumerate over.</typeparam>
        </member>
        <member name="T:BepuUtilities.IForEach`1">
            <summary>
            Defines a loop body function able to handle the equivalent of a foreach's body.
            </summary>
            <typeparam name="T">Type to enumerate over.</typeparam>
        </member>
        <member name="T:BepuUtilities.IBreakableForEach`1">
            <summary>
            Defines a loop body function able to handle the equivalent of a foreach's body that supports breaking the loop early.
            </summary>
            <typeparam name="T">Type to enumerate over.</typeparam>
        </member>
        <member name="M:BepuUtilities.IBreakableForEach`1.LoopBody(`0)">
            <summary>
            Executes one execution of the loop body.
            </summary>
            <param name="i">Visited element.</param>
            <returns>True if the loop should continue, false otherwise.</returns>
        </member>
        <member name="T:BepuUtilities.IBreakableForEachRef`1">
            <summary>
            Defines a loop body function able to handle the equivalent of a foreach's body that supports breaking the loop early.
            Takes a ref parameter for efficiency when dealing with large value types.
            </summary>
            <typeparam name="T">Type to enumerate over.</typeparam>
        </member>
        <member name="M:BepuUtilities.IBreakableForEachRef`1.LoopBody(`0@)">
            <summary>
            Executes one execution of the loop body.
            </summary>
            <param name="i">Visited element.</param>
            <returns>True if the loop should continue, false otherwise.</returns>
        </member>
        <member name="T:BepuUtilities.Int2">
            <summary>
            Provides simple 2d cell hashing.
            </summary>
        </member>
        <member name="T:BepuUtilities.Int3">
            <summary>
            A set of 3 integers, useful for spatial hashing.
            </summary>
        </member>
        <member name="T:BepuUtilities.IThreadDispatcher">
            <summary>
            Provides multithreading dispatch primitives, a thread count, and per thread resource pools for the simulation to use.
            </summary>
            <remarks>
            <para>Note that the simulation does not require a true load balancing forloop implementation. All that's needed is a way to jumpstart some threads.
            All systems which use multithreading tend to have some form of domain specific load balancing that a general purpose thread pool or parallel for loop implementation 
            couldn't match. The simulation also tends to keep the number of dispatches as low as it can. Combined, these two things reduce the importance of a
            very highly optimized dispatcher.</para>
            <para>This is important when a user wants to share some other thread pool, but doesn't have the time to guarantee extremely high performance and high quality
            load balancing. Instead of worrying about that, they can just wrap whatever implementation they happen to have and it'll probably work fine.</para>
            </remarks>
        </member>
        <member name="P:BepuUtilities.IThreadDispatcher.ThreadCount">
            <summary>
            Gets the number of workers available in the thread dispatcher.
            </summary>
            <remarks>Note that some systems (like the solver) expect the ThreadCount to be backed by truly independent threads capable of progression even when one is blocked.
            If the ThreadCount doesn't represent independent threads, deadlocks will occur.
            </remarks>
        </member>
        <member name="M:BepuUtilities.IThreadDispatcher.DispatchWorkers(System.Action{System.Int32},System.Int32)">
            <summary>
            Dispatches all the available workers.
            </summary>
            <param name="workerBody">Delegate to be invoked on every worker.</param>
            <param name="maximumWorkerCount">Maximum number of workers to dispatch.</param>
        </member>
        <member name="M:BepuUtilities.IThreadDispatcher.GetThreadMemoryPool(System.Int32)">
            <summary>
            Gets the memory pool associated with a given worker index. It is guaranteed that no other workers will share the same pool for the duration of the worker's execution.
            </summary>
            <remarks>All usages of the memory pool within the simulation are guaranteed to return thread pool memory before the function returns. In other words,
            thread memory pools are used for strictly ephemeral memory, and it will never be held by the simulation outside the scope of a function that 
            takes the IThreadDispatcher as input.</remarks>
            <param name="workerIndex">Index of the worker to grab the pool for.</param>
            <returns>The memory pool for the specified worker index.</returns>
        </member>
        <member name="T:BepuUtilities.MathChecker">
            <summary>
            Contains conditional extensions to check for bad values in various structures.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.IsInvalid(System.Single)">
            <summary>
            Checks a single float for validity.
            </summary>
            <param name="f">Value to validate.</param>
            <returns>True if the value is invalid, false if it is valid.</returns>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(System.Single)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(System.Numerics.Vector2)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(System.Numerics.Vector3)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(System.Numerics.Vector4)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(BepuUtilities.Matrix3x3)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(BepuUtilities.Matrix)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(System.Numerics.Quaternion)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.ValidateOrientation(System.Numerics.Quaternion)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(BepuUtilities.Symmetric3x3)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(BepuUtilities.AffineTransform)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(BepuUtilities.BoundingBox)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathChecker.Validate(BepuUtilities.BoundingSphere)">
            <summary>
            Checks the value to see if it is a NaN or infinite.  If it is, a debug assertion will fail.
            This is only run when the CHECKMATH symbol is defined.
            </summary>
        </member>
        <member name="T:BepuUtilities.MathHelper">
            <summary>
            Contains helper math methods.
            </summary>
        </member>
        <member name="F:BepuUtilities.MathHelper.Pi">
            <summary>
            Approximate value of Pi.
            </summary>
        </member>
        <member name="F:BepuUtilities.MathHelper.TwoPi">
            <summary>
            Approximate value of Pi multiplied by two.
            </summary>
        </member>
        <member name="F:BepuUtilities.MathHelper.PiOver2">
            <summary>
            Approximate value of Pi divided by two.
            </summary>
        </member>
        <member name="F:BepuUtilities.MathHelper.PiOver4">
            <summary>
            Approximate value of Pi divided by four.
            </summary>
        </member>
        <member name="M:BepuUtilities.MathHelper.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamps a value between a minimum and maximum value.
            </summary>
            <param name="value">Value to clamp.</param>
            <param name="min">Minimum value.  If the value is less than this, the minimum is returned instead.</param>
            <param name="max">Maximum value.  If the value is more than this, the maximum is returned instead.</param>
            <returns>Clamped value.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Max(System.Single,System.Single)">
            <summary>
            Returns the higher value of the two parameters.
            </summary>
            <param name="a">First value.</param>
            <param name="b">Second value.</param>
            <returns>Higher value of the two parameters.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Min(System.Single,System.Single)">
            <summary>
            Returns the lower value of the two parameters.
            </summary>
            <param name="a">First value.</param>
            <param name="b">Second value.</param>
            <returns>Lower value of the two parameters.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps a value between a minimum and maximum value.
            </summary>
            <param name="value">Value to clamp.</param>
            <param name="min">Minimum value.  If the value is less than this, the minimum is returned instead.</param>
            <param name="max">Maximum value.  If the value is more than this, the maximum is returned instead.</param>
            <returns>Clamped value.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Max(System.Int32,System.Int32)">
            <summary>
            Returns the higher value of the two parameters.
            </summary>
            <param name="a">First value.</param>
            <param name="b">Second value.</param>
            <returns>Higher value of the two parameters.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Min(System.Int32,System.Int32)">
            <summary>
            Returns the lower value of the two parameters.
            </summary>
            <param name="a">First value.</param>
            <param name="b">Second value.</param>
            <returns>Lower value of the two parameters.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Clamp(System.Int64,System.Int64,System.Int64)">
            <summary>
            Clamps a value between a minimum and maximum value.
            </summary>
            <param name="value">Value to clamp.</param>
            <param name="min">Minimum value.  If the value is less than this, the minimum is returned instead.</param>
            <param name="max">Maximum value.  If the value is more than this, the maximum is returned instead.</param>
            <returns>Clamped value.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Max(System.Int64,System.Int64)">
            <summary>
            Returns the higher value of the two parameters.
            </summary>
            <param name="a">First value.</param>
            <param name="b">Second value.</param>
            <returns>Higher value of the two parameters.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Min(System.Int64,System.Int64)">
            <summary>
            Returns the lower value of the two parameters.
            </summary>
            <param name="a">First value.</param>
            <param name="b">Second value.</param>
            <returns>Lower value of the two parameters.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.ToRadians(System.Single)">
            <summary>
            Converts degrees to radians.
            </summary>
            <param name="degrees">Degrees to convert.</param>
            <returns>Radians equivalent to the input degrees.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.ToDegrees(System.Single)">
            <summary>
            Converts radians to degrees.
            </summary>
            <param name="radians">Radians to convert.</param>
            <returns>Degrees equivalent to the input radians.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.BinarySign(System.Single)">
            <summary>
            Returns -1 if the value is negative and 1 otherwise.
            </summary>
            <param name="x">Value to compute the sign of.</param>
            <returns>-1 if the input is negative, and 1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Cos(System.Single)">
            <summary>
            Computes an approximation of cosine. Maximum error a little below 8e-7 for the interval -2 * Pi to 2 * Pi. Values further from the interval near zero have gracefully degrading error.
            </summary>
            <param name="x">Value to take the cosine of.</param>
            <returns>Approximate cosine of the input value.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Sin(System.Single)">
            <summary>
            Computes an approximation of sine. Maximum error a little below 5e-7 for the interval -2 * Pi to 2 * Pi. Values further from the interval near zero have gracefully degrading error.
            </summary>
            <param name="x">Value to take the sine of.</param>
            <returns>Approximate sine of the input value.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Acos(System.Single)">
            <summary>
            Computes an approximation of arccos. Inputs outside of [-1, 1] are clamped. Maximum error less than 5.17e-07.
            </summary>
            <param name="x">Input value to the arccos function.</param>
            <returns>Result of the arccos function.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Cos(System.Numerics.Vector{System.Single})">
            <summary>
            Computes an approximation of cosine. Maximum error a little below 8e-7 for the interval -2 * Pi to 2 * Pi. Values further from the interval near zero have gracefully degrading error.
            </summary>
            <param name="x">Values to take the cosine of.</param>
            <returns>Approximate cosine of the input values.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Sin(System.Numerics.Vector{System.Single})">
            <summary>
            Computes an approximation of sine. Maximum error a little below 5e-7 for the interval -2 * Pi to 2 * Pi. Values further from the interval near zero have gracefully degrading error.
            </summary>
            <param name="x">Value to take the sine of.</param>
            <returns>Approximate sine of the input value.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.Acos(System.Numerics.Vector{System.Single})">
            <summary>
            Computes an approximation of arccos. Inputs outside of [-1, 1] are clamped. Maximum error less than 5.17e-07.
            </summary>
            <param name="x">Input value to the arccos function.</param>
            <returns>Result of the arccos function.</returns>
        </member>
        <member name="M:BepuUtilities.MathHelper.GetSignedAngleDifference(System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Gets the change in angle from a to b as a signed value from -pi to pi.
            </summary>
            <param name="a">Source angle.</param>
            <param name="b">Target angle.</param>
            <param name="difference">Difference between a and b, expressed as a value from -pi to pi.</param>
        </member>
        <member name="T:BepuUtilities.Matrix">
            <summary>
            Provides SIMD-aware 4x4 matrix math.
            </summary>
            <remarks>
            All functions assume row vectors.
            </remarks>
        </member>
        <member name="F:BepuUtilities.Matrix.X">
            <summary>
            Row 1 of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Matrix.Y">
            <summary>
            Row 2 of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Matrix.Z">
            <summary>
            Row 3 of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Matrix.W">
            <summary>
            Row 4 of the matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Matrix.TransformTranspose(System.Numerics.Vector4@,BepuUtilities.Matrix@,System.Numerics.Vector4@)">
            <summary>
            Transforms a vector with a transposed matrix.
            </summary>
            <param name="v">Row vector to transform.</param>
            <param name="m">Matrix whose transpose will be applied to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.Transform(System.Numerics.Vector4@,BepuUtilities.Matrix@,System.Numerics.Vector4@)">
            <summary>
            Transforms a vector with a matrix.
            </summary>
            <param name="v">Row vector to transform.</param>
            <param name="m">Matrix to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.Transform(System.Numerics.Vector3@,BepuUtilities.Matrix@,System.Numerics.Vector4@)">
            <summary>
            Transforms a vector with a matrix. Implicitly uses 1 as the fourth component of the input vector.
            </summary>
            <param name="v">Row vector to transform.</param>
            <param name="m">Matrix to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.Multiply(BepuUtilities.Matrix@,BepuUtilities.Matrix@,BepuUtilities.Matrix@)">
            <summary>
            Multiplies a matrix by another matrix.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <param name="result">Result of the matrix multiplication.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.op_Multiply(BepuUtilities.Matrix@,BepuUtilities.Matrix@)">
            <summary>
            Concatenates two matrices.
            </summary>
            <param name="m1">First input matrix.</param>
            <param name="m2">Second input matrix.</param>
            <returns>Concatenated transformation of the form m1 * m2.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix.CreatePerspectiveFieldOfView(System.Single,System.Single,System.Single,System.Single,BepuUtilities.Matrix@)">
            <summary>
            Creates a right-handed perspective matrix.
            </summary>
            <param name="fieldOfView">Vertical field of view of the perspective in radians.</param>
            <param name="aspectRatio">Width of the viewport over the height of the viewport.</param>
            <param name="nearClip">Near clip plane of the perspective.</param>
            <param name="farClip">Far clip plane of the perspective.</param>
            <param name="perspective">Resulting perspective matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreatePerspectiveFieldOfViewLH(System.Single,System.Single,System.Single,System.Single,BepuUtilities.Matrix@)">
            <summary>
            Creates a left-handed perspective matrix.
            </summary>
            <param name="fieldOfView">Vertical field of view of the perspective in radians.</param>
            <param name="aspectRatio">Width of the viewport over the height of the viewport.</param>
            <param name="nearClip">Near clip plane of the perspective.</param>
            <param name="farClip">Far clip plane of the perspective.</param>
            <param name="perspective">Resulting perspective matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreatePerspectiveFromFieldOfViews(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a right-handed perspective matrix.
            </summary>
            <param name="verticalFieldOfView">Vertical field of view of the perspective in radians.</param>
            <param name="horizontalFieldOfView">Horizontal field of view of the perspective in radians.</param>
            <param name="nearClip">Near clip plane of the perspective.</param>
            <param name="farClip">Far clip plane of the perspective.</param>
            <returns>Resulting perspective matrix.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix.CreatePerspectiveFromFieldOfViews(System.Single,System.Single,System.Single,System.Single,BepuUtilities.Matrix@)">
            <summary>
            Creates a right-handed perspective matrix.
            </summary>
            <param name="verticalFieldOfView">Vertical field of view of the perspective in radians.</param>
            <param name="horizontalFieldOfView">Horizontal field of view of the perspective in radians.</param>
            <param name="nearClip">Near clip plane of the perspective.</param>
            <param name="farClip">Far clip plane of the perspective.</param>
            <param name="perspective">Resulting perspective matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreatePerspectiveFieldOfView(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a right-handed perspective matrix.
            </summary>
            <param name="fieldOfView">Vertical field of view of the perspective in radians.</param>
            <param name="aspectRatio">Width of the viewport over the height of the viewport.</param>
            <param name="nearClip">Near clip plane of the perspective.</param>
            <param name="farClip">Far clip plane of the perspective.</param>
            <returns>Resulting perspective matrix.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateOrthographic(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,BepuUtilities.Matrix@)">
            <summary>
            Creates a right handed orthographic projection.
            </summary>
            <param name="left">Leftmost coordinate of the projected area.</param>
            <param name="right">Rightmost coordinate of the projected area.</param>
            <param name="bottom">Bottom coordinate of the projected area.</param>
            <param name="top">Top coordinate of the projected area.</param>
            <param name="zNear">Near plane of the projection.</param>
            <param name="zFar">Far plane of the projection.</param>
            <param name="projection">The resulting orthographic projection matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.Invert(BepuUtilities.Matrix@,BepuUtilities.Matrix@)">
            <summary>
            Inverts the matrix.
            </summary>
            <param name="m">Matrix to invert.</param>
            <param name="inverted">Inverted version of the matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.Invert(BepuUtilities.Matrix@)">
            <summary>
            Inverts the matrix.
            </summary>
            <param name="m">Matrix to invert.</param>
            <returns>Inverted version of the matrix.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateLookAt(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,BepuUtilities.Matrix@)">
            <summary>
            Creates a view matrix pointing from a position to a target with the given up vector.
            </summary>
            <param name="position">Position of the camera.</param>
            <param name="target">Target of the camera.</param>
            <param name="upVector">Up vector of the camera.</param>
            <param name="viewMatrix">Look at matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateLookAt(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Creates a view matrix pointing from a position to a target with the given up vector.
            </summary>
            <param name="position">Position of the camera.</param>
            <param name="target">Target of the camera.</param>
            <param name="upVector">Up vector of the camera.</param>
            <returns>Look at matrix.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateView(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@,BepuUtilities.Matrix@)">
            <summary>
            Creates a view matrix pointing in a direction with a given up vector.
            </summary>
            <param name="position">Position of the camera.</param>
            <param name="forward">Forward direction of the camera.</param>
            <param name="upVector">Up vector of the camera.</param>
            <param name="viewMatrix">Look at matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateView(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>
            Creates a view matrix pointing looking in a direction with a given up vector.
            </summary>
            <param name="position">Position of the camera.</param>
            <param name="forward">Forward direction of the camera.</param>
            <param name="upVector">Up vector of the camera.</param>
            <returns>Look at matrix.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateRigid(BepuUtilities.Matrix3x3@,System.Numerics.Vector3@,BepuUtilities.Matrix@)">
            <summary>
            Creates a rigid world matrix from a rotation and position.
            </summary>
            <param name="rotation">Rotation of the transform.</param>
            <param name="position">Position of the transform.</param>
            <param name="world">4x4 matrix representing the combined transform.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateRigid(System.Numerics.Quaternion@,System.Numerics.Vector3@,BepuUtilities.Matrix@)">
            <summary>
            Creates a rigid world matrix from a rotation and position.
            </summary>
            <param name="rotation">Rotation of the transform.</param>
            <param name="position">Position of the transform.</param>
            <param name="world">4x4 matrix representing the combined transform.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateFrom3x3(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix@)">
            <summary>
            Creates a 4x4 matrix from a 3x3 matrix. All extra columns and rows filled with 0 except the W.W, which is set to 1.
            </summary>
            <param name="matrix3x3">Smaller matrix to base the larger matrix on.</param>
            <param name="matrix4x4">Larger matrix that has the smaller matrix as a submatrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix.CreateFrom3x3(BepuUtilities.Matrix3x3@)">
            <summary>
            Creates a 4x4 matrix from a 3x3 matrix. All extra columns and rows filled with 0 except the W.W, which is set to 1.
            </summary>
            <param name="matrix3x3">Smaller matrix to base the larger matrix on.</param>
            <returns>Larger matrix that has the smaller matrix as a submatrix.</returns>
        </member>
        <member name="F:BepuUtilities.Matrix2x2Wide.X">
            <summary>
            First row of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Matrix2x2Wide.Y">
            <summary>
            Second row of the matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Matrix2x2Wide.MultiplyByTransposeWithoutOverlap(BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x2Wide@)">
            <summary>
            Multiplies a matrix by another matrix, where the second matrix is sampled as if it were transposed: result = a * transpose(b).
            </summary>
            <param name="a">First matrix in the pair.</param>
            <param name="b">Matrix to be sampled as if it were transposed when multiplied with the first matrix.</param>
            <param name="result">Result of the multiplication a * transpose(b).</param>
        </member>
        <member name="M:BepuUtilities.Matrix2x2Wide.Scale(BepuUtilities.Matrix2x2Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Matrix2x2Wide@)">
            <summary>
            Multiplies every component in the matrix by the given scalar value.
            </summary>
            <param name="m">Matrix to scale.</param>
            <param name="scale">Scaling value to apply to the matrix's components.</param>
            <param name="result">Resulting matrix with scaled components.</param>
        </member>
        <member name="M:BepuUtilities.Matrix2x2Wide.Add(BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x2Wide@)">
            <summary>
            Adds the components of one matrix to another.
            </summary>
            <param name="a">First matrix to add.</param>
            <param name="b">Second matrix to add.</param>
            <param name="result">Sum of the two given matrices.</param>
        </member>
        <member name="M:BepuUtilities.Matrix2x2Wide.Subtract(BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x2Wide@)">
            <summary>
            Subtracts the components of one matrix from another.
            </summary>
            <param name="a">Matrix to be subtracted from..</param>
            <param name="b">Matrix to subtract from the other.</param>
            <param name="result">Result of the subtraction.</param>
        </member>
        <member name="M:BepuUtilities.Matrix2x2Wide.InvertWithoutOverlap(BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x2Wide@)">
            <summary>
            Inverts the given matix.
            </summary>
            <param name="matrix">Matrix to be inverted.</param>
            <param name="result">Inverted matrix.</param>
        </member>
        <member name="F:BepuUtilities.Matrix2x3Wide.X">
            <summary>
            First row of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Matrix2x3Wide.Y">
            <summary>
            Second row of the matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Matrix2x3Wide.MultiplyTransposedWithoutOverlap(BepuUtilities.Matrix2x2Wide@,BepuUtilities.Matrix2x3Wide@,BepuUtilities.Matrix2x3Wide@)">
            <summary>
            Multiplies a matrix by another matrix, where the first matrix is sampled as if it were transposed: result = transpose(a) * b.
            </summary>
            <param name="a">Matrix to be sampled as if it were transposed when multiplied with the second matrix.</param>
            <param name="b">Second matrix in the pair.</param>
            <param name="result">Result of the multiplication transpose(a) * b.</param>
        </member>
        <member name="M:BepuUtilities.Matrix2x3Wide.MultiplyByTransposeWithoutOverlap(BepuUtilities.Matrix2x3Wide@,BepuUtilities.Matrix2x3Wide@,BepuUtilities.Matrix2x2Wide@)">
            <summary>
            Multiplies a matrix by another matrix, where the second matrix is sampled as if it were transposed: result = a * transpose(b).
            </summary>
            <param name="a">First matrix in the pair.</param>
            <param name="b">Matrix to be sampled as if it were transposed when multiplied with the first matrix.</param>
            <param name="result">Result of the multiplication a * transpose(b).</param>
        </member>
        <member name="M:BepuUtilities.Matrix2x3Wide.Scale(BepuUtilities.Matrix2x3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Matrix2x3Wide@)">
            <summary>
            Multiplies every component in the matrix by the given scalar value.
            </summary>
            <param name="m">Matrix to scale.</param>
            <param name="scale">Scaling value to apply to the matrix's components.</param>
            <param name="result">Resulting matrix with scaled components.</param>
        </member>
        <member name="T:BepuUtilities.Matrix3x3">
            <summary>
            3 row, 3 column matrix.
            </summary>
        </member>
        <member name="P:BepuUtilities.Matrix3x3.Identity">
            <summary>
            Gets the 3x3 identity matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Add(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Adds the components of two matrices together.
            </summary>
            <param name="a">First matrix to add.</param>
            <param name="b">Second matrix to add.</param>
            <param name="result">Sum of the two input matrices.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Scale(BepuUtilities.Matrix3x3,System.Single,BepuUtilities.Matrix3x3@)">
            <summary>
            Scales the components of a matrix by a scalar.
            </summary>
            <param name="matrix">Matrix to scale.</param>
            <param name="scale">Scale to apply to the matrix's components.</param>
            <param name="result">Scaled matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Subtract(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Subtracts the components of one matrix from another.
            </summary>
            <param name="a">Matrix to be subtracted from.</param>
            <param name="b">Matrix to subtract from a.</param>
            <param name="result">Difference of the two input matrices.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Transpose(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@)">
            <summary>                                                                                                
            Computes the transposed matrix of a matrix.                                                              
            </summary>                                                                                               
            <param name="m">Matrix to transpose.</param>                                                             
            <param name="transposed">Transposed matrix.</param>                                                      
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Determinant">
            <summary>
            Calculates the determinant of the matrix.
            </summary>
            <returns>The matrix's determinant.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Invert(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Inverts the given matix.
            </summary>
            <param name="m">Matrix to be inverted.</param>
            <param name="inverse">Inverted matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Invert(BepuUtilities.Matrix3x3*,BepuUtilities.Matrix3x3*)">
            <summary>
            Inverts the given matix.
            </summary>
            <param name="m">Matrix to be inverted.</param>
            <param name="inverse">Inverted matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Transform(System.Numerics.Vector3@,BepuUtilities.Matrix3x3@,System.Numerics.Vector3@)">
            <summary>
            Transforms the vector by the matrix.
            </summary>
            <param name="v">Vector3 to transform.</param>
            <param name="m">Matrix to use as the transformation.</param>
            <param name="result">Product of the transformation.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.TransformTranspose(System.Numerics.Vector3@,BepuUtilities.Matrix3x3@,System.Numerics.Vector3@)">
            <summary>
            Transforms the vector by the matrix's transpose.
            </summary>
            <param name="v">Vector3 to transform.</param>
            <param name="m">Matrix to use as the transformation transpose.</param>
            <param name="result">Product of the transformation.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.Multiply(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Multiplies the two matrices.
            </summary>
            <param name="a">First matrix to multiply.</param>
            <param name="b">Second matrix to multiply.</param>
            <param name="result">Product of the multiplication.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.MultiplyTransposed(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Multiplies the two matrices, where a is treated as transposed: result = transpose(a) * b
            </summary>
            <param name="a">First matrix to multiply that will be transposed.</param>
            <param name="b">Second matrix to multiply.</param>
            <param name="result">Product of the multiplication.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.CreateScale(System.Numerics.Vector3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Creates a 3x3 matrix representing the given scale along its local axes.
            </summary>
            <param name="scale">Scale to represent.</param>
            <param name="linearTransform">Matrix representing a scale.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.CreateFromAxisAngle(System.Numerics.Vector3@,System.Single,BepuUtilities.Matrix3x3@)">
            <summary>
            Creates a matrix representing a rotation derived from an axis and angle.
            </summary>
            <param name="axis">Axis of the rotation.</param>
            <param name="angle">Angle of the rotation.</param>
            <param name="result">Resulting rotation matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.CreateFromAxisAngle(System.Numerics.Vector3@,System.Single)">
            <summary>
            Creates a matrix representing a rotation derived from an axis and angle.
            </summary>
            <param name="axis">Axis of the rotation.</param>
            <param name="angle">Angle of the rotation.</param>
            <returns>Resulting rotation matrix.</returns>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.CreateCrossProduct(System.Numerics.Vector3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Creates a matrix such that a x v = a * result.
            </summary>
            <param name="v">Vector to build the skew symmetric matrix from.</param>
            <param name="result">Skew symmetric matrix representing the cross product.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3.op_Multiply(BepuUtilities.Matrix3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Concatenates two matrices.
            </summary>
            <param name="m1">First input matrix.</param>
            <param name="m2">Second input matrix.</param>
            <returns>Concatenated transformation of the form m1 * m2.</returns>
        </member>
        <member name="F:BepuUtilities.Matrix3x3Wide.X">
            <summary>
            First row of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Matrix3x3Wide.Y">
            <summary>
            Second row of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Matrix3x3Wide.Z">
            <summary>
            Third row of the matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Matrix3x3Wide.MultiplyTransposedWithoutOverlap(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Multiplies a matrix by another matrix, where the first matrix is sampled as if it were transposed: result = transpose(a) * b.
            </summary>
            <param name="a">Matrix to be sampled as if it were transposed when multiplied with the second matrix.</param>
            <param name="b">Second matrix in the pair.</param>
            <param name="result">Result of the multiplication transpose(a) * b.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3Wide.MultiplyByTransposeWithoutOverlap(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Multiplies a matrix by another matrix, where the second matrix is sampled as if it were transposed: result = a * transpose(b).
            </summary>
            <param name="a">First matrix in the pair.</param>
            <param name="b">Matrix to be sampled as if it were transposed when multiplied with the first matrix.</param>
            <param name="result">Result of the multiplication a * transpose(b).</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3Wide.Negate(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Negates the components of a matrix.
            </summary>
            <param name="m">Matrix to negate.</param>
            <param name="result">Negated result matrix.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3Wide.Scale(BepuUtilities.Matrix3x3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Multiplies every component in the matrix by the given scalar value.
            </summary>
            <param name="m">Matrix to scale.</param>
            <param name="scale">Scaling value to apply to the matrix's components.</param>
            <param name="result">Resulting matrix with scaled components.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3Wide.ReadFirst(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="source">Source of the lane.</param>
            <param name="target">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="M:BepuUtilities.Matrix3x3Wide.ReadSlot(BepuUtilities.Matrix3x3Wide@,System.Int32,BepuUtilities.Matrix3x3@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="wide">Source of the lane.</param>
            <param name="slotIndex">Index of the lane within the wide representation to read.</param>
            <param name="narrow">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="T:BepuUtilities.Memory.Allocator">
            <summary>
            Represents a chunk of abstract memory supporting allocations and deallocations.
            Never moves any memory.
            </summary>
            <remarks>Uses an extremely simple ring buffer that makes no attempt to skip groups of allocations. Not particularly efficient.</remarks>
        </member>
        <member name="P:BepuUtilities.Memory.Allocator.Capacity">
            <summary>
            Gets or sets the capacity of the allocator.
            </summary>
        </member>
        <member name="F:BepuUtilities.Memory.Allocator.searchStartIndex">
            <summary>
            Index in allocations that we should start at during the next allocation attempt.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.#ctor(System.Int64,BepuUtilities.Memory.BufferPool,System.Int32)">
            <summary>
            Creates a new allocator.
            </summary>
            <param name="capacity">Size of the memory handled by the allocator in elements.</param>
            <param name="initialAllocationCapacity">Estimated number of allocations to allocate room for in the internal structures.</param>
            <param name="pool">Pool to pull internal resources from.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.Contains(System.UInt64)">
            <summary>
            Checks if the id is currently allocated.
            </summary>
            <param name="id">Id to check for.</param>
            <returns>True if the id is present in the allocations set, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.TryGetAllocationRegion(System.UInt64,BepuUtilities.Memory.Allocator.Allocation@)">
            <summary>
            Gets the allocation region associated with the given allocation id if it is present.
            </summary>
            <param name="allocationId">Allocation id to look up the allocation for.</param>
            <param name="allocation">Allocation associated with the id, if present.</param>
            <returns>True if the allocationId was present in the allocator, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.CanFit``1(System.Int64,``0@)">
            <summary>
            Checks if a block of memory can fit into the current state of the allocator.
            </summary>
            <param name="size">Size of the memory to test.</param>
            <param name="ignoredIds">Ids of allocations to treat as nonexistent for the purposes of the test.</param>
            <returns>True if the size could fit, false if out of memory or if memory was too fragmented to find a spot.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.CanFit(System.Int64)">
            <summary>
            Checks if a block of memory can fit into the current state of the allocator.
            </summary>
            <param name="size">Size of the memory to test.</param>
            <returns>True if the size could fit, false if out of memory or if memory was too fragmented to find a spot.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.Allocate(System.UInt64,System.Int64,System.Int64@)">
            <summary>
            Attempts to allocate a range of memory.
            </summary>
            <param name="id">Unique id of the memory to allocate.</param>
            <param name="size">Size of the memory to allocate.</param>
            <param name="outputStart">Starting index of the allocated memory, if successful.</param>
            <returns>True if the allocation succeeded, false if out of memory or if memory was too fragmented to find a spot.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.Deallocate(System.UInt64)">
            <summary>
            Removes the memory associated with the id from the pool.
            </summary>
            <param name="id">Id to remove.</param>
            <returns>True of the id was found, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.GetLargestContiguousSize(System.Int64@,System.Int64@)">
            <summary>
            Gets the size of the largest contiguous area and the total free space in the allocator.
            Not very efficient; runs in linear time for the number of allocations.
            </summary>
            <param name="largestContiguous">Largest contiguous region in the allocator. The allocator can hold an allocation up to this size.</param>
            <param name="totalFreeSpace">Total free space in the allocator.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.IncrementalCompact(System.UInt64@,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Finds the first allocation with empty space before it and pulls it forward to close the gap. Assumes the ability to perform synchronous reallocation.
            </summary>
            <param name="id">Id of the allocation to be moved, if any.</param>
            <param name="size">Size of the moved allocation.</param>
            <param name="oldStart">Old starting location of the allocation.</param>
            <param name="newStart">New starting location of the allocation.</param>
            <returns>True if a compaction was performed, false otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Allocator.Resize(System.UInt64,System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Attempts to resize a given allocation to a new size. If the new size is smaller, the start index remains unchanged.
            </summary>
            <param name="id">Id of the allocation to resize.</param>
            <param name="size">New desired size of the allocation.</param>
            <param name="oldStart">Old start location of the allocation.</param>
            <param name="newStart">New start location of the allocation.</param>
            <returns>True if the resize was successful. False if there was insufficient room for the larger allocation.</returns>
        </member>
        <member name="T:BepuUtilities.Memory.Buffer`1">
            <summary>
            Span over an unmanaged memory region.
            </summary>
            <typeparam name="T">Type of the memory exposed by the span.</typeparam>
        </member>
        <member name="F:BepuUtilities.Memory.Buffer`1.Id">
            <summary>
            Implementation specific identifier of the raw buffer set by its source. If taken from a BufferPool, Id represents the index in the power pool from which it was taken.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.Buffer`1.Item(System.Int32)">
            <summary>
            Gets a reference to the element at the given index.
            </summary>
            <param name="index">Index of the element to grab a reference of.</param>
            <returns>Reference to the element at the given index.</returns>
        </member>
        <member name="P:BepuUtilities.Memory.Buffer`1.Item(System.UInt32)">
            <summary>
            Gets a reference to the element at the given index.
            </summary>
            <param name="index">Index of the element to grab a reference of.</param>
            <returns>Reference to the element at the given index.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.GetPointer(System.Int32)">
            <summary>
            Gets a pointer to the element at the given index.
            </summary>
            <param name="index">Index of the element to retrieve a pointer for.</param>
            <returns>Pointer to the element at the given index.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.GetPointer(System.UInt32)">
            <summary>
            Gets a pointer to the element at the given index.
            </summary>
            <param name="index">Index of the element to retrieve a pointer for.</param>
            <returns>Pointer to the element at the given index.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.Slice(System.Int32,System.Int32)">
            <summary>
            Creates a view of a subset of the buffer's memory.
            </summary>
            <param name="start">Index at which to start the sliced buffer.</param>
            <param name="count">Number of elements to include in the sliced buffer.</param>
            <returns>Buffer spanning the specified subset of the original buffer.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.Slice(System.Int32)">
            <summary>
            Creates a view of a subset of the buffer's memory, starting from the first index.
            </summary>
            <param name="count">Number of elements to include in the sliced buffer.</param>
            <returns>Buffer spanning the specified subset of the original buffer.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.Slice(System.Int32,System.Int32,BepuUtilities.Memory.Buffer{`0}@)">
            <summary>
            Creates a view of a subset of the buffer's memory.
            </summary>
            <param name="start">Index at which to start the sliced buffer.</param>
            <param name="count">Number of elements to include in the sliced buffer.</param>
            <param name="sliced">Buffer spanning the specified subset of the original buffer.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.Slice(System.Int32,BepuUtilities.Memory.Buffer{`0}@)">
            <summary>
            Creates a view of a subset of the buffer's memory, starting from the first index.
            </summary>
            <param name="count">Number of elements to include in the sliced buffer.</param>
            <param name="sliced">Buffer spanning the specified subset of the original buffer.</param>
        </member>
        <member name="P:BepuUtilities.Memory.Buffer`1.Length">
            <summary>
            Gets the length of the buffer in typed elements.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.Buffer`1.Allocated">
            <summary>
            Gets whether the buffer references non-null memory.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.Clear(System.Int32,System.Int32)">
            <summary>
            Zeroes out the buffer's memory.
            </summary>
            <param name="start">Start location in the buffer.</param>
            <param name="count">Number of elements to clear beyond the start index.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.CopyTo(System.Int32,BepuUtilities.Memory.Buffer{`0}@,System.Int32,System.Int32)">
            <summary>
            Copies buffer data into another buffer.
            </summary>
            <param name="sourceStart">Start index in the source buffer.</param>
            <param name="target">Target buffer to copy into.</param>
            <param name="targetStart">Start index in the target buffer.</param>
            <param name="count">Number of elements to copy from the source buffer into the target buffer.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.CopyTo(System.Int32,System.Span{`0},System.Int32,System.Int32)">
            <summary>
            Copies buffer data into another buffer.
            </summary>
            <param name="sourceStart">Start index in the source buffer.</param>
            <param name="target">Target buffer to copy into.</param>
            <param name="targetStart">Start index in the target buffer.</param>
            <param name="count">Number of elements to copy from the source buffer into the target buffer.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.CopyFrom(System.Span{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies span data into this buffer.
            </summary>
            <param name="source">Source span to copy from.</param>
            <param name="sourceStart">Start index in the source buffer.</param>
            <param name="targetStart">Start index in the target buffer.</param>
            <param name="count">Number of elements to copy from the source buffer into the target buffer.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.CopyFrom(System.ReadOnlySpan{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies span data into this buffer.
            </summary>
            <param name="source">Source span to copy from.</param>
            <param name="sourceStart">Start index in the source buffer.</param>
            <param name="targetStart">Start index in the target buffer.</param>
            <param name="count">Number of elements to copy from the source buffer into the target buffer.</param>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.IndexOf(`0@,System.Int32,System.Int32)">
            <summary>
            Gets the index of an element in the buffer using the type's default comparer.
            </summary>
            <param name="element">Element to look for in the buffer.</param>
            <param name="start">Start index at which to begin the search.</param>
            <param name="count">Number of elements to scan beyond the start index.</param>
            <returns>Index of the element in the buffer if found, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Gets the index of an element in the buffer using the type's default comparer.
            </summary>
            <param name="element">Element to look for in the buffer.</param>
            <param name="start">Start index at which to begin the search.</param>
            <param name="count">Number of elements to scan beyond the start index.</param>
            <returns>Index of the element in the buffer if found, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.IndexOf``1(``0@,System.Int32,System.Int32)">
            <summary>
            Gets the index of the first element that matches a provided predicate.
            </summary>
            <param name="predicate">Predicate to test each element with.</param>
            <param name="start">Start index at which to begin the search.</param>
            <param name="count">Number of elements to scan beyond the start index.</param>
            <returns>Index of the first matching element in the buffer if any, -1 otherwise.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Buffer`1.As``1">
            <summary>
            Creates a typed region from the raw buffer with the largest capacity that can fit within the allocated bytes.
            </summary>
            <typeparam name="TCast">Type of the buffer.</typeparam>
            <returns>Typed buffer of maximum extent within the current buffer.</returns>
        </member>
        <member name="T:BepuUtilities.Memory.BufferPool">
            <summary>
            Unmanaged memory pool that creates pinned blocks of memory for use in spans.
            </summary>
            <remarks>This currently works by allocating large managed arrays and pinning them under the assumption that they'll end up in the large object heap.</remarks>
        </member>
        <member name="F:BepuUtilities.Memory.BufferPool.PowerPool.Slots">
            <summary>
            Pool of slots available to this power level.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new buffer pool.
            </summary>
            <param name="minimumBlockAllocationSize">Minimum size of individual block allocations. Must be a power of 2.
            Pools with single allocations larger than the minimum will use the minimum value necessary to hold one element.
            Buffers will be suballocated from blocks.</param>
            <param name="expectedPooledResourceCount">Number of suballocations to preallocate reference space for.
            This does not preallocate actual blocks, just the space to hold references that are waiting in the pool.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.EnsureCapacityForPower(System.Int32,System.Int32)">
            <summary>
            Ensures that the pool associated with a given power has at least a certain amount of capacity, measured in bytes.
            </summary>
            <param name="byteCount">Minimum number of bytes to require for the power pool.</param>
            <param name="power">Power associated with the pool to check.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.GetCapacityForPower(System.Int32)">
            <summary>
            Gets the capacity allocated for a power.
            </summary>
            <param name="power">Power to check.</param>
            <returns>Allocated capacity for the given power.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.TakeAtLeast``1(System.Int32,BepuUtilities.Memory.Buffer{``0}@)">
            <summary>
            Takes a buffer large enough to contain a number of elements of a given type. Capacity may be larger than requested.
            </summary>
            <typeparam name="T">Type of the elements in the buffer.</typeparam>
            <param name="count">Desired minimum capacity of the buffer in typed elements.</param>
            <param name="buffer">Buffer large enough to contain the requested number of elements.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.Take``1(System.Int32,BepuUtilities.Memory.Buffer{``0}@)">
            <summary>
            Takes a typed buffer of the requested size from the pool.
            </summary>
            <typeparam name="T">Type of the instances in the buffer.</typeparam>
            <param name="count">Desired capacity of the buffer in typed elements.</param>
            <param name="buffer">Typed buffer of the requested size.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.TakeForPower(System.Int32,BepuUtilities.Memory.Buffer{System.Byte}@)">
            <summary>
            Takes a buffer large enough to contain a number of bytes given by a power, where the number of bytes is 2^power.
            </summary>
            <param name="power">Number of bytes that should fit within the buffer as an exponent, where the number of bytes is 2^power.</param>
            <param name="buffer">Buffer that can hold the bytes.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.ReturnUnsafely(System.Int32)">
            <summary>
            Returns a buffer to the pool by id.
            </summary>
            <param name="id">Id of the buffer to return to the pool.</param>
            <remarks>Typed buffer pools zero out the passed-in buffer by convention.
            This costs very little and avoids a wide variety of bugs (either directly or by forcing fast failure). For consistency, BufferPool.Return does the same thing.
            This "Unsafe" overload should be used only in cases where there's a reason to bypass the clear; the naming is intended to dissuade casual use.</remarks>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.Return``1(BepuUtilities.Memory.Buffer{``0}@)">
            <summary>
            Returns a buffer to the pool.
            </summary>
            <param name="buffer">Buffer to return to the pool.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.ResizeToAtLeast``1(BepuUtilities.Memory.Buffer{``0}@,System.Int32,System.Int32)">
            <summary>
            Resizes a typed buffer to the smallest size available in the pool which contains the target size. Copies a subset of elements into the new buffer. 
            Final buffer size is at least as large as the target size and may be larger.
            </summary>
            <typeparam name="T">Type of the buffer to resize.</typeparam>
            <param name="buffer">Buffer reference to resize.</param>
            <param name="targetSize">Number of elements to resize the buffer for.</param>
            <param name="copyCount">Number of elements to copy into the new buffer from the old buffer.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.Resize``1(BepuUtilities.Memory.Buffer{``0}@,System.Int32,System.Int32)">
            <summary>
            Resizes a buffer to the target size. Copies a subset of elements into the new buffer.
            </summary>
            <typeparam name="T">Type of the buffer to resize.</typeparam>
            <param name="buffer">Buffer reference to resize.</param>
            <param name="targetSize">Number of elements to resize the buffer for.</param>
            <param name="copyCount">Number of elements to copy into the new buffer from the old buffer.</param>
        </member>
        <member name="M:BepuUtilities.Memory.BufferPool.Clear">
            <summary>
            Unpins and drops reference to all memory. Any outstanding buffers will be invalidated silently.
            </summary>
        </member>
        <member name="T:BepuUtilities.Memory.IdPool">
            <summary>
            Manages a pool of identifier values. Grabbing an id from the pool picks a number that has been picked and returned before, 
            or if none of those are available, the minimum value greater than any existing id.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.IdPool.HighestPossiblyClaimedId">
            <summary>
            Gets the highest value which any index claimed thus far could possibly have.
            This is not necessarily the current highest claimed index; this value may represent an earlier claim that has already been released.
            -1 if nothing has ever been claimed.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.IdPool.AvailableIdCount">
            <summary>
            Gets the number of previously returned ids waiting in the pool.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.IdPool.Allocated">
            <summary>
            Gets whether the id pool has backing resources allocated to it and is ready to use.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.IdPool.ReturnUnsafely(System.Int32)">
            <summary>
            Returns an id to the pool without checking if a resize is required on the available id stack.
            </summary>
            <param name="id">Id to return.</param>
        </member>
        <member name="M:BepuUtilities.Memory.IdPool.Clear">
            <summary>
            Resets the IdPool.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.IdPool.EnsureCapacity(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Ensures that the underlying id queue can hold at least a certain number of ids.
            </summary>
            <param name="count">Number of elements to preallocate space for in the available ids queue.</param>
            <param name="pool">Pool to pull resized spans from.</param>
        </member>
        <member name="M:BepuUtilities.Memory.IdPool.Compact(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Shrinks the available ids queue to the smallest size that can fit the given count and the current available id count.
            </summary>
            <param name="minimumCount">Number of elements to guarantee space for in the available ids queue.</param>
        </member>
        <member name="M:BepuUtilities.Memory.IdPool.Resize(System.Int32,BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Resizes the underlying buffer to the smallest size required to hold the given count and the current available id count.
            </summary>
            <param name="count">Number of elements to guarantee space for in the available ids queue.</param>
        </member>
        <member name="M:BepuUtilities.Memory.IdPool.Dispose(BepuUtilities.Memory.IUnmanagedMemoryPool)">
            <summary>
            Returns underlying memory to the pool.
            </summary>
            <remarks>The IdPool can be reused only if EnsureCapacity or Resize is called.</remarks>
        </member>
        <member name="T:BepuUtilities.Memory.IUnmanagedMemoryPool">
            <summary>
            Defines a type that is capable of rapidly serving requests for allocation and deallocation of unmanaged memory.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.IUnmanagedMemoryPool.TakeAtLeast``1(System.Int32,BepuUtilities.Memory.Buffer{``0}@)">
            <summary>
            Takes a buffer large enough to contain a number of elements of a given type. Capacity may be larger than requested.
            </summary>
            <typeparam name="T">Type of the elements in the buffer.</typeparam>
            <param name="count">Desired minimum capacity of the buffer in typed elements.</param>
            <param name="buffer">Buffer large enough to contain the requested number of elements.</param>
        </member>
        <member name="M:BepuUtilities.Memory.IUnmanagedMemoryPool.Take``1(System.Int32,BepuUtilities.Memory.Buffer{``0}@)">
            <summary>
            Takes a typed buffer of the requested size from the pool.
            </summary>
            <typeparam name="T">Type of the instances in the buffer.</typeparam>
            <param name="count">Desired capacity of the buffer in typed elements.</param>
            <param name="buffer">Typed buffer of the requested size.</param>
        </member>
        <member name="M:BepuUtilities.Memory.IUnmanagedMemoryPool.Return``1(BepuUtilities.Memory.Buffer{``0}@)">
            <summary>
            Returns a buffer to the pool.
            </summary>
            <typeparam name="T">Type of the buffer's elements.</typeparam>
            <param name="buffer">Buffer to return to the pool.</param>
        </member>
        <member name="M:BepuUtilities.Memory.IUnmanagedMemoryPool.GetCapacityForCount``1(System.Int32)">
            <summary>
            Gets the capacity of a buffer that would be returned by the pool if a given element count was requested from TakeAtLeast.
            </summary>
            <typeparam name="T">Type of the elements being requested.</typeparam>
            <param name="count">Number of elements to request.</param>
            <returns>Capacity of a buffer that would be returned if the given element count was requested.</returns>
        </member>
        <member name="T:BepuUtilities.Memory.ManagedIdPool">
            <summary>
            Manages a pool of identifier values. Grabbing an id from the pool picks a number that has been picked and returned before, 
            or if none of those are available, the minimum value greater than any existing id.
            </summary>
            <remarks>This contrasts with the IdPool which operates on unmanaged memory. This version only exists to support use cases where the unmanaged version can't be used-
            for example, in the BufferPool. While the implementation can be shared, doing so involves creating enough supporting infrastructure that it's simpler to have a managed-only version.</remarks>
        </member>
        <member name="P:BepuUtilities.Memory.ManagedIdPool.HighestPossiblyClaimedId">
            <summary>
            Gets the highest value which any index claimed thus far could possibly have.
            This is not necessarily the current highest claimed index; this value may represent an earlier claim that has already been released.
            -1 if nothing has ever been claimed.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.ManagedIdPool.AvailableIdCount">
            <summary>
            Gets the number of previously returned ids waiting in the pool.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.ManagedIdPool.#ctor(System.Int32)">
            <summary>
            Gets the capacity of the id pool for returned ids.
            </summary>        
            public int Capacity => availableIds.Length;
        </member>
        <member name="M:BepuUtilities.Memory.ManagedIdPool.ReturnUnsafely(System.Int32)">
            <summary>
            Returns an id to the pool without checking if a resize is required on the available id stack.
            </summary>
            <param name="id">Id to return.</param>
        </member>
        <member name="M:BepuUtilities.Memory.ManagedIdPool.Clear">
            <summary>
            Resets the IdPool.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.ManagedIdPool.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the underlying id queue can hold at least a certain number of ids.
            </summary>
            <param name="count">Number of elements to preallocate space for in the available ids queue.</param>
        </member>
        <member name="M:BepuUtilities.Memory.ManagedIdPool.Compact(System.Int32)">
            <summary>
            Shrinks the available ids queue to the smallest size that can fit the given count and the current available id count.
            </summary>
            <param name="minimumCount">Number of elements to guarantee space for in the available ids queue.</param>
        </member>
        <member name="M:BepuUtilities.Memory.ManagedIdPool.Resize(System.Int32)">
            <summary>
            Resizes the underlying buffer to the smallest size required to hold the given count and the current available id count.
            </summary>
            <param name="count">Number of elements to guarantee space for in the available ids queue.</param>
        </member>
        <member name="T:BepuUtilities.Memory.Pool`1">
            <summary>
            Manages a cache of a type of resource.
            </summary>
            <typeparam name="T">Type of object to pool.</typeparam>
        </member>
        <member name="P:BepuUtilities.Memory.Pool`1.PooledElementCount">
            <summary>
            Gets the number of existing elements in the pool. This number of elements can be requested without creating any new ones.
            </summary>
            <remarks> 
            Does not do any locking. Should not be used while elements may still be getting added to or removed from the pool.
            </remarks>
        </member>
        <member name="P:BepuUtilities.Memory.Pool`1.Creator">
            <summary>
            Gets or sets the function used to create new objects when the pool has no existing objects available.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.Pool`1.Initializer">
            <summary>
            Gets or sets the function used to initialize objects taken from the pool. Runs even if the object was just created by the Creator delegate.
            </summary>
        </member>
        <member name="P:BepuUtilities.Memory.Pool`1.Cleaner">
            <summary>
            Gets or sets the action applied to an element when it is returned to the pool.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.Pool`1.Clear">
            <summary>
            Clears all elements from the pool.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.Pool`1.Take">
            <summary>
            Takes an element from the pool. If the pool is empty, a new resource is created and returned.
            </summary>
            <returns>Element from the pool.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.Pool`1.Return(`0)">
            <summary>
            Returns the specified item to the pool. If a cleaner delegate is set, the item is cleaned.
            </summary>
            <param name="item">Item to give back to the pool.</param>
        </member>
        <member name="F:BepuUtilities.Memory.SpanHelper.MaximumSpanSizePower">
            <summary>
            The highest size span exponent. The largest span is 2^MaximumSpanSizePower. This avoids overflow.
            </summary>
        </member>
        <member name="M:BepuUtilities.Memory.SpanHelper.GetContainingPowerOf2(System.Int32)">
            <summary>
            Computes the lowest integer N such that 2^N >= i.
            </summary>
            <param name="i">Integer to compute the power of.</param>
            <returns>Lowest integer N such that 2^N >= i.</returns>
        </member>
        <member name="M:BepuUtilities.Memory.SpanHelper.IsPrimitive``1">
            <summary>
            Tests if a generic parameter is primitive. Fast path; specialized compilation.
            </summary>
            <typeparam name="T">Type to check for primitiveness.</typeparam>
            <returns>True if the type is one of the primitive types, false otherwise.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:BepuUtilities.Memory.SpanHelper.IsPrimitive(System.Type)" -->
        <member name="M:BepuUtilities.Memory.SpanHelper.Copy``1(BepuUtilities.Memory.Buffer{``0}@,System.Int32,BepuUtilities.Memory.Buffer{``0}@,System.Int32,System.Int32)">
            <summary>
            Copies data from one buffer to another.
            </summary>
            <typeparam name="T">Type of element being copied.</typeparam>
            <param name="source">Source buffer to pull elements from.</param>
            <param name="sourceIndex">Index in the buffer to start pulling elements from.</param>
            <param name="target">Target buffer to set values.</param>
            <param name="targetIndex">Index in the buffer to start putting elements into.</param>
            <param name="count">Number of elements to copy.</param>
        </member>
        <member name="M:BepuUtilities.Memory.SpanHelper.Copy``1(BepuUtilities.Memory.Buffer{``0}@,System.Int32,System.Span{``0},System.Int32,System.Int32)">
            <summary>
            Copies data from a buffer to a span.
            </summary>
            <typeparam name="T">Type of element being copied.</typeparam>
            <param name="source">Source buffer to pull elements from.</param>
            <param name="sourceIndex">Index in the buffer to start pulling elements from.</param>
            <param name="target">Target span to set values.</param>
            <param name="targetIndex">Index in the span to start putting elements into.</param>
            <param name="count">Number of elements to copy.</param>
        </member>
        <member name="M:BepuUtilities.Memory.SpanHelper.Copy``1(System.Span{``0}@,System.Int32,BepuUtilities.Memory.Buffer{``0}@,System.Int32,System.Int32)">
            <summary>
            Copies data from a span to a buffer.
            </summary>
            <typeparam name="T">Type of element being copied.</typeparam>
            <param name="source">Source span to pull elements from.</param>
            <param name="sourceIndex">Index in the span to start pulling elements from.</param>
            <param name="target">Target buffer to set values into.</param>
            <param name="targetIndex">Index in the buffer to start putting elements into.</param>
            <param name="count">Number of elements to copy.</param>
        </member>
        <member name="M:BepuUtilities.Memory.SpanHelper.Copy``1(System.ReadOnlySpan{``0}@,System.Int32,BepuUtilities.Memory.Buffer{``0}@,System.Int32,System.Int32)">
            <summary>
            Copies data from a span to a buffer.
            </summary>
            <typeparam name="T">Type of element being copied.</typeparam>
            <param name="source">Source span to pull elements from.</param>
            <param name="sourceIndex">Index in the span to start pulling elements from.</param>
            <param name="target">Target buffer to set values into.</param>
            <param name="targetIndex">Index in the buffer to start putting elements into.</param>
            <param name="count">Number of elements to copy.</param>
        </member>
        <member name="T:BepuUtilities.QuaternionEx">
            <summary>
            Provides additional functionality and some lower overhead function variants for Quaternions.
            </summary>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Add(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Adds two quaternions together.
            </summary>
            <param name="a">First quaternion to add.</param>
            <param name="b">Second quaternion to add.</param>
            <param name="result">Sum of the addition.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Scale(System.Numerics.Quaternion@,System.Single,System.Numerics.Quaternion@)">
            <summary>
            Scales a quaternion.
            </summary>
            <param name="q">Quaternion to multiply.</param>
            <param name="scale">Amount to multiply each component of the quaternion by.</param>
            <param name="result">Scaled quaternion.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.ConcatenateWithoutOverlap(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Concatenates the transforms of two quaternions together such that the resulting quaternion, applied as an orientation to a vector v, is equivalent to
            transformed = (v * a) * b.
            Assumes that neither input parameter overlaps the output parameter.
            </summary>
            <param name="a">First quaternion to concatenate.</param>
            <param name="b">Second quaternion to concatenate.</param>
            <param name="result">Product of the concatenation.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Concatenate(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Concatenates the transforms of two quaternions together such that the resulting quaternion, applied as an orientation to a vector v, is equivalent to
            transformed = (v * a) * b.
            </summary>
            <param name="a">First quaternion to concatenate.</param>
            <param name="b">Second quaternion to concatenate.</param>
            <param name="result">Product of the concatenation.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Concatenate(System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Concatenates the transforms of two quaternions together such that the resulting quaternion, applied as an orientation to a vector v, is equivalent to
            transformed = (v * a) * b.
            </summary>
            <param name="a">First quaternion to multiply.</param>
            <param name="b">Second quaternion to multiply.</param>
            <returns>Product of the multiplication.</returns>
        </member>
        <member name="P:BepuUtilities.QuaternionEx.Identity">
            <summary>
            Quaternion representing the identity transform.
            </summary>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromRotationMatrix(BepuUtilities.Matrix3x3@,System.Numerics.Quaternion@)">
            <summary>
            Constructs a quaternion from a rotation matrix.
            </summary>
            <param name="r">Rotation matrix to create the quaternion from.</param>
            <param name="q">Quaternion based on the rotation matrix.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromRotationMatrix(BepuUtilities.Matrix3x3@)">
            <summary>
            Creates a quaternion from a rotation matrix.
            </summary>
            <param name="r">Rotation matrix used to create a new quaternion.</param>
            <returns>Quaternion representing the same rotation as the matrix.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromRotationMatrix(BepuUtilities.Matrix@,System.Numerics.Quaternion@)">
            <summary>
            Constructs a quaternion from a rotation matrix.
            </summary>
            <param name="r">Rotation matrix to create the quaternion from.</param>
            <param name="q">Quaternion based on the rotation matrix.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromRotationMatrix(BepuUtilities.Matrix@)">
            <summary>
            Constructs a quaternion from a rotation matrix.
            </summary>
            <param name="r">Rotation matrix to create the quaternion from.</param>
            <returns>Quaternion based on the rotation matrix.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Normalize(System.Numerics.Quaternion@)">
            <summary>
            Ensures the quaternion has unit length.
            </summary>
            <param name="quaternion">Quaternion to normalize.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.LengthSquared(System.Numerics.Quaternion@)">
            <summary>
            Computes the squared length of the quaternion.
            </summary>
            <returns>Squared length of the quaternion.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Length(System.Numerics.Quaternion@)">
            <summary>
            Computes the length of the quaternion.
            </summary>
            <returns>Length of the quaternion.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Slerp(System.Numerics.Quaternion@,System.Numerics.Quaternion,System.Single,System.Numerics.Quaternion@)">
            <summary>
            Blends two quaternions together to get an intermediate state.
            </summary>
            <param name="start">Starting point of the interpolation.</param>
            <param name="end">Ending point of the interpolation.</param>
            <param name="interpolationAmount">Amount of the end point to use.</param>
            <param name="result">Interpolated intermediate quaternion.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Slerp(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Single)">
            <summary>
            Blends two quaternions together to get an intermediate state.
            </summary>
            <param name="start">Starting point of the interpolation.</param>
            <param name="end">Ending point of the interpolation.</param>
            <param name="interpolationAmount">Amount of the end point to use.</param>
            <returns>Interpolated intermediate quaternion.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Conjugate(System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Computes the conjugate of the quaternion.
            </summary>
            <param name="quaternion">Quaternion to conjugate.</param>
            <param name="result">Conjugated quaternion.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Conjugate(System.Numerics.Quaternion@)">
            <summary>
            Computes the conjugate of the quaternion.
            </summary>
            <param name="quaternion">Quaternion to conjugate.</param>
            <returns>Conjugated quaternion.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Inverse(System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Computes the inverse of the quaternion.
            </summary>
            <param name="quaternion">Quaternion to invert.</param>
            <param name="result">Result of the inversion.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Inverse(System.Numerics.Quaternion@)">
            <summary>
            Computes the inverse of the quaternion.
            </summary>
            <param name="quaternion">Quaternion to invert.</param>
            <returns>Result of the inversion.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Negate(System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Negates the components of a quaternion.
            </summary>
            <param name="a">Quaternion to negate.</param>
            <param name="b">Negated result.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Negate(System.Numerics.Quaternion@)">
            <summary>
            Negates the components of a quaternion.
            </summary>
            <param name="q">Quaternion to negate.</param>
            <returns>Negated result.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.TransformWithoutOverlap(System.Numerics.Vector3@,System.Numerics.Quaternion@,System.Numerics.Vector3@)">
            <summary>
            Transforms the vector using a quaternion, assuming that the output does not alias with the input.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="rotation">Rotation to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Transform(System.Numerics.Vector3@,System.Numerics.Quaternion@,System.Numerics.Vector3@)">
            <summary>
            Transforms the vector using a quaternion.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="rotation">Rotation to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.Transform(System.Numerics.Vector3@,System.Numerics.Quaternion@)">
            <summary>
            Transforms the vector using a quaternion.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="rotation">Rotation to apply to the vector.</param>
            <returns>Transformed vector.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.TransformUnitX(System.Numerics.Quaternion@,System.Numerics.Vector3@)">
            <summary>
            Transforms the unit X direction using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.TransformUnitY(System.Numerics.Quaternion@,System.Numerics.Vector3@)">
            <summary>
            Transforms the unit Y vector using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.TransformUnitZ(System.Numerics.Quaternion@,System.Numerics.Vector3@)">
            <summary>
            Transforms the unit Z vector using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromAxisAngle(System.Numerics.Vector3@,System.Single)">
            <summary>
            Creates a quaternion from an axis and angle.
            </summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle to rotate around the axis.</param>
            <returns>Quaternion representing the axis and angle rotation.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromAxisAngle(System.Numerics.Vector3@,System.Single,System.Numerics.Quaternion@)">
            <summary>
            Creates a quaternion from an axis and angle.
            </summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle to rotate around the axis.</param>
            <param name="q">Quaternion representing the axis and angle rotation.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Constructs a quaternion from yaw, pitch, and roll.
            </summary>
            <param name="yaw">Yaw of the rotation.</param>
            <param name="pitch">Pitch of the rotation.</param>
            <param name="roll">Roll of the rotation.</param>
            <returns>Quaternion representing the yaw, pitch, and roll.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.CreateFromYawPitchRoll(System.Single,System.Single,System.Single,System.Numerics.Quaternion@)">
            <summary>
            Constructs a quaternion from yaw, pitch, and roll.
            </summary>
            <param name="yaw">Yaw of the rotation.</param>
            <param name="pitch">Pitch of the rotation.</param>
            <param name="roll">Roll of the rotation.</param>
            <param name="q">Quaternion representing the yaw, pitch, and roll.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.GetAngleFromQuaternion(System.Numerics.Quaternion@)">
            <summary>
            Computes the angle change represented by a normalized quaternion.
            </summary>
            <param name="q">Quaternion to be converted.</param>
            <returns>Angle around the axis represented by the quaternion.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.GetAxisAngleFromQuaternion(System.Numerics.Quaternion@,System.Numerics.Vector3@,System.Single@)">
            <summary>
            Computes the axis angle representation of a normalized quaternion.
            </summary>
            <param name="q">Quaternion to be converted.</param>
            <param name="axis">Axis represented by the quaternion.</param>
            <param name="angle">Angle around the axis represented by the quaternion.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.GetQuaternionBetweenNormalizedVectors(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Quaternion@)">
            <summary>
            Computes the quaternion rotation between two normalized vectors.
            </summary>
            <param name="v1">First unit-length vector.</param>
            <param name="v2">Second unit-length vector.</param>
            <param name="q">Quaternion representing the rotation from v1 to v2.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.GetRelativeRotationWithoutOverlap(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Computes the rotation from the start orientation to the end orientation such that end = Quaternion.Concatenate(start, relative).
            Assumes that neither input parameter overlaps with the output parameter.
            </summary>
            <param name="start">Starting orientation.</param>
            <param name="end">Ending orientation.</param>
            <param name="relative">Relative rotation from the start to the end orientation.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionEx.GetLocalRotationWithoutOverlap(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Transforms the rotation into the local space of the target basis such that rotation = Quaternion.Concatenate(localRotation, targetBasis)
            Assumes that neither input parameter overlaps with the output parameter.
            </summary>
            <param name="rotation">Rotation in the original frame of reference.</param>
            <param name="targetBasis">Basis in the original frame of reference to transform the rotation into.</param>
            <param name="localRotation">Rotation in the local space of the target basis.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.Rebroadcast(BepuUtilities.QuaternionWide@,System.Int32,BepuUtilities.QuaternionWide@)">
            <summary>
            Takes a slot from the source quaternion and broadcasts it into all slots of the target quaternion.
            </summary>
            <param name="source">Quaternion to pull values from.</param>
            <param name="slotIndex">Slot in the source vectors to pull values from.</param>
            <param name="broadcasted">Target quaternion to be filled with the selected data.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.CreateFromRotationMatrix(BepuUtilities.Matrix3x3Wide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Constructs a quaternion from a rotation matrix.
            </summary>
            <param name="r">Rotation matrix to create the quaternion from.</param>
            <param name="q">Quaternion based on the rotation matrix.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.Add(BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Adds the components of two quaternions together.
            </summary>
            <param name="a">First quaternion to add.</param>
            <param name="b">Second quaternion to add.</param>
            <param name="result">Sum of the two input quaternions.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.GetQuaternionBetweenNormalizedVectors(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Computes the quaternion rotation between two normalized vectors.
            </summary>
            <param name="v1">First unit-length vector.</param>
            <param name="v2">Second unit-length vector.</param>
            <param name="q">Quaternion representing the rotation from v1 to v2.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.GetQuaternionBetweenNormalizedVectors(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Computes the quaternion rotation between two normalized vectors.
            </summary>
            <param name="v1">First unit-length vector.</param>
            <param name="v2">Second unit-length vector.</param>
            <returns>Quaternion representing the rotation from v1 to v2.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.GetAxisAngleFromQuaternion(BepuUtilities.QuaternionWide@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Gets an axis and angle representation of the rotation stored in a quaternion.
            </summary>
            <param name="q">Quaternion to extract an axis-angle representation from.</param>
            <param name="axis">Axis of rotation extracted from the quaternion.</param>
            <param name="angle">Angle of rotation extracted from the quaternion.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.TransformWithoutOverlap(BepuUtilities.Vector3Wide@,BepuUtilities.QuaternionWide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Transforms the vector using a quaternion. Assumes that the memory backing the input and output do not overlap.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="rotation">Rotation to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.Transform(BepuUtilities.Vector3Wide@,BepuUtilities.QuaternionWide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Transforms the vector using a quaternion.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="rotation">Rotation to apply to the vector.</param>
            <param name="result">Transformed vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.Transform(BepuUtilities.Vector3Wide,BepuUtilities.QuaternionWide)">
            <summary>
            Transforms the vector using a quaternion.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="rotation">Rotation to apply to the vector.</param>
            <returns>Transformed vector.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.TransformByConjugate(BepuUtilities.Vector3Wide,BepuUtilities.QuaternionWide)">
            <summary>
            Transforms the vector using a quaternion.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="rotation">Rotation to apply to the vector.</param>
            <returns>Transformed vector.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.TransformUnitX(BepuUtilities.QuaternionWide)">
            <summary>
            Transforms the unit X direction using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vector.</param>
            <returns>Transformed vector.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.TransformUnitY(BepuUtilities.QuaternionWide)">
            <summary>
            Transforms the unit Y vector using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vector.</param>
            <returns>Transformed vector.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.TransformUnitZ(BepuUtilities.QuaternionWide)">
            <summary>
            Transforms the unit Z vector using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vector.</param>
            <returns>Transformed vector.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.TransformUnitXY(BepuUtilities.QuaternionWide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Transforms the unit X and unit Y direction using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vectors.</param>
            <param name="x">Transformed unit X vector.</param>
            <param name="y">Transformed unit Y vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.TransformUnitXZ(BepuUtilities.QuaternionWide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Transforms the unit X and unit Z direction using a quaternion.
            </summary>
            <param name="rotation">Rotation to apply to the vectors.</param>
            <param name="x">Transformed unit X vector.</param>
            <param name="z">Transformed unit Z vector.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.ConcatenateWithoutOverlap(BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Concatenates the transforms of two quaternions together such that the resulting quaternion, applied as an orientation to a vector v, is equivalent to
            transformed = (v * a) * b. Assumes that the memory backing the input and output do not overlap.
            </summary>
            <param name="a">First quaternion to concatenate.</param>
            <param name="b">Second quaternion to concatenate.</param>
            <param name="result">Product of the concatenation.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.Concatenate(BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Concatenates the transforms of two quaternions together such that the resulting quaternion, applied as an orientation to a vector v, is equivalent to
            transformed = (v * a) * b.
            </summary>
            <param name="a">First quaternion to concatenate.</param>
            <param name="b">Second quaternion to concatenate.</param>
            <param name="result">Product of the concatenation.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.op_Multiply(BepuUtilities.QuaternionWide,BepuUtilities.QuaternionWide)">
            <summary>
            Concatenates the transforms of two quaternions together such that the resulting quaternion, applied as an orientation to a vector v, is equivalent to
            transformed = (v * a) * b.
            </summary>
            <param name="a">First quaternion to concatenate.</param>
            <param name="b">Second quaternion to concatenate.</param>
            <returns>Product of the concatenation.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.Conjugate(BepuUtilities.QuaternionWide@,BepuUtilities.QuaternionWide@)">
            <summary>
            Computes the conjugate of the quaternion.
            </summary>
            <param name="quaternion">Quaternion to conjugate.</param>
            <param name="result">Conjugated quaternion.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.Conjugate(BepuUtilities.QuaternionWide@)">
            <summary>
            Computes the conjugate of the quaternion.
            </summary>
            <param name="quaternion">Quaternion to conjugate.</param>
            <returns>Conjugated quaternion.</returns>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.ReadFirst(BepuUtilities.QuaternionWide@,System.Numerics.Quaternion@)">
            <summary>
            Gathers values from the first slot of a wide quaternion and puts them into a narrow representation.
            </summary>
            <param name="source">Wide quaternion to copy values from.</param>
            <param name="target">Narrow quaternion to place values into.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.WriteFirst(System.Numerics.Quaternion@,BepuUtilities.QuaternionWide@)">
            <summary>
            Gathers values from a quaternion and places them into the first indices of the target wide quaternion.
            </summary>
            <param name="source">Quaternion to copy values from.</param>
            <param name="targetSlot">Wide quaternion to place values into.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.WriteSlot(System.Numerics.Quaternion@,System.Int32,BepuUtilities.QuaternionWide@)">
            <summary>
            Writes a value into a slot of the target bundle.
            </summary>
            <param name="source">Source of the value to write.</param>
            <param name="slotIndex">Index of the slot to write into.</param>
            <param name="target">Bundle to write the value into.</param>
        </member>
        <member name="M:BepuUtilities.QuaternionWide.ReadSlot(BepuUtilities.QuaternionWide@,System.Int32,System.Numerics.Quaternion@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="wide">Source of the lane.</param>
            <param name="slotIndex">Index of the lane within the wide representation to read.</param>
            <param name="narrow">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="T:BepuUtilities.Symmetric2x2Wide">
            <summary>
            Stores the lower left triangle (including diagonal) of a 2x2 matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Symmetric2x2Wide.SandwichScale(BepuUtilities.Matrix2x3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Symmetric2x2Wide@)">
            <summary>
            Computes m * scale * mT. 
            </summary>
            <param name="m">Matrix to sandwich the scale with.</param>
            <param name="scale">Scale to be sandwiched.</param>
            <param name="result">Result of m * scale * mT.</param>
            <remarks>This is a peculiar operation, but it's useful for computing linear effective mass contributions in 2DOF constraints.</remarks>
        </member>
        <member name="M:BepuUtilities.Symmetric2x2Wide.MultiplyTransposed(BepuUtilities.Matrix2x3Wide@,BepuUtilities.Symmetric2x2Wide@,BepuUtilities.Matrix2x3Wide@)">
            <summary>
            Computes result = transpose(transpose(a) * b), assuming b is symmetric.
            </summary>
            <param name="a">Matrix to be transposed and multiplied.</param>
            <param name="b">Symmetric matrix to multiply.</param>
            <param name="result">Result of transpose(transpose(a) * b).</param>
        </member>
        <member name="M:BepuUtilities.Symmetric2x2Wide.CompleteMatrixSandwich(BepuUtilities.Matrix2x3Wide@,BepuUtilities.Matrix2x3Wide@,BepuUtilities.Symmetric2x2Wide@)">
            <summary>
            Computes a * transpose(b), assuming a = b * M for some symmetric matrix M. This is conceptually the second half of Triangular3x3Wide.MatrixSandwich.
            </summary>
            <param name="a">First matrix to multiply. Must be of the form a = b * M for some symmetric matrix M.</param>
            <param name="b">Matrix to be transaposed and multiplied with a..</param>
            <param name="result">Symmetric result of a * transpose(b), assuming a = b * M.</param>
        </member>
        <member name="T:BepuUtilities.Symmetric3x3">
            <summary>
            Lower left triangle (including diagonal) of a symmetric 3x3 matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3.XX">
            <summary>
            First row, first column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3.YX">
            <summary>
            Second row, first column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3.YY">
            <summary>
            Second row, second column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3.ZX">
            <summary>
            Third row, first column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3.ZY">
            <summary>
            Third row, second column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3.ZZ">
            <summary>
            Third row, third column of the matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.RotationSandwich(BepuUtilities.Matrix3x3@,BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes rT * m * r for a symmetric matrix m and a rotation matrix r.
            </summary>
            <param name="r">Rotation matrix to use as the sandwich bread.</param>
            <param name="m">Succulent interior symmetric matrix.</param>
            <param name="sandwich">Result of transpose(r) * m * r.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Determinant(BepuUtilities.Symmetric3x3@)">
            <summary>
            Computes the determinant of a symmetric matrix.
            </summary>
            <param name="m">Matrix to intepret as symmetric.</param>
            <returns>Determinant of the matrix interpreted as symmetric.</returns>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Invert(BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Inverts the given matix.
            </summary>
            <param name="m">Matrix to be inverted.</param>
            <param name="inverse">Inverted matrix.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Add(BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Adds the components of two matrices together.
            </summary>
            <param name="a">First matrix to add.</param>
            <param name="b">Second matrix to add.</param>
            <param name="result">Matrix with components equal to the components of the two input matrices added together.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Subtract(BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Subtracts the components of b from a.
            </summary>
            <param name="a">Matrix to be subtracted from.</param>
            <param name="b">Matrix to subtract from the first matrix..</param>
            <param name="result">Matrix with subtracted components.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Add(BepuUtilities.Matrix3x3@,BepuUtilities.Symmetric3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Adds the components of two matrices together.
            </summary>
            <param name="a">First matrix to add.</param>
            <param name="b">Second matrix to add.</param>
            <param name="result">Matrix with components equal to the components of the two input matrices added together.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Subtract(BepuUtilities.Matrix3x3@,BepuUtilities.Symmetric3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Subtracts the components of one matrix from another.
            </summary>
            <param name="a">Matrix to be subtracted from.</param>
            <param name="b">Matrix to subtract from the first matrix.</param>
            <param name="result">Matrix with components equal to the difference of the two input matrices.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Scale(BepuUtilities.Symmetric3x3@,System.Single,BepuUtilities.Symmetric3x3@)">
            <summary>
            Multiplies every component in the matrix by the given scale.
            </summary>
            <param name="m">Matrix to be scaled.</param>
            <param name="scale">Scale to apply to every component of the original matrix.</param>
            <param name="scaled">Scaled result.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.MultiplyWithoutOverlap(BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@,BepuUtilities.Symmetric3x3@)">
            <summary>
            Multiplies the two matrices as if they were symmetric.
            </summary>
            <param name="a">First matrix to multiply.</param>
            <param name="b">Second matrix to multiply.</param>
            <param name="result">Product of the multiplication.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.Multiply(BepuUtilities.Matrix3x3@,BepuUtilities.Symmetric3x3@,BepuUtilities.Matrix3x3@)">
            <summary>
            Multiplies the two matrices.
            </summary>
            <param name="a">First matrix to multiply.</param>
            <param name="b">Second matrix to multiply.</param>
            <param name="result">Product of the multiplication.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3.TransformWithoutOverlap(System.Numerics.Vector3@,BepuUtilities.Symmetric3x3@,System.Numerics.Vector3@)">
            <summary>
            Transforms a vector by a symmetric matrix.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="m">Matrix to interpret as symmetric transform.</param>
            <param name="result">Result of transforming the vector by the given symmetric matrix.</param>
        </member>
        <member name="T:BepuUtilities.Symmetric3x3Wide">
            <summary>
            Stores the lower left triangle (including diagonal) of a 3x3 matrix. Useful for symmetric matrices (and sometimes antisymmetric matrices).
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3Wide.XX">
            <summary>
            First row, first column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3Wide.YX">
            <summary>
            Second row, first column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3Wide.YY">
            <summary>
            Second row, second column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3Wide.ZX">
            <summary>
            Third row, first column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3Wide.ZY">
            <summary>
            Third row, second column of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric3x3Wide.ZZ">
            <summary>
            Third row, third column of the matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.Invert(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Inverts the matrix as if it is a symmetric matrix where M32 == M23, M13 == M31, and M21 == M12.
            </summary>
            <param name="m">Symmetric matrix to invert.</param>
            <param name="inverse">Inverse of the symmetric matrix.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.Add(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Adds the components of two symmetric matrices together.
            </summary>
            <param name="a">First matrix to add.</param>
            <param name="b">Second matrix to add.</param>
            <param name="result">Sum of the two input matrices.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.op_Addition(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Adds the components of two symmetric matrices together.
            </summary>
            <param name="a">First matrix to add.</param>
            <param name="b">Second matrix to add.</param>
            <returns>Sum of the two input matrices.</returns>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.Subtract(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Subtracts one symmetric matrix's components from another.
            </summary>
            <param name="a">Matrix to be subtracted from.</param>
            <param name="b">Matrix to subtract from the first matrix.</param>
            <param name="result">Result of a - b.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.op_Subtraction(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Subtracts one symmetric matrix's components from another.
            </summary>
            <param name="a">Matrix to be subtracted from.</param>
            <param name="b">Matrix to subtract from the first matrix.</param>
            <returns>Result of a - b.</returns>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.SkewSandwichWithoutOverlap(BepuUtilities.Vector3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes skewSymmetric(v) * m * transpose(skewSymmetric(v)) for a symmetric matrix m. Assumes that the input and output matrices do not overlap.
            </summary>
            <param name="m">Symmetric matrix.</param>
            <param name="v">Vector to create the skew symmetric matrix from to act as the sandwich bread.</param>
            <param name="sandwich">Result of skewSymmetric(v) * m * transpose(skewSymmetric(v)).</param>
            <remarks>This operation might have a formal name that isn't skew sandwich. But that's okay, its real name is skew sandwich.</remarks>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.VectorSandwich(BepuUtilities.Vector3Wide@,BepuUtilities.Symmetric3x3Wide@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes v * m * transpose(v) for a symmetric matrix m. Assumes that the input and output do not overlap.
            </summary>
            <param name="v">Vector acting as the sandwich bread.</param>
            <param name="m">Succulent interior symmetric matrix.</param>
            <param name="sandwich">Result of v * m * transpose(v) for a symmetric matrix m.</param>
            <remarks>Since I called the other one a skew sandwich, I really don't have a choice in the naming convention anymore.</remarks>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.RotationSandwich(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes rT * m * r for a symmetric matrix m and a rotation matrix R.
            </summary>
            <param name="r">Rotation matrix to use as the sandwich bread.</param>
            <param name="m">Succulent interior symmetric matrix.</param>
            <param name="sandwich">Result of v * m * transpose(v) for a symmetric matrix m.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.MultiplyWithoutOverlap(BepuUtilities.Matrix2x3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Matrix2x3Wide@)">
            <summary>
            Computes result = a * b, assuming that b represents a symmetric 3x3 matrix. Assumes that input parameters and output result do not overlap.
            </summary>
            <param name="a">First matrix of the pair to multiply.</param>
            <param name="b">Matrix to be reinterpreted as symmetric for the multiply.</param>
            <param name="result">Result of multiplying a * b.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.op_Multiply(BepuUtilities.Matrix2x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes result = a * b, assuming that b represents a symmetric 3x3 matrix. Assumes that input parameters and output result do not overlap.
            </summary>
            <param name="a">First matrix of the pair to multiply.</param>
            <param name="b">Matrix to be reinterpreted as symmetric for the multiply.</param>
            <returns>Result of multiplying a * b.</returns>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.MultiplyWithoutOverlap(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Computes result = a * b, assuming that b represents a symmetric 3x3 matrix. Assumes that input parameters and output result do not overlap.
            </summary>
            <param name="a">First matrix of the pair to multiply.</param>
            <param name="b">Matrix to be reinterpreted as symmetric for the multiply.</param>
            <param name="result">Result of multiplying a * b.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.op_Multiply(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes result = a * b, assuming that b represents a symmetric 3x3 matrix. Assumes that input parameters and output result do not overlap.
            </summary>
            <param name="a">First matrix of the pair to multiply.</param>
            <param name="b">Matrix to be reinterpreted as symmetric for the multiply.</param>
            <returns>Result of multiplying a * b.</returns>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.Multiply(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Computes result = a * b, assuming that a represents a symmetric 3x3 matrix. Assumes that input parameters and output result do not overlap.
            </summary>
            <param name="a">Matrix to be reinterpreted as symmetric for the multiply.</param>
            <param name="b">Second matrix of the pair to multiply.</param>
            <param name="result">Result of multiplying a * b.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.op_Multiply(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Computes result = a * b, assuming that a represents a symmetric 3x3 matrix. Assumes that input parameters and output result do not overlap.
            </summary>
            <param name="a">Matrix to be reinterpreted as symmetric for the multiply.</param>
            <param name="b">Second matrix of the pair to multiply.</param>
            <param name="result">Result of multiplying a * b.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.MultiplyByTransposed(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@)">
            <summary>
            Computes result = a * transpose(b).
            </summary>
            <param name="a">Matrix to multiply with the transposed matrix.</param>
            <param name="b">Matrix to transpose and concatenate with the first matrix.</param>
            <param name="result">Result of a * transpose(b).</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.MultiplyByTransposed(BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Matrix2x3Wide@,BepuUtilities.Matrix2x3Wide@)">
            <summary>
            Computes result = transpose(a * transpose(b)).
            </summary>
            <param name="a">Matrix to multiply with the transposed matrix.</param>
            <param name="b">Matrix to transpose and concatenate with the first matrix.</param>
            <param name="result">Result of transpose(a * transpose(b)).</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.MatrixSandwich(BepuUtilities.Matrix2x3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Symmetric2x2Wide@)">
            <summary>
            Computes m * t * mT for a symmetric matrix t and a matrix m.
            </summary>
            <param name="m">Matrix to use as the sandwich bread.</param>
            <param name="t">Succulent interior symmetric matrix.</param>
            <param name="sandwich">Result of m * t * mT for a symmetric matrix t.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.CompleteMatrixSandwich(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes result = a * b, where a = transpose(b) * M for some symmetric matrix M.
            </summary>
            <param name="a">Some matrix equal to transpose(b) * M for some symmetric matrix M.</param>
            <param name="b">Matrix used to sandwich the original matrix M.</param>
            <param name="result">Complete result of transpose(b) * M * b.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.CompleteMatrixSandwich(BepuUtilities.Matrix2x3Wide@,BepuUtilities.Matrix2x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes result = tranpose(a) * b, where a = transpose(transpose(b) * M) for some symmetric matrix M. In other words, we're just treating matrix a as a 3x2 matrix.
            </summary>
            <param name="a">Some matrix equal to transpose(b) * M for some symmetric matrix M.</param>
            <param name="b">Matrix used to sandwich the original matrix M.</param>
            <param name="result">Complete result of transpose(b) * M * b.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.CompleteMatrixSandwichByTranspose(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes result = a * transpose(b), where a = b * M for some symmetric matrix M.
            </summary>
            <param name="a">Some matrix equal to b * M for some symmetric matrix M.</param>
            <param name="b">Matrix used to sandwich the original matrix M, to be transposed.</param>
            <param name="result">Complete result of b * M * transpose(b).</param>
        </member>
        <member name="M:BepuUtilities.Symmetric3x3Wide.CompleteMatrixSandwichTranspose(BepuUtilities.Matrix3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Symmetric3x3Wide@)">
            <summary>
            Computes result = transpose(a) * b, where b = M * a for some symmetric matrix M.
            </summary>
            <param name="a">Matrix used to sandwich the original matrix M.</param>
            <param name="b">Some matrix equal to M * a for some symmetric matrix M.</param>
            <param name="result">Complete result of transpose(a) * M * a.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric4x4Wide.GetUpperLeft3x3Block(BepuUtilities.Symmetric4x4Wide@)">
            <summary>
            Returns a reference to the upper left 3x3 block of the matrix.
            </summary>
            <param name="m">Matrix to pull a block from.</param>
            <returns>Reference to the requested block.</returns>
        </member>
        <member name="M:BepuUtilities.Symmetric4x4Wide.GetUpperRight3x1Block(BepuUtilities.Symmetric4x4Wide@)">
            <summary>
            Returns a reference to the upper right 3x1 (or lower left 1x3) block of the matrix. 
            </summary>
            <param name="m">Matrix to pull a block from.</param>
            <returns>Reference to the requested block.</returns>
        </member>
        <member name="M:BepuUtilities.Symmetric4x4Wide.Scale(BepuUtilities.Symmetric4x4Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Symmetric4x4Wide@)">
            <summary>
            Scales each component of m by the given scale.
            </summary>
            <param name="m">Matrix to scale.</param>
            <param name="scale">Scale to apply to the components of m.</param>
            <param name="result">Result of scaling each component of m by scale.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric4x4Wide.TransformWithoutOverlap(BepuUtilities.Vector4Wide@,BepuUtilities.Symmetric4x4Wide,BepuUtilities.Vector4Wide@)">
            <summary>
            Computes result = v * m.
            </summary>
            <param name="v">Vector to transform.</param>
            <param name="m">Matrix to transform with.</param>
            <param name="result">Result of the transform.</param>
        </member>
        <member name="F:BepuUtilities.Symmetric5x5Wide.A">
            <summary>
            Upper left 3x3 block of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric5x5Wide.B">
            <summary>
            Lower left 2x3 block of the matrix.
            </summary>
        </member>
        <member name="F:BepuUtilities.Symmetric5x5Wide.D">
            <summary>
            Lower right 2x2 block of the matrix.
            </summary>
        </member>
        <member name="M:BepuUtilities.Symmetric5x5Wide.Scale(BepuUtilities.Symmetric5x5Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Symmetric5x5Wide@)">
            <summary>
            Scales each component of m by the given scale.
            </summary>
            <param name="m">Matrix to scale.</param>
            <param name="scale">Scale to apply to the components of m.</param>
            <param name="result">Result of scaling each component of m by scale.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric5x5Wide.TransformWithoutOverlap(BepuUtilities.Vector3Wide@,BepuUtilities.Vector2Wide@,BepuUtilities.Symmetric5x5Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector2Wide@)">
            <summary>
            Computes result = v * m, where v and result are 1x5 vectors which are split into two subvectors.
            </summary>
            <param name="v0">First half of the a vector.</param>
            <param name="v1">Second half of the a vector.</param>
            <param name="m">Matrix to transform with.</param>
            <param name="result0">First half of the result.</param>
            <param name="result1">Second half of the result.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric6x6Wide.Scale(BepuUtilities.Symmetric6x6Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Symmetric6x6Wide@)">
            <summary>
            Scales each component of m by the given scale.
            </summary>
            <param name="m">Matrix to scale.</param>
            <param name="scale">Scale to apply to the components of m.</param>
            <param name="result">Result of scaling each component of m by scale.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric6x6Wide.TransformWithoutOverlap(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Symmetric6x6Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes result = v * m, where v and result are 1x6 vectors which are split into two 1x3 values.
            </summary>
            <param name="v0">First half of the a vector.</param>
            <param name="v1">Second half of the a vector.</param>
            <param name="m">Matrix to transform with.</param>
            <param name="result0">First half of the result.</param>
            <param name="result1">Second half of the result.</param>
        </member>
        <member name="M:BepuUtilities.Symmetric6x6Wide.LDLTSolve(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Matrix3x3Wide@,BepuUtilities.Symmetric3x3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Solves [vLower, vUpper] = [resultLower, resultUpper] * [[a, b], [bT, d]] for [resultLower, resultUpper] using LDLT decomposition.
            [[a, b], [bT, d]] should be positive semidefinite.
            </summary>
            <param name="v0">First 3 values of the 6 component input vector.</param>
            <param name="v1">Second 3 values of the 6 component input vector.</param>
            <param name="a">Upper left 3x3 region of the matrix.</param>
            <param name="b">Upper right 3x3 region of the matrix. Also the lower left 3x3 region of the matrix, transposed.</param>
            <param name="d">Lower right 3x3 region of the matrix.</param>
            <param name="result0">First 3 values of the result vector.</param>
            <param name="result1">Second 3 values of the result vector.</param>
        </member>
        <member name="T:BepuUtilities.ThreadDispatcher">
            <summary>
            Provides a <see cref="T:BepuUtilities.IThreadDispatcher"/> implementation. Not reentrant.
            </summary>
        </member>
        <member name="P:BepuUtilities.ThreadDispatcher.ThreadCount">
            <summary>
            Gets the number of threads to dispatch work on.
            </summary>
        </member>
        <member name="M:BepuUtilities.ThreadDispatcher.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new thread dispatcher with the given number of threads.
            </summary>
            <param name="threadCount">Number of threads to dispatch on each invocation.</param>
            <param name="threadPoolBlockAllocationSize">Size of memory blocks to allocate for thread pools.</param>
        </member>
        <member name="M:BepuUtilities.ThreadDispatcher.Dispose">
            <summary>
            Waits for all pending work to complete and then disposes all workers.
            </summary>
        </member>
        <member name="T:BepuUtilities.Vector2Wide">
            <summary>
            Two dimensional vector with <see cref="P:System.Numerics.Vector`1.Count"/> (with generic type argument of <see cref="T:System.Single"/>) SIMD lanes.
            </summary>
        </member>
        <member name="F:BepuUtilities.Vector2Wide.X">
            <summary>
            First component of the vector.
            </summary>
        </member>
        <member name="F:BepuUtilities.Vector2Wide.Y">
            <summary>
            Second component of the vector.
            </summary>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.Add(BepuUtilities.Vector2Wide@,BepuUtilities.Vector2Wide@,BepuUtilities.Vector2Wide@)">
            <summary>
            Performs a componentwise add between two vectors.
            </summary>
            <param name="a">First vector to add.</param>
            <param name="b">Second vector to add.</param>
            <param name="result">Sum of a and b.</param>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.op_Addition(BepuUtilities.Vector2Wide,BepuUtilities.Vector2Wide)">
            <summary>
            Performs a componentwise add between two vectors.
            </summary>
            <param name="a">First vector to add.</param>
            <param name="b">Second vector to add.</param>
            <returns>Sum of a and b.</returns>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.op_Addition(BepuUtilities.Vector2Wide,System.Numerics.Vector{System.Single})">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <returns>Vector with components equal to the input vector added to the input scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.op_Addition(System.Numerics.Vector{System.Single},BepuUtilities.Vector2Wide)">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <returns>Vector with components equal to the input vector added to the input scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.ReadFirst(BepuUtilities.Vector2Wide@,System.Numerics.Vector2@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="source">Source of the lane.</param>
            <param name="target">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.ReadSlot(BepuUtilities.Vector2Wide@,System.Int32,System.Numerics.Vector2@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="wide">Source of the lane.</param>
            <param name="slotIndex">Index of the lane within the wide representation to read.</param>
            <param name="narrow">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.WriteFirst(System.Numerics.Vector2@,BepuUtilities.Vector2Wide@)">
            <summary>
            Gathers values from a vector and places them into the first indices of the target vector.
            </summary>
            <param name="source">Vector to copy values from.</param>
            <param name="targetSlot">Wide vectorto place values into.</param>
        </member>
        <member name="M:BepuUtilities.Vector2Wide.WriteSlot(System.Numerics.Vector2@,System.Int32,BepuUtilities.Vector2Wide@)">
            <summary>
            Writes a value into a slot of the target bundle.
            </summary>
            <param name="source">Source of the value to write.</param>
            <param name="slotIndex">Index of the slot to write into.</param>
            <param name="target">Bundle to write the value into.</param>
        </member>
        <member name="T:BepuUtilities.Vector3Wide">
            <summary>
            Three dimensional vector with <see cref="P:System.Numerics.Vector`1.Count"/> (with generic type argument of <see cref="T:System.Single"/>) SIMD lanes.
            </summary>
        </member>
        <member name="F:BepuUtilities.Vector3Wide.X">
            <summary>
            First component of the vector.
            </summary>
        </member>
        <member name="F:BepuUtilities.Vector3Wide.Y">
            <summary>
            Second component of the vector.
            </summary>
        </member>
        <member name="F:BepuUtilities.Vector3Wide.Z">
            <summary>
            Third component of the vector.
            </summary>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.#ctor(System.Numerics.Vector{System.Single}@)">
            <summary>
            Creates a vector by populating each component with the given scalar.
            </summary>
            <param name="s">Scalar to copy into all lanes of the vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.#ctor(System.Numerics.Vector{System.Single})">
            <summary>
            Creates a vector by populating each component with the given scalar.
            </summary>
            <param name="s">Scalar to copy into all lanes of the vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Add(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Performs a componentwise add between two vectors.
            </summary>
            <param name="a">First vector to add.</param>
            <param name="b">Second vector to add.</param>
            <param name="result">Sum of a and b.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Add(BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@)">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <param name="result">Vector with components equal to the input vector added to the input scalar.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Addition(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Performs a componentwise add between two vectors.
            </summary>
            <param name="a">First vector to add.</param>
            <param name="b">Second vector to add.</param>
            <returns>Sum of a and b.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Addition(BepuUtilities.Vector3Wide,System.Numerics.Vector{System.Single})">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <returns>Vector with components equal to the input vector added to the input scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Addition(System.Numerics.Vector{System.Single},BepuUtilities.Vector3Wide)">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <returns>Vector with components equal to the input vector added to the input scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Subtract(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Subtracts one vector from another.
            </summary>
            <param name="a">Vector to subtract from.</param>
            <param name="b">Vector to subtract from the first vector.</param>
            <param name="result">Vector with components equal the input scalar subtracted from the input vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Subtract(BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@)">
            <summary>
            Finds the result of subtracting a scalar from every component of a vector.
            </summary>
            <param name="v">Vector to subtract from.</param>
            <param name="s">Scalar to subtract from every component of the vector.</param>
            <param name="result">Vector with components equal the input scalar subtracted from the input vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Subtraction(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Subtracts one vector from another.
            </summary>
            <param name="a">Vector to subtract from.</param>
            <param name="b">Vector to subtract from the first vector.</param>
            <returns>Vector with components equal the input scalar subtracted from the input vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Subtract(System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Finds the result of subtracting the components of a vector from a scalar.
            </summary>
            <param name="v">Vector to subtract from the scalar.</param>
            <param name="s">Scalar to subtract from.</param>
            <param name="result">Vector with components equal the input vector subtracted from the input scalar.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Subtraction(BepuUtilities.Vector3Wide,System.Numerics.Vector{System.Single})">
            <summary>
            Finds the result of subtracting the components of a vector from a scalar.
            </summary>
            <param name="v">Vector to subtract from the scalar.</param>
            <param name="s">Scalar to subtract from.</param>
            <returns>Vector with components equal the input vector subtracted from the input scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Dot(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes the inner product between two vectors.
            </summary>
            <param name="a">First vector to dot.</param>
            <param name="b">Second vector to dot.</param>
            <param name="result">Dot product of a and b.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Dot(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Computes the inner product between two vectors.
            </summary>
            <param name="a">First vector to dot.</param>
            <param name="b">Second vector to dot.</param>
            <returns>Dot product of a and b.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Min(System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the per-component minimum between a scalar value and the components of a vector.
            </summary>
            <param name="s">Scalar to compare to each vector component.</param>
            <param name="v">Vector whose components will be compared.</param>
            <param name="result">Vector with components matching the smaller of the scalar value and the input vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Min(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the per-component minimum of two vectors.
            </summary>
            <param name="a">First vector whose components will be compared.</param>
            <param name="b">Second vector whose components will be compared.</param>
            <param name="result">Vector with components matching the smaller of the two input vectors.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Min(System.Numerics.Vector{System.Single},BepuUtilities.Vector3Wide)">
            <summary>
            Computes the per-component minimum between a scalar value and the components of a vector.
            </summary>
            <param name="s">Scalar to compare to each vector component.</param>
            <param name="v">Vector whose components will be compared.</param>
            <returns>Vector with components matching the smaller of the scalar value and the input vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Min(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Computes the per-component minimum of two vectors.
            </summary>
            <param name="a">First vector whose components will be compared.</param>
            <param name="b">Second vector whose components will be compared.</param>
            <returns>Vector with components matching the smaller of the two input vectors.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Max(System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the per-component maximum between a scalar value and the components of a vector.
            </summary>
            <param name="s">Scalar to compare to each vector component.</param>
            <param name="v">Vector whose components will be compared.</param>
            <param name="result">Vector with components matching the larger of the scalar value and the input vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Max(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the per-component maximum of two vectors.
            </summary>
            <param name="a">First vector whose components will be compared.</param>
            <param name="b">Second vector whose components will be compared.</param>
            <param name="result">Vector with components matching the larger of the two input vectors.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Max(System.Numerics.Vector{System.Single},BepuUtilities.Vector3Wide)">
            <summary>
            Computes the per-component maximum between a scalar value and the components of a vector.
            </summary>
            <param name="s">Scalar to compare to each vector component.</param>
            <param name="v">Vector whose components will be compared.</param>
            <returns>Vector with components matching the larger of the scalar value and the input vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Max(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Computes the per-component maximum of two vectors.
            </summary>
            <param name="a">First vector whose components will be compared.</param>
            <param name="b">Second vector whose components will be compared.</param>
            <returns>Vector with components matching the larger of the two input vectors.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Scale(BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@,BepuUtilities.Vector3Wide@)">
            <summary>
            Scales a vector by a scalar.
            </summary>
            <param name="vector">Vector to scale.</param>
            <param name="scalar">Scalar to apply to the vector.</param>
            <param name="result">Scaled result vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Division(BepuUtilities.Vector3Wide,System.Numerics.Vector{System.Single})">
            <summary>
            Divides each component of the vector by the scalar.
            </summary>
            <param name="vector">Vector to divide.</param>
            <param name="scalar">Scalar to divide the vector by.</param>
            <returns>Value of the vector divided by the scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Multiply(BepuUtilities.Vector3Wide,System.Numerics.Vector{System.Single})">
            <summary>
            Scales a vector by a scalar.
            </summary>
            <param name="vector">Vector to scale.</param>
            <param name="scalar">Scalar to apply to the vector.</param>
            <returns>Scaled result vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Multiply(System.Numerics.Vector{System.Single},BepuUtilities.Vector3Wide)">
            <summary>
            Scales a vector by a scalar.
            </summary>
            <param name="vector">Vector to scale.</param>
            <param name="scalar">Scalar to apply to the vector.</param>
            <returns>Scaled result vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Abs(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the absolute value of a vector.
            </summary>
            <param name="vector">Vector to take the absolute value of.</param>
            <param name="result">Absolute value of the input vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Abs(BepuUtilities.Vector3Wide)">
            <summary>
            Computes the absolute value of a vector.
            </summary>
            <param name="vector">Vector to take the absolute value of.</param>
            <returns>Absolute value of the input vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Negate(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Negates a vector.
            </summary>
            <param name="v">Vector to negate.</param>
            <param name="result">Negated vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Negate(BepuUtilities.Vector3Wide@)">
            <summary>
            Negates a vector in place and returns a reference to it.
            </summary>
            <param name="v">Vector to negate.</param>
            <returns>Reference to the input parameter, mutated.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_UnaryNegation(BepuUtilities.Vector3Wide)">
            <summary>
            Negates a vector.
            </summary>
            <param name="v">Vector to negate.</param>
            <returns>Negated vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.ConditionallyNegate(System.Numerics.Vector{System.Int32}@,BepuUtilities.Vector3Wide@)">
            <summary>
            Conditionally negates lanes of the vector.
            </summary>
            <param name="shouldNegate">Mask indicating which lanes should be negated.</param>
            <param name="v">Reference to the vector to be conditionally negated.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.ConditionallyNegate(System.Numerics.Vector{System.Int32}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Conditionally negates lanes of the vector.
            </summary>
            <param name="shouldNegate">Mask indicating which lanes should be negated.</param>
            <param name="v">Vector to be conditionally negated.</param>
            <param name="negated">Conditionally negated result.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.ConditionallyNegate(System.Numerics.Vector{System.Int32},BepuUtilities.Vector3Wide)">
            <summary>
            Conditionally negates lanes of the vector.
            </summary>
            <param name="shouldNegate">Mask indicating which lanes should be negated.</param>
            <param name="v">Vector to be conditionally negated.</param>
            <returns>Conditionally negated vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.CrossWithoutOverlap(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the cross product between two vectors, assuming that the vector references are not aliased.
            </summary>
            <param name="a">First vector to cross.</param>
            <param name="b">Second vector to cross.</param>
            <param name="result">Result of the cross product.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Cross(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes the cross product between two vectors.
            </summary>
            <param name="a">First vector to cross.</param>
            <param name="b">Second vector to cross.</param>
            <param name="result">Result of the cross product.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Cross(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Computes the cross product between two vectors.
            </summary>
            <param name="a">First vector to cross.</param>
            <param name="b">Second vector to cross.</param>
            <returns>Result of the cross product.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.LengthSquared(BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes the squared length of a vector.
            </summary>
            <param name="v">Vector to compute the squared length of.</param>
            <param name="lengthSquared">Squared length of the input vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Length(BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes the length of a vector.
            </summary>
            <param name="v">Vector to compute the length of.</param>
            <param name="length">Length of the input vector.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.LengthSquared(BepuUtilities.Vector3Wide)">
            <summary>
            Computes the squared length of a vector.
            </summary>
            <param name="v">Vector to compute the squared length of.</param>
            <returns>Squared length of the input vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Length(BepuUtilities.Vector3Wide)">
            <summary>
            Computes the length of a vector.
            </summary>
            <param name="v">Vector to compute the length of.</param>
            <returns>Length of the input vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.LengthSquared">
            <summary>
            Computes the squared length of the vector.
            </summary>
            <returns>Squared length of this vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Length">
            <summary>
            Computes the length of the vector.
            </summary>
            <returns>Length of this vector.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Distance(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes the distance between two vectors.
            </summary>
            <param name="a">First vector in the pair.</param>
            <param name="b">Second vector in the pair.</param>
            <param name="distance">Distance between a and b.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.DistanceSquared(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,System.Numerics.Vector{System.Single}@)">
            <summary>
            Computes the squared distance between two vectors.
            </summary>
            <param name="a">First vector in the pair.</param>
            <param name="b">Second vector in the pair.</param>
            <param name="distanceSquared">Squared distance between a and b.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Distance(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Computes the distance between two vectors.
            </summary>
            <param name="a">First vector in the pair.</param>
            <param name="b">Second vector in the pair.</param>
            <returns>Distance between a and b.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.DistanceSquared(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Computes the squared distance between two vectors.
            </summary>
            <param name="a">First vector in the pair.</param>
            <param name="b">Second vector in the pair.</param>
            <returns>Squared distance between a and b.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Normalize(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Computes a unit length vector pointing in the same direction as the input.
            </summary>
            <param name="v">Vector to normalize.</param>
            <param name="result">Vector pointing in the same direction as the input, but with unit length.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Normalize(BepuUtilities.Vector3Wide)">
            <summary>
            Computes a unit length vector pointing in the same direction as the input.
            </summary>
            <param name="v">Vector to normalize.</param>
            <returns>Vector pointing in the same direction as the input, but with unit length.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.ConditionalSelect(System.Numerics.Vector{System.Int32}@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Selects the left or right input for each lane depending on a mask.
            </summary>
            <param name="condition">Mask to use to decide between the left and right value for each lane..</param>
            <param name="left">Value to choose if the condition mask is set.</param>
            <param name="right">Value to choose if the condition mask is unset.</param>
            <param name="result">Blended result.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.ConditionalSelect(System.Numerics.Vector{System.Int32},BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Selects the left or right input for each lane depending on a mask.
            </summary>
            <param name="condition">Mask to use to decide between the left and right value for each lane..</param>
            <param name="left">Value to choose if the condition mask is set.</param>
            <param name="right">Value to choose if the condition mask is unset.</param>
            <returns>Blended result.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Multiply(BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@,BepuUtilities.Vector3Wide@)">
            <summary>
            Multiplies the components of one vector with another.
            </summary>
            <param name="a">First vector to multiply.</param>
            <param name="b">Second vector to multiply.</param>
            <param name="result">Result of the multiplication.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.op_Multiply(BepuUtilities.Vector3Wide,BepuUtilities.Vector3Wide)">
            <summary>
            Multiplies the components of one vector with another.
            </summary>
            <param name="a">First vector to multiply.</param>
            <param name="b">Second vector to multiply.</param>
            <returns>Result of the multiplication.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.ReadSlot(BepuUtilities.Vector3Wide@,System.Int32,System.Numerics.Vector3@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="wide">Source of the lane.</param>
            <param name="slotIndex">Index of the lane within the wide representation to read.</param>
            <param name="narrow">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.ReadFirst(BepuUtilities.Vector3Wide@,System.Numerics.Vector3@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="source">Source of the lane.</param>
            <param name="target">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.WriteFirst(System.Numerics.Vector3@,BepuUtilities.Vector3Wide@)">
            <summary>
            Gathers values from a vector and places them into the first indices of the target vector.
            </summary>
            <param name="source">Vector to copy values from.</param>
            <param name="targetSlot">Wide vectorto place values into.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.WriteSlot(System.Numerics.Vector3@,System.Int32,BepuUtilities.Vector3Wide@)">
            <summary>
            Writes a value into a slot of the target bundle.
            </summary>
            <param name="source">Source of the value to write.</param>
            <param name="slotIndex">Index of the slot to write into.</param>
            <param name="target">Bundle to write the value into.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Broadcast(System.Numerics.Vector3@,BepuUtilities.Vector3Wide@)">
            <summary>
            Expands each scalar value to every slot of the bundle.
            </summary>
            <param name="source">Source value to write to every bundle slot.</param>
            <param name="broadcasted">Bundle containing the source's components in every slot.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Broadcast(System.Numerics.Vector3)">
            <summary>
            Expands each scalar value to every slot of the bundle.
            </summary>
            <param name="source">Source value to write to every bundle slot.</param>
            <returns>Bundle containing the source's components in every slot.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Rebroadcast(BepuUtilities.Vector3Wide@,System.Int32,BepuUtilities.Vector3Wide@)">
            <summary>
            Takes a slot from the source vector and broadcasts it into all slots of the target vector.
            </summary>
            <param name="source">Vector to pull values from.</param>
            <param name="slotIndex">Slot in the source vectors to pull values from.</param>
            <param name="broadcasted">Target vector to be filled with the selected data.</param>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.Rebroadcast(BepuUtilities.Vector3Wide,System.Int32)">
            <summary>
            Takes a slot from the source vector and broadcasts it into all slots of the target vector.
            </summary>
            <param name="source">Vector to pull values from.</param>
            <param name="slotIndex">Slot in the source vectors to pull values from.</param>
            <returns>Target vector to be filled with the selected data.</returns>
        </member>
        <member name="M:BepuUtilities.Vector3Wide.CopySlot(BepuUtilities.Vector3Wide@,System.Int32,BepuUtilities.Vector3Wide@,System.Int32)">
            <summary>
            Takes a slot from the source vector and places it into a slot of the target.
            </summary>
            <param name="source">Vector to pull values from.</param>
            <param name="sourceSlotIndex">Slot in the source vectors to pull values from.</param>
            <param name="target">Target vector whose slot will be filled with the selected data.</param>
            <param name="targetSlotIndex">Slot in the target vectors to write values into.</param>
        </member>
        <member name="T:BepuUtilities.Vector4Wide">
            <summary>
            Four dimensional vector with <see cref="P:System.Numerics.Vector`1.Count"/> (with generic type argument of <see cref="T:System.Single"/>) SIMD lanes.
            </summary>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.Add(BepuUtilities.Vector4Wide,BepuUtilities.Vector4Wide,BepuUtilities.Vector4Wide@)">
            <summary>
            Performs a componentwise add between two vectors.
            </summary>
            <param name="a">First vector to add.</param>
            <param name="b">Second vector to add.</param>
            <param name="result">Sum of a and b.</param>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.Add(BepuUtilities.Vector4Wide,System.Numerics.Vector{System.Single},BepuUtilities.Vector4Wide@)">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <param name="result">Vector with components equal to the input vector added to the input scalar.</param>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.op_Addition(BepuUtilities.Vector4Wide,BepuUtilities.Vector4Wide)">
            <summary>
            Performs a componentwise add between two vectors.
            </summary>
            <param name="a">First vector to add.</param>
            <param name="b">Second vector to add.</param>
            <returns>Sum of a and b.</returns>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.op_Addition(BepuUtilities.Vector4Wide,System.Numerics.Vector{System.Single})">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <returns>Vector with components equal to the input vector added to the input scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.op_Addition(System.Numerics.Vector{System.Single},BepuUtilities.Vector4Wide)">
            <summary>
            Finds the result of adding a scalar to every component of a vector.
            </summary>
            <param name="v">Vector to add to.</param>
            <param name="s">Scalar to add to every component of the vector.</param>
            <returns>Vector with components equal to the input vector added to the input scalar.</returns>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.Min(BepuUtilities.Vector4Wide@,BepuUtilities.Vector4Wide@,BepuUtilities.Vector4Wide@)">
            <summary>
            Computes the per-component minimum of two vectors.
            </summary>
            <param name="a">First vector whose components will be compared.</param>
            <param name="b">Second vector whose components will be compared.</param>
            <param name="result">Vector with components matching the smaller of the two input vectors.</param>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.Max(BepuUtilities.Vector4Wide@,BepuUtilities.Vector4Wide@,BepuUtilities.Vector4Wide@)">
            <summary>
            Computes the per-component maximum of two vectors.
            </summary>
            <param name="a">First vector whose components will be compared.</param>
            <param name="b">Second vector whose components will be compared.</param>
            <param name="result">Vector with components matching the larger of the two input vectors.</param>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.ReadSlot(BepuUtilities.Vector4Wide@,System.Int32,System.Numerics.Vector4@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="wide">Source of the lane.</param>
            <param name="slotIndex">Index of the lane within the wide representation to read.</param>
            <param name="narrow">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.ReadFirst(BepuUtilities.Vector4Wide@,System.Numerics.Vector4@)">
            <summary>
            Pulls one lane out of the wide representation.
            </summary>
            <param name="source">Source of the lane.</param>
            <param name="target">Non-SIMD type to store the lane in.</param>
        </member>
        <member name="M:BepuUtilities.Vector4Wide.WriteFirst(System.Numerics.Vector4@,BepuUtilities.Vector4Wide@)">
            <summary>
            Gathers values from a vector and places them into the first indices of the target vector.
            </summary>
            <param name="source">Vector to copy values from.</param>
            <param name="targetSlot">Wide vectorto place values into.</param>
        </member>
    </members>
</doc>
