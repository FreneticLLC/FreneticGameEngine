//
// This file is part of the Frenetic Game Engine, created by Frenetic LLC.
// This code is Copyright (C) Frenetic LLC under the terms of a strict license.
// See README.md or LICENSE.txt in the FreneticGameEngine source root for the contents of the license.
// If neither of these are available, assume that neither you nor anyone other than the copyright holder
// hold any right or permission to use this software until such time as the official license is identified.
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FGECore.EntitySystem.JointSystems.NonPhysicsJoints;
using FGECore.EntitySystem.PhysicsHelpers;
using FGECore.MathHelpers;
using FGECore.PhysicsSystem;
using FGECore.PropertySystem;
using BepuPhysics;
using BepuPhysics.Collidables;
using System.Numerics;
using BepuPhysics.Trees;
using BepuPhysics.CollisionDetection;

using Quaternion = FGECore.MathHelpers.Quaternion;

namespace FGECore.EntitySystem;

/// <summary>Identifies and controls the factors of an entity relating to standard-implemented physics.</summary>
public class EntityPhysicsProperty : BasicEntityProperty
{
    // TODO: Save the correct physics world ref?
    /// <summary>The owning physics world.</summary>
    public PhysicsSpace PhysicsWorld;

    /// <summary>Whether the entity is currently spawned into the physics world.</summary>
    public bool IsSpawned = false;

    /// <summary>The spawned physics body handle.</summary>
    public BodyReference SpawnedBody;

    /// <summary>Event fired when this entity collides with another.
    /// <para>Warning: runs on physics multi-thread. If you need main-thread, collect data and in-event and then defer handling through the Scheduler.</para></summary>
    public Action<CollisionEvent> CollisionHandler;

    /// <summary>Event called every physics update tick with a delta value.
    /// Immediately after this event completes, the entity's velocity/gravity/etc. are copied over, and then after general physics calculations occur.
    /// <para>Note that physics delta might not always match game delta.</para>
    /// <para>Warning: runs on physics multi-thread. If you need main-thread, collect data and in-event and then defer handling through the Scheduler.</para></summary>
    public Action<double> PhysicsUpdate;

    /// <summary>The shape of the physics body. This should not be altered while the entity is spawned.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    [PropertyPriority(-1000)]
    public EntityShapeHelper Shape;

    /// <summary>Whether gravity value is already set for this entity. If not set, <see cref="Gravity"/> is invalid or irrelevant.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public bool GravityIsSet = false;

    /// <summary>This entity's collision group.</summary>
    public CollisionGroup CGroup;

    /// <summary>Internal data for this physics property.</summary>
    public struct InternalData
    {
        /// <summary>The starting mass of the physics body.</summary>
        public float Mass;

        /// <summary>The starting gravity of the physics body.</summary>
        public Location Gravity;

        /// <summary>The starting linear velocity of the physics body.</summary>
        public Location LinearVelocity;

        /// <summary>The starting angular velocity of the physics body.</summary>
        public Location AngularVelocity;

        /// <summary>The starting position of the physics body.</summary>
        public Location Position;

        /// <summary>The starting orientation of the physics body.</summary>
        public Quaternion Orientation;

        /// <summary>A set of no-collide IDs, if any, as generated by <see cref="JointNoCollide"/>.</summary>
        public HashSet<long> NoCollideIDs;
    }

    /// <summary>Internal data for this physics property.</summary>
    public InternalData Internal = new() { Mass = 1f, Orientation = Quaternion.Identity };

    // TODO: Shape save/debug
    // TODO: Maybe point to the correct physics space somehow in saves/debug? Needs a space ID.

    /// <summary>Gets or sets the entity's mass.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public float Mass
    {
        get
        {
            if (IsSpawned)
            {
                float invmass = SpawnedBody.LocalInertia.InverseMass;
                return invmass == 0 ? 0 : 1f / invmass;
            }
            else
            {
                return Internal.Mass;
            }
        }
        set
        {
            Internal.Mass = value;
            if (IsSpawned)
            {
                if (value == SpawnedBody.LocalInertia.InverseMass)
                {
                    return;
                }
                if (value == 0)
                {
                    SpawnedBody.BecomeKinematic();
                }
                else if (SpawnedBody.LocalInertia.InverseMass == 0)
                {
                    Shape.ComputeInertia(value, out SpawnedBody.LocalInertia);
                }
                else
                {
                    SpawnedBody.LocalInertia.InverseMass = 1f / value;
                }
            }
        }
    }

    /// <summary>Gets or sets the entity's custom gravity value. Can be unset to use gravity shared gravity value.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public Location Gravity
    {
        get
        {
            return Internal.Gravity;
        }
        set
        {
            Internal.Gravity = value;
            GravityIsSet = true;
        }
    }

    /// <summary>Gets the actual current gravity value.</summary>
    public Location ActualGravity => GravityIsSet ? Internal.Gravity : PhysicsWorld.Gravity;

    /// <summary>The entity's friction coefficient.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public float Friction = 1f;

    /// <summary>The entity's bounciness.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public float Bounciness = 0.1f;

    /// <summary>The entity's linear damping (per second) rate. Must be from 0 to 1, inclusive.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public float LinearDamping = 0.03f;

    /// <summary>The entity's angular damping (per second) rate. Must be from 0 to 1, inclusive.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public float AngularDamping = 0.03f;

    /// <summary>Temporary (single-physics-tick) boost to linear damping.</summary>
    public float LinearDampingBoost = 0;

    /// <summary>Temporary (single-physics-tick) boost to angular damping.</summary>
    public float AngularDampingBoost = 0;

    /// <summary>Gets or sets the entity's linear velocity.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public Location LinearVelocity
    {
        get
        {
            return IsSpawned ? SpawnedBody.Velocity.Linear.ToLocation() : Internal.LinearVelocity;
        }
        set
        {
            Internal.LinearVelocity = value;
            if (IsSpawned)
            {
                SpawnedBody.Velocity.Linear = Internal.LinearVelocity.ToNumerics();
            }
        }
    }

    /// <summary>Gets or sets the entity's angular velocity.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public Location AngularVelocity
    {
        get
        {
            return IsSpawned ? SpawnedBody.Velocity.Angular.ToLocation() : Internal.AngularVelocity;
        }
        set
        {
            Internal.AngularVelocity = value;
            if (IsSpawned)
            {
                SpawnedBody.Velocity.Angular = Internal.AngularVelocity.ToNumerics();
            }
        }
    }

    /// <summary>Gets or sets the entity's position.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public Location Position
    {
        get
        {
            return IsSpawned ? SpawnedBody.Pose.Position.ToLocation() + PhysicsWorld.Offset : Internal.Position;
        }
        set
        {
            Internal.Position = value;
            if (IsSpawned)
            {
                SpawnedBody.Pose.Position = (Internal.Position - PhysicsWorld.Offset).ToNumerics();
                SpawnedBody.UpdateBounds();
            }
        }
    }

    /// <summary>Gets or sets the entity's orientation.</summary>
    [PropertyDebuggable]
    [PropertyAutoSavable]
    public Quaternion Orientation
    {
        get
        {
            return IsSpawned ? SpawnedBody.Pose.Orientation.ToCore() : Internal.Orientation;
        }
        set
        {
            Internal.Orientation = value;
            if (IsSpawned)
            {
                SpawnedBody.Pose.Orientation = Internal.Orientation.ToNumerics();
                SpawnedBody.UpdateBounds();
            }
        }
    }

    /// <summary>Gets the entity's bounding box. This box is centered on the entity - to get the spatial bounds, add the <see cref="Position"/> to the box.
    /// Returns <see cref="AABB.NaN"/> if the entity is not spawned or otherwise has no known box.</summary>
    /// <param name="recalculate">If true, the bounding box will be updated before returning. If false, it will be only whatever value was present on the last physics update (ie, may be offset if the entity has moved).</param>
    public unsafe AABB GetBounds(bool recalculate)
    {
        if (!IsSpawned)
        {
            return AABB.NaN;
        }
        if (recalculate)
        {
            SpawnedBody.UpdateBounds();
        }
        SpawnedBody.GetBoundsReferencesFromBroadPhase(out Vector3* min, out Vector3* max);
        Vector3 pos = SpawnedBody.Pose.Position;
        if (min is null || max is null)
        {
            return AABB.NaN;
        }
        return new((*min - pos).ToLocation(), (*max - pos).ToLocation());
    }

    /// <summary>Fired when the entity is added to the world.</summary>
    public override void OnSpawn()
    {
        if (IsSpawned)
        {
            return;
        }
        PhysicsWorld ??= Engine.PhysicsWorldGeneric;
        if (Shape == null)
        {
            return;
        }
        HandledRemove = false;
        SpawnHandle();
        Entity.OnPositionChanged += DoPosCheckEvent;
        Entity.OnOrientationChanged += DoOrientationCheckEvent;
    }

    /// <summary>Fired when the entity is removed from the world.</summary>
    public override void OnDespawn()
    {
        if (HandledRemove)
        {
            return;
        }
        HandledRemove = true;
        DespawnHandle();
        Entity.OnPositionChanged -= DoPosCheckEvent;
        Entity.OnOrientationChanged -= DoOrientationCheckEvent;
    }

    /// <summary>Whether the position and orientation changed events should be propogated to the physics body. Usually leave true.</summary>
    public bool DoTrackPositionChange = true;

    private void DoPosCheckEvent(Location position)
    {
        if (DoTrackPositionChange)
        {
            Position = position;
        }
    }

    private void DoOrientationCheckEvent(Quaternion orientation)
    {
        if (DoTrackPositionChange)
        {
            Orientation = orientation;
        }
    }

    /// <summary>Handles the physics entity being spawned into a world.</summary>
    public void SpawnHandle()
    {
        if (IsSpawned)
        {
            return;
        }
        if (!GravityIsSet)
        {
            Internal.Gravity = PhysicsWorld.Gravity;
            GravityIsSet = true;
        }
        CGroup ??= CollisionUtil.Solid;
        RigidPose pose = new((Internal.Position - PhysicsWorld.Offset).ToNumerics(), Internal.Orientation.ToNumerics());
        BodyVelocity velocity = new(Internal.LinearVelocity.ToNumerics(), Internal.AngularVelocity.ToNumerics());
        Shape = Shape.Register();
        CollidableDescription collidable = new(Shape.ShapeIndex, 0.1f, ContinuousDetection.Continuous(1e-4f, 1e-4f)) { MinimumSpeculativeMargin = 0.01f };
        BodyDescription description;
        if (Mass == 0)
        {
            description = BodyDescription.CreateKinematic(pose, velocity, collidable, new BodyActivityDescription(0.01f));
        }
        else
        {
            Shape.ComputeInertia(Internal.Mass, out BodyInertia inertia);
            description = BodyDescription.CreateDynamic(pose, velocity, inertia, collidable, new BodyActivityDescription(0.01f));
        }
        // TODO: Other settings
        SpawnedBody = PhysicsWorld.Spawn(this, description);
        Entity.OnTick += Tick;
        IsSpawned = true;
        TickUpdates();
    }

    /// <summary>Ticks the physics entity.</summary>
    public void Tick()
    {
        if (IsSpawned)
        {
            TickUpdates();
        }
    }

    /// <summary>Whether this entity was awake at last check.</summary>
    public bool WasAwake = true;

    /// <summary>Ticks external positioning updates.</summary>
    public void TickUpdates()
    {
        bool isAwake = SpawnedBody.Awake;
        if (!isAwake && !WasAwake)
        {
            return;
        }
        WasAwake = isAwake;
        bool shouldTrack = DoTrackPositionChange;
        DoTrackPositionChange = false;
        Internal.Position = Position;
        Entity.SetPosition(Internal.Position);
        Internal.Orientation = Orientation;
        Entity.SetOrientation(Internal.Orientation);
        DoTrackPositionChange = shouldTrack;
    }

    /// <summary>Updates the entity's local fields from spawned variant.</summary>
    public void UpdateFields()
    {
        float invMass = SpawnedBody.LocalInertia.InverseMass;
        Internal.Mass = invMass == 0 ? 0 : 1f / invMass;
        Internal.LinearVelocity = LinearVelocity;
        Internal.AngularVelocity = AngularVelocity;
        Internal.Position = Position;
        Internal.Orientation = Orientation;
    }

    /// <summary>Fired before the physics entity is despawned from the world.</summary>
    public Action DespawnEvent;

    /// <summary>Handles the physics entity being de-spawned from a world.</summary>
    public void DespawnHandle()
    {
        if (!IsSpawned)
        {
            return;
        }
        UpdateFields();
        Entity.OnTick -= Tick;
        DespawnEvent?.Invoke();
        PhysicsWorld.Despawn(SpawnedBody);
        Shape.Unregister();
        IsSpawned = false;
    }

    private bool HandledRemove = false;

    /// <summary>Handles removal event.</summary>
    public override void OnRemoved()
    {
        OnDespawn();
    }

    /// <summary>
    /// Applies a force directly to the physics entity's body.
    /// The force is assumed to be perfectly central to the entity.
    /// Note: this is a force, not a velocity. Mass is relevant.
    /// This will activate the entity.
    /// </summary>
    /// <param name="force">The force to apply.</param>
    public void ApplyForce(Location force)
    {
        if (IsSpawned)
        {
            SpawnedBody.ApplyLinearImpulse(force.ToNumerics());
            SpawnedBody.Awake = true;
        }
        else
        {
            LinearVelocity += force / Mass;
        }
    }

    /// <summary>
    /// Applies a force directly to the physics entity's body, at a specified relative origin point.
    /// The origin is relevant to the body's centerpoint.
    /// The further you get from the centerpoint, the more spin and less linear motion will be applied.
    /// Note: this is a force, not a velocity. Mass is relevant.
    /// This will activate the entity.
    /// </summary>
    /// <param name="origin">Where to apply the force at.</param>
    /// <param name="force">The force to apply.</param>
    public void ApplyForce(Location origin, Location force)
    {
        if (IsSpawned)
        {
            SpawnedBody.ApplyImpulse(force.ToNumerics(), origin.ToNumerics());
            SpawnedBody.Awake = true;
        }
        else
        {
            // TODO: Account for spin?
            LinearVelocity += force / Mass;
        }
    }

    /// <summary>Applies an angular force directly to the physics entity's body.
    /// Note: this is a force, not a velocity. Mass is relevant.
    /// This will activate the entity.</summary>
    /// <param name="force">The angular force vector.</param>
    public void ApplyAngularForce(Location force)
    {
        if (IsSpawned)
        {
            SpawnedBody.ApplyAngularImpulse(force.ToNumerics());
            SpawnedBody.Awake = true;
        }
        else
        {
            AngularVelocity += force / Mass;
        }
    }

    /// <summary>Performs a ray-trace against just this one entity.</summary>
    /// <param name="start">The starting location.</param>
    /// <param name="direction">The direction. Should be normalized in advance.</param>
    /// <param name="distance">The maximum distance before giving up.</param>
    public CollisionResult RayTrace(Location start, Location direction, double distance)
    {
        PhysicsSpace.InternalData.RayTraceHelper helper = new() { Space = PhysicsWorld, Start = start, Direction = direction, Hit = new() { Position = start + direction * distance, Time = distance } };
        helper.Hit.Position = start;
        helper.Hit.Normal = direction;
        if (!IsSpawned)
        {
            return helper.Hit;
        }
        float maximumT = (float)distance;
        TypedIndex shape = SpawnedBody.Collidable.Shape;
        RayData ray = new() { Direction = direction.ToNumerics(), Origin = (start - PhysicsWorld.Offset).ToNumerics() };
        PhysicsWorld.Internal.CoreSimulation.Shapes[shape.Type].RayTest(shape.Index, SpawnedBody.Pose, ray, ref maximumT, ref helper);
        if (helper.Hit.Hit)
        {
            helper.Hit.Position += PhysicsWorld.Offset;
        }
        return helper.Hit;
    }

    /// <summary>Performs a convex-sweep-cast-trace against just this one entity.</summary>
    /// <param name="shape">The shape to be sweeped.</param>
    /// <param name="shapeRotation">The rotation for the shape.</param>
    /// <param name="start">The starting location.</param>
    /// <param name="direction">The direction. Should be normalized in advance.</param>
    /// <param name="distance">The maximum distance before giving up.</param>
    public unsafe CollisionResult ConvexTrace(EntityShapeHelper shape, Quaternion shapeRotation, Location start, Location direction, double distance)
    {
        if (shape.BepuShape is not IConvexShape convexInput)
        {
            throw new ArgumentException("Shape must be convex.");
        }
        PhysicsSpace.InternalData.RayTraceHelper helper = new() { Space = PhysicsWorld, Start = start, Direction = direction, Hit = new() { Position = start + direction * distance, Time = distance } };
        if (!IsSpawned)
        {
            return helper.Hit;
        }
        Simulation simulation = PhysicsWorld.Internal.CoreSimulation;
        SweepTask task = simulation.NarrowPhase.SweepTaskRegistry.GetTask(shape.ShapeIndex.Type, Shape.ShapeIndex.Type);
        if (task is null)
        {
            // TODO: Should this be an error?
            return helper.Hit;
        }
        simulation.Shapes[shape.ShapeIndex.Type].GetShapeData(shape.ShapeIndex.Index, out void* shapePointer, out _);
        simulation.Shapes[Shape.ShapeIndex.Type].GetShapeData(shape.ShapeIndex.Index, out void* ownShapePointer, out _);
        // These estimate calculations from BEPU source, simplified for local specifics (direction.Length == 1, shape won't spin while moving, etc)
        convexInput.ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion);
        float minimumRadius = maximumRadius - maximumAngularExpansion;
        float sizeEstimate = Math.Max(minimumRadius, maximumRadius * 0.25f);
        float minimumProgressionDistance = 0.1f * sizeEstimate;
        float convergenceThresholdDistance = 1e-5f * sizeEstimate;
        float minimumProgressionT = minimumProgressionDistance;
        float convergenceThresholdT = convergenceThresholdDistance;
        const int maximumIterationCount = 25;
        // The BEPU sweep code is cursed and hypercomplicated. It's not really built for this type of call, it's meant for the actual main engine run.
        /* public unsafe bool Sweep<TSweepFilter>(
            void* shapeDataA, int shapeTypeA, Quaternion orientationA, in BodyVelocity velocityA,
            void* shapeDataB, int shapeTypeB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB,
            float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount,
            ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal)*/
        if (task.Sweep(shapePointer, shape.ShapeIndex.Type, shapeRotation.ToNumerics(), new BodyVelocity(direction.ToNumerics()),
            ownShapePointer, Shape.ShapeIndex.Type, SpawnedBody.Pose.Position - (start - PhysicsWorld.Offset).ToNumerics(), SpawnedBody.Pose.Orientation, new BodyVelocity(),
            (float) distance, minimumProgressionT, convergenceThresholdT, maximumIterationCount,
            ref helper, simulation.Shapes, simulation.NarrowPhase.SweepTaskRegistry, simulation.BufferPool, out _, out float t1, out _, out Vector3 hitNormal))
        {
            helper.Hit.Hit = true;
            helper.Hit.Position = start + direction * t1;
            helper.Hit.Normal = hitNormal.ToLocation();
            helper.Hit.Time = t1;
        }
        return helper.Hit;
    }

    /// <summary>Temporarily adjusts the linear damping, for exactly 1 physics-tick.</summary>
    /// <param name="damping">Damping to add.</param>
    public void ModifyLinearDamping(float damping)
    {
        float totalDamping = LinearDamping + LinearDampingBoost;
        float remainder = 1 - totalDamping;
        LinearDampingBoost += damping * remainder;
    }
    /// <summary>Temporarily adjusts the angular damping, for exactly 1 physics-tick.</summary>
    public void ModifyAngularDamping(float damping)
    {
        float totalDamping = AngularDamping + AngularDampingBoost;
        float remainder = 1 - totalDamping;
        AngularDampingBoost += damping * remainder;
    }
}
